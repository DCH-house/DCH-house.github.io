<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>短链接--回收站</title>
      <link href="/2024/03/25/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%9B%9E%E6%94%B6%E7%AB%99%E6%A8%A1%E5%9D%97/"/>
      <url>/2024/03/25/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%9B%9E%E6%94%B6%E7%AB%99%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解ThreadLocal</title>
      <link href="/2024/03/25/%E8%AF%A6%E8%A7%A3ThreadLocal/"/>
      <url>/2024/03/25/%E8%AF%A6%E8%A7%A3ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p><strong>起因</strong></p><p>​为什么要写这篇文章？作为一个java程序员，你会发现在很多项目中都会使用这个工具，不仅如此，ThreadLocal还是面试经常被问到的一个考点，由此可见ThreadLocal的重要性。我自己也在学习的过程中使用过ThreadLocal，但只停留在别人教我这里要使用，我就使用的层面，对于为什么要使用ThreadLocal以及它的工作原理都是懵懵懂懂的状态。因此想要借此文章系统整理一下关于ThreadLocal的知识点，从而加深对它的理解</p><p><strong>问题：ThreadLocal有什么用？</strong></p><p>​当你看到别人使用ThreadLocal时，你可能会问，为啥要使用ThreadLocal呢？因此，我们第一步需要知道ThreadLocal有什么用，它能解决什么问题。</p><p>​ThreadLocal最主要的用途就是用来保证线程间数据的相互隔离。什么意思呢？简单来说就是在多线程环境下，每个线程从ThreadLocal中获取的数据都是自己之前存放进去的数据，而不会是其他线程的数据。基于此特性，在很多场景下都能使用ThreadLocal，比如层与层间进行参数传递，这样只要在一层中向ThreadLocal中存入数据，在其他层就可以直接获取数据，而不用在方法中显式传参。其实我们大部分的使用场景都是进行参数传递。</p><p><strong>问题：ThreadLocal是如何工作的？</strong></p><p>​在了解了ThreadLocal的使用场景后，我们继续深入源码来了解ThreadLocal的工作原理，学习人家是如何保证线程间的数据隔离的。这里我们着重关注的是ThreadLocal的set()和get()方法(当然从中会牵扯出其他相关的方法)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以大概知道的是，set方法的底层会先获取当前线程，接着通过同类方法getMap获取一个ThreadLocalMap对象，最后以ThreadLocal对象为Key，要存放的数据为Value存放到ThreadLocalMap中。听完你可能脑袋里会有点晕晕的感觉，别急，我们接着往下看。<strong>首先我们要解决的问题是ThreadLocalMap是个什么东西？</strong></p><p>​我们先来看看ThreadLocal中的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们再来看看getMap()的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上源码大概可以知道以下信息：ThreadLocalMap是ThreadLocal中的一个静态内部类，并且每个线程中都有一个ThreadLocalMap属性。</p><p>以下是Thread中的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>至此，我们可以简单梳理一下调用set方法的整个过程，用一个流程图来表示</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3ThreadLocal/image-20240325133122399.png" alt="image-20240325133122399"></p><p><strong>你可能还会有疑问：为什么不直接用一个Map，在这个Map中Key存每个线程，Value存储每个线程对应的值呢？</strong></p><p>​这样做也能做到线程间数据的隔离，但是这种做法有一个问题：每个线程最多存放一个值，后面存放的值都会被覆盖。而jdk中实现的ThreadLocal，每个线程都拥有一个ThreadLocalMap，因此每个线程可以存放多个值，只需要new 一个对应的ThreadLocal即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;User&gt;tl1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;IdCard&gt; tl2 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">tl1.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">tl2.set(<span class="keyword">new</span> <span class="title class_">IdCard</span>());</span><br></pre></td></tr></table></figure><p>我们再来研究get方法，先来看下get方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有了上面的基础后，相信大家能够轻易的读懂这部分源码。一个很简单的逻辑：取出线程对应的ThreadLocalMap，再通过当前ThreadLocal取出对应的value，如果不存在map或Entry就返回一个默认值。这里有意思的是第5行代码，通过获取this对应的Entry来防止空指针异常。</p><p><strong>ThreadLocal中存在的问题</strong></p><p>​很多时候如果我们不正确的使用ThreadLocal可能会造成严重的后果，最为熟知的就是内存泄露问题。</p><p>这是因为ThreadLocalMap中的key是弱引用(请看上述ThreadLocalMap源码)，当外部不存在强引用时，就会被垃圾回收机制自动回收，但是value是一个强引用，只有当前线程结束运行后才会被回收，如果这些线程不结束运行的话，那么这些value就会一直存在，最后导致OOM。</p><p>虽然ThreadLocal中在进行set，get方法时底层都会调用expungeStaleEntry()来进行清理，但是在某些情况下依然会发生内存泄露，因此，一个良好的习惯依然是：<strong>当你不需要这个ThreadLocal变量时，主动调用remove()，这样对整个系统是有好处的</strong>。</p><p><strong>关于ThreadLocal的一些其他知识点</strong></p><p>​还有一些关于ThreadLocal的知识点也是需要我们了解的，比如ThreadLocalMap是通过开放寻址法来解决哈希冲突的；在ThreadLocal中还提供了一个可被继承的ThreadLocal——InheritableThreadLocal，支持父子线程间共享数据，有兴趣的朋友可以自行研究，由于笔者实力有限，只能写到这里(后续可能会去研究一下)。</p><p><strong>参考文章</strong>：</p><p><a href="https://juejin.cn/post/6959333602748268575?searchId=202403251121511D2E9479B2535F00B048">ThreadLocal使用与原理 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6854573219916021767?searchId=20240325204444A19FB94202EB263FCB6C">Java面试必问：ThreadLocal终极篇 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维</title>
      <link href="/2024/03/25/%E7%AE%97%E6%B3%95--%E6%80%9D%E7%BB%B4/"/>
      <url>/2024/03/25/%E7%AE%97%E6%B3%95--%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><strong>已知a + b + c + …+ n的和sum，求abc..n乘积的最大值</strong></p><p>结论：尽可能让a,b,c…&#x3D;3；</p><p>解题思路：<br>设将长度为 n 的竹子切为 a 段：</p><p>​n&#x3D;n<del>1</del>+n<del>2</del>+…+n<del>a</del></p><p>本题等价于求解：</p><p>max⁡(n<del>1</del>×n<del>2</del>×…×n<del>a</del>)<br>以下数学推导总体分为两步：(1) 当所有绳段长度相等时，乘积最大。(2) 最优的绳段长度为 3 。</p><p>数学推导：<br>以下公式为“算术几何均值不等式” ，等号当且仅当 n<del>1</del>&#x3D;n<del>2</del>&#x3D;…&#x3D;n<del>a</del>时成立。</p><p>​$\frac{n_1 + n_2 + … + n_a}{a} \geq \sqrt[a]{n_1 n_2 … n_a}$</p><p>推论一： 将竹子 以相等的长度等分为多段 ，得到的乘积最大。</p><p>设将竹子按照 x 长度等分为 a 段，即 n&#x3D;ax,则乘积为 x^a^  。观察以下公式，由于 n 为常数，因此当$x^{\frac{1}{x}}$取最大值时， 乘积达到最大值。</p><p>​$x^a &#x3D; x^{\frac{n}{x}}&#x3D;{x^{\frac{1}{x}}}^n$</p><p>根据分析，可将问题转化为求$y&#x3D;x^{\frac{1}{x}}$  的极大值，因此对 x求导数。</p><p>易得驻点为 x<del>0</del>&#x3D;e≈2.7.由于切分长度 x必须为整数，最接近 e 的整数为 2 或 3 。如下式所示，代入 x&#x3D;2和 x&#x3D;3，得出 x&#x3D;3 时，乘积达到最大。<br>推论二： 尽可能将竹子以长度 3 等分为多段时，乘积最大。</p><p>切分规则：<br>最优： 3 。把竹子尽可能切为多个长度为 3 的片段，留下的最后一段竹子的长度可能为 0,1,2 三种情况。<br>次优： 2 。若最后一段竹子长度为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若最后一段竹子长度为 1；则应把一份 3+1替换为 2+2，因为 2×2&gt;3×1。</p><p>作者：Krahets<br>链接：<a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/solutions/104809/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">https://leetcode.cn/problems/jian-sheng-zi-lcof/solutions/104809/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--短链接跳转</title>
      <link href="/2024/03/24/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/"/>
      <url>/2024/03/24/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：如何获取gid？</strong></p><p><strong>问题：为什么会发生缓存击穿问题？如何解决缓存击穿问题？</strong></p><p><strong>问题：什么是缓存预热？项目中哪里使用了缓存预热？为什么需要缓存预热？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--修改短链接</title>
      <link href="/2024/03/24/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E4%BF%AE%E6%94%B9%E7%9F%AD%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/03/24/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E4%BF%AE%E6%94%B9%E7%9F%AD%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><strong>修改短链接</strong></p><p>​针对短链接的修改操作，有以下两种情况。</p><ol><li>只修改短链接的基本信息，包括：需要跳转的长连接、有效期类型、有效期、是否启用、描述以及网站图标。针对这类修改，我们只需要更新数据库中对应的行即可。具体做法：</li><li>修改短链接所属的分组，针对这类修改，我们需要先删除掉原来的短链接数据，再将短链接添加到对应的分组下(短链接以gid作为分片件，因此在进行增删改查时都需要带上gid，gid变化短链接所在的表就会发生改变，需要删除该短链接原来表中对应的数据)</li></ol><p><strong>需要注意的是，本项目中的短链接不支持修改域名，在小码短链接平台更是连分组都不能修改</strong></p>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/2024/03/23/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2024/03/23/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：为什么要分库分表？[使用场景]</strong></p><p>​–解答：当一个系统的并发量非常大的时候，仅仅依赖一个数据库无法满足系统高可用、高性能以及高可扩展性的需求。一个最常见的限制条件就是数据库的连接数是有上限的，随着并发度的上升，系统性能瓶颈会集中在数据库上。</p><p>​另一个限制条件就是表中的数据量，当一张表中数据量达到了一定规模时，即使加了索引等优化操作查询效率依然不高。</p><p>​分库分表技术就是对上述问题进行优化，以此提高系统性能。</p><p><strong>问题：什么是分库分表？</strong></p><p>​–解答：分库分表其实包含了三种操作：分库、分表和分库分表。</p><p><strong>分库</strong></p><p>​正如我们刚刚讲到的，当一个系统的并发量非常大的时候，仅仅依靠单个数据库无法满足需求。一种最直接的解决方案就是增加数据库的数量，这就是分库操作的实质，就是通过增加数据库的数量进而增加并发量，解决的是并发量过高的问题。比如可以将一个电商数据库拆分为订单数据库、物流数据库、商品数据库和用户数据库</p><p><img src="/../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20240325220600013.png" alt="image-20240325220600013"></p><p>如果某个数据库的并发度还非常大，可以继续执行分库操作，但维护成本也会相应的增大。</p><p><strong>分表</strong></p><p>​分表操作解决的是数据量大的问题，通过将数据拆分到多个表，减少单表的数据量，提高查询效率。在分表时通常有两种方式</p><ol><li>水平分表：每张表的字段相同，将数据分散在多张表中，减少的是单张表的行数。在实际应用中以水平分表这种方式居多(本人只使用过水平分表)</li><li>垂直分表：每张表的字段不同，减少的是单张表的列数</li></ol><p><strong>分库分表</strong></p><p>​如果以上两个问题同时存在即高并发量和大数据，就需要考虑分库分表操作了。不过在分库分表之前，可以先考虑⼀下能不能优化。⼀般来说，单表的⾏数如果超过了 500 万或者单表容量超过 2 GB 之后，就需要考虑做分库分表了，⼩于这个数据量的时候，遇到性能问题可以通过其他⽅式来进⾏优化。</p><p>PS：以上数据量是阿⾥巴巴 Java 开发⼿册中给出的数据，仅供参考</p><p><strong>在讲完了为什么要使用分库分表后以及关于分库分表的一些概念后，接下来进入重点：如何分库分表</strong></p><ol><li><p><strong>数据库的基本优化</strong>：做好索引、减少多表 join、减少冗余字段</p></li><li><p><strong>减少数据库压⼒</strong>：在数据库之前加⼀层缓存，把⼀些可以接受延迟的，以及数据库变化频率较低的内容放到本地缓存或者分布式缓存当中。</p></li><li><p><strong>冷热数据的隔离</strong>：即数据归档，可以将⼀些更新以及不经常使⽤的数据单独隔离出来，可以放到历史表或者离线数仓当中，减少表中的数据量来提升效率</p></li><li><p><strong>数据库分区</strong>：数据库分区之后，将数据存储在不同的表当中，尽量减少单表的数据量，提升查询性能。</p></li><li><p><strong>分布式数据库</strong>：将数据分散到多个节点上，提升容量</p></li></ol><p><strong>问题：分区和分表有什么区别？</strong></p><p>​–解答：我们上面提过⼀个点，就是在数据库中，如果数据量⽐较⼤的话，优先考虑的是如何对数据进行优化，而不是进行分库分表，这两个过程有什么区别？我们现在来探究⼀下。首先我们先说⼀个点，就是分区和分表相同的点，都是按照⼀定的规则，对⼀张数据量特别大的表进行分解，使得表的数据量减少，从而提高查询效率。这样听起来你可能感觉没差多少，因为两者的区别都是把表进行拆分，那具体有什么差别吗？</p><p>主要就是分区和分表后数据的存储⽅式发⽣了变化。</p><p>这个要从 MySQL 的索引说起，在 Innodb 中（8.0之前），表存储主要依赖两个⽂件，分别是 .frm ⽂件和.ibd ⽂件。.frm⽂件⽤于存储表结构定义信息(也就是我们使用desc table得到的结构)，⽽.ibd⽂件则⽤于存储表数据。</p><p>分区增加的只是.ibd文件的数量，这些.ibd文件共用同一个.frm文件；而分表不仅会增加.ibd文件并且每个.ibd文件都会有一个独立的.frm文件。简单来说就是，分区实际上还是一张表，而分表则是真正将一张表拆分为多张表。</p><p><strong>分区结构</strong></p><p><img src="/../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20240324122916989.png" alt="image-20240324122916989"></p><p><strong>分表结构</strong></p><p><img src="/../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20240324124041738.png" alt="image-20240324124041738"></p><p><strong>问题：为什么不优先考虑分表呢？即分表操作有哪些问题？</strong></p><p>​–解答：</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--短链接管理之查询短链接</title>
      <link href="/2024/03/22/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9D%97%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9F%AD%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/03/22/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9D%97%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9F%AD%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>​–解答：</p><hr><p>根据gid分页查询短链接Service层代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getShortLinkByPage</span><span class="params">(ShortLinkPageReqDTO requestParam)</span>&#123;</span><br><span class="line">    Page&lt;ShortLinkDO&gt; shortLinkDOPage = <span class="keyword">new</span> <span class="title class_">Page</span>(requestParam.getCurrent(), requestParam.getSize());</span><br><span class="line">    LambdaQueryWrapper&lt;ShortLinkDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(ShortLinkDO::getGid,requestParam.getGid());</span><br><span class="line">    Page&lt;ShortLinkDO&gt; pages = shortLinkMapper.selectPage(shortLinkDOPage, queryWrapper);</span><br><span class="line"></span><br><span class="line">    pages.convert(each -&gt; BeanUtil.copyProperties(each, ShortLinkPageResDTO.class));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Results.success(pages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--短链接管理之新增短链接</title>
      <link href="/2024/03/20/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
      <url>/2024/03/20/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：什么是短链接？有什么作用？</strong></p><p><strong>问题：短链接是如何实现页面跳转的？</strong></p><p><strong>问题：如何生成短链接？短链接生成算法是什么？</strong></p><p><strong>问题：为什么使用这种算法？</strong></p><p><strong>问题：为什么短链接表要以gid作为分片件？</strong></p><p>​–解答：这里主要是方便进行分页查询</p><p><strong>问题：哈希冲突怎么解决？</strong></p><p>​–解答：重试，随机一个UUID继续生成。</p><p><strong>问题：为什么使用UUID作为生成短链接？</strong></p><p>​–解答：每次重试的时候，由于UUID是随机生成的，冲突的概率更小</p><p><strong>问题：为什么建议Spring使用构造注入？</strong></p><p><strong>问题：为什么一个表中往往有两个id字段？</strong></p><p><strong>问题：为什么使用布隆过滤器？</strong></p><p>​–解答：这里的目的是我们在生成一个短链接后需要查看数据库中是否已经存在该短链接。一种最直接的实现方案是直接查询数据库，但面对海量用户时，这种方案不仅性能低，而且由于数据库存在最大连接数，无法支持海量用户。布隆过滤器可以快速的判断出数据库是否存在此短链接，性能高。</p><p><strong>问题：为什么不使用set来判断是否存在短链接呢？</strong></p><p>​–解答：布隆过滤器本身是由一个二进制位数组和多个哈希函数组成，工作原理是将key通过哈希函数映射到二进制数组的对应位置，因此所需要的内存是非常小的。<strong>set还存在大key问题？</strong></p><p><strong>问题：针对布隆过滤器的误判如何解决？</strong></p><p>​–虽然布隆过滤器的性能非常好，但是存在误判的可能，由于其本质上是一种哈希算法，那么就必然会出现哈希冲突，即两个不同的key映射成相同的值。布隆过滤器可以判断数据库中一定不存在某个值，但当布隆过滤器判断数据库中存在某个值时，可能是误判导致，针对误判问题，我的解决方案是先查询数据库判断是否的确存在该短链接，如果不存在，直接返回生成的短链接，否则进入重试。</p><p><strong>问题：当布隆过滤器的内存快满时，此时误判率极高，如何优化？</strong></p><p><strong>问题：同一时间，有多个创建短链接的请求，这些请求生成的短链接完全一致并且布隆过滤器不存在该链接，这些请求是不是都会插入到数据库中？</strong></p><p>​–解答：这是一个很好的问题，在线程并发情况下，很容易出现这种情况。我的解决方案也很简单，就是将数据库的full_short_url字段标识为unique约束，这样就能够避免以上问题了，因为数据库中不允许相同的full_short_url内容出现，因此这些请求中只有一个能够成功，其余请求都会报错。</p><p><strong>问题：也就是说所有请求都会打到数据库，这种方案遇到海量请求是否有问题？如何解决？</strong></p><hr><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shortLink project 服务实现层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortLinkServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShortLinkMapper, ShortLinkDO&gt; <span class="keyword">implements</span> <span class="title class_">ShortLinkService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布隆过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RBloomFilter&lt;String&gt; shortLinkExistOrNotBloomFilter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShortLinkMapper shortLinkMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建短链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createShortLink</span><span class="params">(ShortLinkCreateReqDTO requestParam)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">validDateType</span> <span class="operator">=</span> requestParam.getValidDateType();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">shortLinkSuffix</span> <span class="operator">=</span> generateSuffix(requestParam.getDomain());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">fullShortUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        fullShortUrl.append(requestParam.getDomain()).append(<span class="string">&quot;/&quot;</span>).append(shortLinkSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> ShortLinkDO.builder().domain(requestParam.getDomain())</span><br><span class="line">                .originUrl(requestParam.getOriginUrl())</span><br><span class="line">                .gid(requestParam.getGid())</span><br><span class="line">                .fullShortUrl(fullShortUrl.toString())</span><br><span class="line">                .enableStatus(requestParam.getEnableStatus())</span><br><span class="line">                .shortUri(shortLinkSuffix)</span><br><span class="line">                .createType(requestParam.getCreateType())</span><br><span class="line">                .describe(requestParam.getDescribe()).build();</span><br><span class="line">        <span class="keyword">if</span>(validDateType == <span class="number">0</span>)&#123;</span><br><span class="line">            shortLinkDO.setValidDateType(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            shortLinkDO.setValidDateType(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">validDate</span> <span class="operator">=</span> requestParam.getValidDate();</span><br><span class="line">            shortLinkDO.setValidDate(validDate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            shortLinkMapper.insert(shortLinkDO);</span><br><span class="line">            shortLinkExistOrNotBloomFilter.add(fullShortUrl.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServerException</span>(String.format(<span class="string">&quot;短链接：%s生成重复&quot;</span>,fullShortUrl.toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Results.success(BeanUtil.copyProperties(shortLinkDO, ShortLinkCreateResDTO.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成短链接后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateSuffix</span><span class="params">(String domain)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;生成短链接重试次数达到10次&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1. 使用UUID生成短链接后缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shortLinkSuffix</span> <span class="operator">=</span> HashUtil.hashToBase62(UUID.randomUUID().toString(<span class="literal">true</span>));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            url.append(domain).append(<span class="string">&quot;/&quot;</span>).append(shortLinkSuffix);</span><br><span class="line">            <span class="comment">//2. 通过布隆过滤器判断是否已经存在该短链接</span></span><br><span class="line">            <span class="keyword">if</span>(!shortLinkExistOrNotBloomFilter.contains(url.toString()))&#123;</span><br><span class="line">                <span class="comment">//如果不存在，说明数据库中一定不存在该短链接</span></span><br><span class="line">                res = shortLinkSuffix;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//布隆过滤器判断数据库中存在该短链接，但有误判的可能，需要查询数据库中是否存在该短链接</span></span><br><span class="line">                LambdaQueryWrapper&lt;ShortLinkDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">                queryWrapper.eq(ShortLinkDO::getFullShortUrl,url);</span><br><span class="line">                <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> shortLinkMapper.selectOne(queryWrapper);</span><br><span class="line">                <span class="keyword">if</span>(shortLinkDO == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//布隆过滤器误判，数据库中其实没有该短链接</span></span><br><span class="line">                    res = shortLinkSuffix;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//重试</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--原理篇1理论基础</title>
      <link href="/2024/03/20/JUC%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86%E7%AF%871/"/>
      <url>/2024/03/20/JUC%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86%E7%AF%871/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：为什么需要多线程？</strong></p><p>​–解答：使用多线程的主要目的是提高CPU的执行效率，比如某个正在运行的线程处于等待状态时，就可以让CPU去执行另一个任务，充分利用CPU资源，提高系统性能。</p><p>多线程有两种形式：并行和并发，两者的本质区别是并行能够真正做到两个事件同时运行，而并发在宏观上是同时运行，微观上是交替运行。我们主要讨论的是并发。</p><p><strong>问题：为什么会出现线程并发安全问题？</strong></p><p>​–解答：线程并发问题发生在多个线程间共享某个数据，又同时操作该数据的情况。本质上是由以下三个问题造成：可见性、原子性和有序性。</p><p>​可见性问题指的是某个线程修改了某个变量后还没有写入主存(还在高速缓存中)，另一个线程就从主存中读取了该变量的旧数据，并对旧数据进行操作。比如i一开始等于10，线程1将其修改为15，此时15存储在缓存中，此时线程2取出i(10)，并将其修改为12，最后i的值可能是12也可能是15.</p><p>​原子性问题：java中一些操作在底层可能是由多条指令构成，CPU在同一时刻只能执行一条指令，那么就可能有这种情况发生：某个线程的操作执行一半时，CPU被移交给另一个线程，操作的数据又是同一个，最终也得不到我们想要的结果。</p><p>​有序性问题：程序执行时，可能不会按照我们编写的代码顺序执行。因为为了提高性能，编译器和处理器常常会对指令做重排序。</p><ol><li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</p></li></ol><p><strong>问题：java是如何解决并发问题的？</strong></p><p>​–解答：(在java中通过JMM(java 内存模型)来解决并发问题。)使用了volatile、synchronized和final关键字以及Happens-Before规则。</p><p>​使用synchronized和Lock可以保证操作执行的原子性，只有一个线程执行对应代码块。</p><p>​使用volatile关键字可以保证被修改的值立即更新到主存中，这样另一个线程就不会取出旧数据了。(另外使用synchronized和Lock也能够保证可见性，因为在锁释放之前，会将共享变量的值更新到主存中)</p><p>​可以使用volatile保证一定的有序性，synchronized和Lock由于保证只有一个线程可以执行同步代码块，也能保证有序性。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--同步模式</title>
      <link href="/2024/03/20/JUC%E5%AD%A6%E4%B9%A0--%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/20/JUC%E5%AD%A6%E4%B9%A0--%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：如何保证线程按照某个顺序运行？</strong></p><p><strong>问题：如何实现线程的交替执行？</strong></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--用户登录以及设置用户信息到上下文</title>
      <link href="/2024/03/19/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BB%A5%E5%8F%8A%E5%B0%81%E8%A3%85%E7%94%A8%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2024/03/19/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BB%A5%E5%8F%8A%E5%B0%81%E8%A3%85%E7%94%A8%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：如何保持用户的登录状态？</strong></p><p>–解答：可以使用session-cookie机制来维持用户的登录状态，但也可以使用token来保持用户的登录状态，这里使用的是token。其实不管是session，cookie还是token，它们实现鉴权的原理是一样的。就是当你登录成功后，会生成一个凭证，并且将该凭证返回给浏览器，当浏览器向该服务器发送任何请求时都会带上该凭证，而服务器会查看是否有与此凭证对应的物品来判断该用户是否是登录状态。</p><p> <strong>问题：那这是不是意味着这个物品可以是任意的，比如所有的凭证对应的物品都是同一个？</strong></p><p>​–解答：理论上是可以这样的，但很多时候我们需要限制凭证的有效时间，如果这样设计的话，就无法实现该要求。因此我们的建议是尽量一个凭证对应一个不同的物品，这样当某个凭证的有效期到了，我们需要删除其对应的物品，基于此，我们还要保证凭证的唯一性，毕竟删除别人的凭证不是一件好事。<strong>后面我会解释是如何保证生成的token的唯一性的。你可能会问为什么不用username作为唯一标识符</strong>，因为本身我们将这些数据存储进redis，就是因为要在其他地方获得用户数据，这说明其他地方是无法直接获得username的，如果将username作为key，就达不到我们想要的效果。</p><p><strong>问题：token和session、cookie有什么区别？为什么使用token而不使用session和cookie？</strong></p><p>​–解答：<a href="https://juejin.cn/post/6844904034181070861">傻傻分不清之 Cookie、Session、Token、JWT - 掘金 (juejin.cn)</a></p><p><strong>问题：为什么要将一个UserInfo对象存进Redis中？为什么使用Redis？</strong></p><p>​–解答：这里一个重要的原因是我不希望某些人反复登录导致多次请求数据库，所以我的做法是第二次及以后的登录请求都将打到Redis中，redis的性能高，反复请求也不会有影响。这里还有一个redis过期时间的小优化，后续会完成，只要用户保持活跃，就通过拦截器不断更新其过期时间。另一个重要原因是我们需要在其他页面使用该用户的信息。事实上如果你只是达成第一个目的的话，可以不存储对象，而是利用redis的hash结构只存储用户名和密码。我这么做的原因是对象更加方便灵活，如果后期需要扩展的话，我可以在该对象中增减字段，从而满足其他页面的需求。选用redis的原因很简单，一是因为其查询性能快；二是因为其key-value的存储格式非常适合我们的要求。</p><p><strong>问题：将token作为key，用户对象作为value存储在redis中，不会有安全风险吗，比如其他人可以盗用你的token发送给服务器直接获取你的登录状态然后修改你的信息？</strong></p><p>​–解答：针对以上问题，目前我没有设置避免token泄露的措施(没学，后期有时间可以研究以下)，根据网上搜索的答案可知有以下解决方案：</p><p>首先，Token 一般放在 Header 或者 Cookies 中，Http 是明文传输，Https 是密文传输。可以一定程度防止Token 截获。<br>第二，Token 一般会和 Ip，MAC地址，或者 DeviceID 进行绑定。如果服务端检测这些发生了变化，可以将 Token 失效让用户重新登录。<br>第三，Token 可以加密，例如AES对称加密，客户端与服务端先交换对称秘钥之后用对称秘钥将 Token + 当前时间戳 对称加密后发往服务端解密验证 Token 和时间戳都有效。或者直接通过 RSA 公钥加密。增加了截取成本。<br>第四，敏感操作一般要求二次安全验证，例如支付的时候，需要支付密码，或者验证手机短信验证码等等。</p><p><strong>问题：为什么需要设置用户信息到上下文？</strong></p><p>​–解答：在某个线程中，需要将某些数据(比如登录用户的信息)共享到多个方法，如果每个方法在获取这些数据时都通过访问redis。太麻烦，不够优雅。一般我们会在拦截器鉴权的时候，将从redis获得的用户信息存入ThreadLocal中，这样在后续过程中需要用户信息时可以直接从ThreadLocal中获取。关于ThreadLocal的使用场景可以参考以下文章</p><p><a href="https://cloud.tencent.com/developer/article/1636025">Java-ThreadLocal三种使用场景-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>问题：为什么本项目使用TransmittableThreadLocal呢？ThreadLocal存在哪些问题呢？</strong></p><p><strong>问题：在拦截请求时，为了区分用户注册的请求和修改用户信息的请求，我的做法是修改后者的请求路径，这并不优雅，因为违反了restful规范，但目前我只能这么做，有没有更好的方法？</strong></p><p>​–解答：使用过滤器进行请求拦截可以做到这点，在请求路径相同的情况下，过滤器可以根据请求方法的不同进行拦截。个人感觉拦截器更加方便，所以项目中使用的还是拦截器。</p><hr><p>代码实现区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户接口实现层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, UserDO&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布隆过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RBloomFilter&lt;String&gt; userRegisterCachePenetrationBloomFilter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;UserDO&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取用户脱敏信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;UserDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(UserDO::getUsername,username);</span><br><span class="line">        <span class="type">UserDO</span> <span class="variable">userDO</span> <span class="operator">=</span> userMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="type">UserRespDTO</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRespDTO</span>();</span><br><span class="line">        <span class="comment">//将UserDO中的属性封装到result中</span></span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_NAME_NOT_EXIST_ERROR.code(),BaseErrorCode.USER_NAME_NOT_EXIST_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanUtils.copyProperties(userDO,result);</span><br><span class="line">        <span class="keyword">return</span> Results.success(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取用户未脱敏信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getActualUserByUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;UserDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(UserDO::getUsername,username);</span><br><span class="line">        <span class="type">UserDO</span> <span class="variable">userDO</span> <span class="operator">=</span> userMapper.selectOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserRespActualDTO</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRespActualDTO</span>();</span><br><span class="line">        <span class="comment">//将UserDO中的属性封装到result中</span></span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_NAME_NOT_EXIST_ERROR.code(),BaseErrorCode.USER_NAME_NOT_EXIST_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanUtils.copyProperties(userDO,result);</span><br><span class="line">        <span class="keyword">return</span> Results.success(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用布隆过滤器判断该用户名是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hasUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userRegisterCachePenetrationBloomFilter.contains(username))&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_NAME_EXIST_ERROR.code(),BaseErrorCode.USER_NAME_EXIST_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Results.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">registerUser</span><span class="params">(UserReqDTO user)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userRegisterCachePenetrationBloomFilter.contains(user.getUsername()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_NAME_EXIST_ERROR.code(),BaseErrorCode.USER_NAME_EXIST_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用分布式锁解决海量同用户名请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> UserCacheConstants.USER_REGISTER_LOCK + user.getUsername();</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">                <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_NAME_LOCK_ACQUIRE_ERROR.code(), BaseErrorCode.USER_NAME_LOCK_ACQUIRE_ERROR.message());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">UserDO</span> <span class="variable">userDO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDO.class);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">saveSuccess</span> <span class="operator">=</span> save(userDO);</span><br><span class="line">            <span class="keyword">if</span>(!saveSuccess)&#123;</span><br><span class="line">                <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_REGISTER_ERROR.code(), BaseErrorCode.USER_REGISTER_ERROR.message());</span><br><span class="line">            &#125;</span><br><span class="line">            userRegisterCachePenetrationBloomFilter.add(user.getUsername());</span><br><span class="line">            stringRedisTemplate.opsForValue().set(user.getUsername(),user.getPassword(),<span class="number">30</span>,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> Results.success(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">updateUser</span><span class="params">(UserUpdateReqDTO user)</span>&#123;</span><br><span class="line">        LambdaUpdateWrapper&lt;UserDO&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="type">UserDO</span> <span class="variable">userDO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDO.class);</span><br><span class="line">        updateWrapper.eq(UserDO::getUsername,user.getUsername());</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.update(userDO, updateWrapper);</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_UPDATE_ERROR.code(),BaseErrorCode.USER_UPDATE_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Results.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">userLogin</span><span class="params">(UserReqLoginDTO user,String token)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!userRegisterCachePenetrationBloomFilter.contains(user.getUsername())) &#123;</span><br><span class="line">            <span class="comment">//数据库中不存在该用户，解决缓存穿透问题</span></span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_NAME_NOT_EXIST_ERROR.code(), BaseErrorCode.USER_NAME_NOT_EXIST_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUserStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(UserCacheConstants.USER_LOGIN_KEY + token);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(jsonUserStr))&#123;</span><br><span class="line">            <span class="comment">//redis中有该用户</span></span><br><span class="line">            <span class="type">UserInfoDTO</span> <span class="variable">userInfoDTO</span> <span class="operator">=</span> JSONUtil.toBean(jsonUserStr, UserInfoDTO.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(userInfoDTO != <span class="literal">null</span> &amp;&amp; userInfoDTO.getUsername().equals(user.getUsername()) &amp;&amp; userInfoDTO.getPassword().equals(user.getPassword()))&#123;</span><br><span class="line">                <span class="comment">//用户已经处于登录状态</span></span><br><span class="line">                <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_LOGIN_ERROR.code(),BaseErrorCode.USER_LOGIN_ERROR.message());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String loginToken;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//生成唯一token</span></span><br><span class="line">            loginToken = UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span>(stringRedisTemplate.opsForValue().get(UserCacheConstants.USER_LOGIN_KEY + loginToken) == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//redis中没有该token</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次登录发生数据不一致，从数据库中查询</span></span><br><span class="line">        LambdaQueryWrapper&lt;UserDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(UserDO::getUsername,user.getUsername()).eq(UserDO::getPassword,user.getPassword());</span><br><span class="line">        <span class="type">UserDO</span> <span class="variable">userDO</span> <span class="operator">=</span> userMapper.selectOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//按理来说由于设置了布隆过滤器，不会执行这一步，这里是做兜底使用</span></span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_LOGIN_PASSWORD_ERROR.code(),BaseErrorCode.USER_LOGIN_PASSWORD_ERROR.message());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!user.getPassword().equals(userDO.getPassword()))&#123;</span><br><span class="line">            <span class="comment">//密码错误</span></span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_LOGIN_PASSWORD_ERROR.code(), BaseErrorCode.USER_LOGIN_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(UserCacheConstants.USER_LOGIN_KEY + loginToken, JSONUtil.toJsonStr(BeanUtil.copyProperties(user, UserInfoDTO.class)),UserCacheConstants.USER_LOGIN_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Results.success(loginToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户退出登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">userLogout</span><span class="params">(String username,String token)</span>&#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> stringRedisTemplate.delete(UserCacheConstants.USER_LOGIN_KEY + token);</span><br><span class="line">        <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure(BaseErrorCode.USER_LOGOUT_ERROR.code(),BaseErrorCode.USER_LOGOUT_ERROR.message());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Results.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录鉴权以及更新有效期,拦截器实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserIntercepterHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserIntercepterHandler</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUserInfoStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(UserCacheConstants.USER_LOGIN_KEY + token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(jsonUserInfoStr))&#123;</span><br><span class="line">            <span class="comment">//未登录用户，不放行</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新redis用户登录有效期</span></span><br><span class="line">        stringRedisTemplate.expire(UserCacheConstants.USER_LOGIN_KEY + token,UserCacheConstants.USER_LOGIN_TTL, TimeUnit.MINUTES);</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserInfoDTO</span> <span class="variable">userInfoDTO</span> <span class="operator">=</span> JSONUtil.toBean(jsonUserInfoStr, UserInfoDTO.class);</span><br><span class="line">        <span class="comment">//设置用户信息至上下文</span></span><br><span class="line">        UserContext.set(userInfoDTO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//及时清除</span></span><br><span class="line">        UserContext.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntercepterConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserIntercepterHandler</span>(stringRedisTemplate))</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/api/short-link/v1/user&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/api/short-link/v1/user/login&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目使用Feed流实现用户推送</title>
      <link href="/2024/03/19/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Feed%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%8E%A8%E9%80%81/"/>
      <url>/2024/03/19/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Feed%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：如何实现点赞排行榜功能？</strong></p><p><strong>问题：Feed流有哪些实现方案？</strong></p><p><strong>问题：为什么选用推模式实现用户推送？</strong></p><p><strong>问题：推拉结合模式有了解过吗？</strong></p><p><strong>问题：为什么使用SortedSet实现用户收件箱？</strong></p><p><strong>问题：滚动分页有何难点？如何解决？</strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--多把锁以及死锁</title>
      <link href="/2024/03/19/JUC%E5%AD%A6%E4%B9%A0--%E5%A4%9A%E6%8A%8A%E9%94%81%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81/"/>
      <url>/2024/03/19/JUC%E5%AD%A6%E4%B9%A0--%E5%A4%9A%E6%8A%8A%E9%94%81%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：为什么需要多把锁？</strong></p><p><strong>问题：什么是死锁？</strong></p><p><strong>问题：如何解决死锁？</strong></p><p><strong>有哪些工具定位死锁？</strong></p><p>​–解答：jstack、jconsole</p><p><strong>问题：什么是活锁？如何解决？</strong></p><p><strong>问题：如何理解线程的饥饿现象？如何解决？</strong></p><p><strong>问题：ReentrantLock有什么特性？相较于Synchronized有什么区别？</strong></p><p>​可重入、可打断、超时、公平锁、条件变量</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习1</title>
      <link href="/2024/03/18/JVM%E5%AD%A6%E4%B9%A01/"/>
      <url>/2024/03/18/JVM%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：什么是JVM？</strong></p><p><strong>问题：为什么需要JVM？</strong></p><p><strong>问题：JVM和JDK有什么关系？</strong></p><p><strong>问题：什么是字节码文件？</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--分组</title>
      <link href="/2024/03/17/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%88%86%E7%BB%84%E6%A8%A1%E5%9D%97/"/>
      <url>/2024/03/17/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%88%86%E7%BB%84%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：为什么要分组？如何实现？</strong></p><p>​–解答：分组可以使用户更好的管理自己的短链接</p><p><strong>问题：gid是全局唯一的吗？如何保证？</strong></p><p>​–解答：gid是全局唯一的。设计方案为：首先使用Hutool的工具生成一个长度为6的随机字符串，然后会去数据库中查询是否已经存在该gid，如果存在则重新生成gid，这个过程会一直循环，直至生成的gid唯一。</p><p><strong>问题：分组分表时以什么作为分片件？</strong></p><p>​–解答：我选择的是username，这样可以保证同一个用户创建的分组在同一个表中。</p><hr><p>实现代码：有很多地方写的不是很优雅，有时间再改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分组服务实现层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;GroupMapper, GroupDO&gt;<span class="keyword">implements</span> <span class="title class_">GroupService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GroupMapper groupMapper;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createGroup</span><span class="params">(GroupReqDTO group)</span>&#123;</span><br><span class="line">        <span class="type">GroupDO</span> <span class="variable">groupDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupDO</span>();</span><br><span class="line">        String gid;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//防止gid重复</span></span><br><span class="line">            gid = RandomUtil.randomString(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span>(!getGroup(gid))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        groupDO.setGid(gid);</span><br><span class="line">        groupDO.setName(group.getName());</span><br><span class="line">        groupDO.setSortOrder(<span class="number">0</span>);</span><br><span class="line">        groupDO.setUsername(UserContext.get().getUsername());</span><br><span class="line"></span><br><span class="line">        save(groupDO);</span><br><span class="line">        <span class="keyword">return</span> Results.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">deleteGroupByGid</span><span class="params">(String gid)</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;GroupDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(GroupDO::getGid,gid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> groupMapper.delete(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(delete &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Results.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">updateGroup</span><span class="params">(String name,String gid)</span>&#123;</span><br><span class="line">        LambdaUpdateWrapper&lt;GroupDO&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        updateWrapper.eq(GroupDO::getGid,gid).set(GroupDO::getName,name);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update(updateWrapper);</span><br><span class="line">        <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">            <span class="keyword">return</span> Results.failure();</span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;GroupDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(GroupDO::getGid,gid);</span><br><span class="line">        <span class="type">GroupDO</span> <span class="variable">groupDO</span> <span class="operator">=</span> groupMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="type">GroupRespDTO</span> <span class="variable">groupRespDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(groupDO, GroupRespDTO.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Results.success(groupRespDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分组排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sortGroup</span><span class="params">(List&lt;GroupSortReqDTO&gt;groups)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(GroupSortReqDTO group : groups)&#123;</span><br><span class="line">            username = group.getUsername();</span><br><span class="line">            <span class="type">String</span> <span class="variable">gid</span> <span class="operator">=</span> group.getGid();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sortOrder</span> <span class="operator">=</span> group.getSortOrder();</span><br><span class="line"></span><br><span class="line">            LambdaUpdateWrapper&lt;GroupDO&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">            updateWrapper.eq(GroupDO::getGid,gid).set(GroupDO::getSortOrder,sortOrder);</span><br><span class="line">            update(updateWrapper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;GroupDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(GroupDO::getUsername,username).orderByDesc(GroupDO::getSortOrder);</span><br><span class="line">        List&lt;GroupDO&gt; groupDOS = groupMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">        List&lt;GroupRespDTO&gt;res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(GroupDO g : groupDOS)&#123;</span><br><span class="line">            res.add(BeanUtil.copyProperties(g, GroupRespDTO.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Results.success(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判读数据库中是否有该分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getGroup</span><span class="params">(String gid)</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;GroupDO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(GroupDO::getGid,gid);</span><br><span class="line">        <span class="type">GroupDO</span> <span class="variable">groupDO</span> <span class="operator">=</span> getOne(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(groupDO == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--park和unpark</title>
      <link href="/2024/03/17/JUC%E5%AD%A6%E4%B9%A0--park%E5%92%8Cunpark/"/>
      <url>/2024/03/17/JUC%E5%AD%A6%E4%B9%A0--park%E5%92%8Cunpark/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：park和unpark有什么作用？相较于wait和notify有什么优势？</strong></p><p>​–解答：park和unpark是LockSupport类中提供的两个方法，park()方法可以让正在运行的线程进入等待状态，而unpark()方法可以唤醒等待的线程。</p><p>​park和unpark不需要获取锁对象后才能使用，每个线程在任何时刻都能调用。相较于notify是随机的唤醒某个线程，unpark可以指定唤醒线程，更加精确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.concurrent.locks.LockSupport.park;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.concurrent.locks.LockSupport.unpark;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParkAndUnparkTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testParkAndUnpark</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;starting...&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;invoke park....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(<span class="string">&quot;starting again...&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        log.info(<span class="string">&quot;invoke unpark...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-18T18:<span class="number">20</span>:<span class="number">16.062</span>+08:<span class="number">00</span>  INFO <span class="number">19268</span> --- [           main] com.deng.ParkAndUnparkTest               : invoke unpark...</span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-18T18:<span class="number">20</span>:<span class="number">34.670</span>+08:<span class="number">00</span>  INFO <span class="number">19268</span> --- [             t1] com.deng.ParkAndUnparkTest               : starting...</span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-18T18:<span class="number">20</span>:<span class="number">35.662</span>+08:<span class="number">00</span>  INFO <span class="number">19268</span> --- [             t1] com.deng.ParkAndUnparkTest               : invoke park....</span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-18T18:<span class="number">21</span>:<span class="number">06.457</span>+08:<span class="number">00</span>  INFO <span class="number">19268</span> --- [             t1] com.deng.ParkAndUnparkTest               : starting again...</span><br></pre></td></tr></table></figure><p><strong>问题：为什么unpark可以作用于park之前</strong></p><p>​–解答：在上述例子中，我们发现一个奇怪的现象：unpark可以在park之前执行，并且park后的线程并没有被阻塞，说明unpark起作用了，这是一个奇怪的现象。要想弄清这一点，我们必须要研究Thread在Java中是如何编写的。</p><p>​在Java中，每个线程都有自己的一个 Parker 对象，由三部分组成 _<em>counter ， _cond 和 _mutex</em>。当调用park方法时，线程会去检查 _counter的值如果为0(默认情况下就是0)，那么该线程会获得 _mutex互斥锁进入 _cond等待，并将counter置为0。当调用unpark时，会设置counter为1，并唤醒对应的线程，该线程发现counter为1，于是继续执行。</p><p>​因此线程调用park进入等待是因为此时线程的counter为0，如果不为0那么调用该方法不会让线程进入等待状态。这也是为什么在park之前调用unpark也会其作用的原因</p><p><strong>问题：那是不是可以在park之前调用多次unpark？</strong></p><p>​–解答：实际情况是，即使你调用了多次unpark，counter的值不会超过1，因此只能抵消一次park</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--设计模式</title>
      <link href="/2024/03/16/JUC%E5%AD%A6%E4%B9%A0--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/16/JUC%E5%AD%A6%E4%B9%A0--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：什么是保护性暂停设计模式？有何作用？</strong></p><p>​–解答：保护性暂停设计模式是一种维护线程间同步的的方法，比如需要在线程间传递某个数据，线程A只有获得该数据才能继续执行。这时就可以使用保护性暂停，让线程A进入等待状态直到数据到达并被唤醒，线程A继续执行。需要注意的是当线程间有多个数据需要传递时，保护性暂停设计模式无法满足需求，需要使用消息队列进行设计。</p><p>具体案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardedObject.get(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        guardedObject.put();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GuardedObject扩展超时机制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> System.currentTimeMillis() - begin;</span><br><span class="line">            <span class="keyword">while</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(passTime &gt; timeout)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait(timeout - passTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上代码使用保护性暂停设计模式模拟了这样一个场景：线程A等待线程B的输入，当A等待时间超过了给定的等待时间时，线程A不再等待，直接返回null。在java中如果你研究过join的源码，你会发现在join中也使用了这种机制。</p><p><strong>问题：什么是生产者-消费者模式？适用于什么场景？如何实现？</strong></p><p>​–解答：生产者-消费者模式是一种模型，这种模式不仅应用在计算机中，在生活中也有很多体现。具体来说模拟的是这样一种场景：一个人专门负责生产产品(生产者)，另一个人负责处理产品(消费者)。两者的工作是异步的，能够很好的解耦，两者通过某个中间站实现交互(称为消息队列)。这里面有一些规范，比如生产者只有在容器还未满的情况下才能向容器中放入产品，而消费者只有在容器不空的情况下才能从容器中取出产品。同样，这种模型也可以用于线程间的交互，以下就是一个使用该模式实现线程间交互的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ProducerAndConsumerModle</span> <span class="variable">producerAndConsumerModle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerAndConsumerModle</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        producerAndConsumerModle.producer();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        producerAndConsumerModle.consumer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerAndConsumerModle</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始生产产品&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(list.size() == <span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;容器已满，只能存储2个物品&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addFirst(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;已放入产品&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理产品&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;容器为空，无产品处理&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> list.removeLast();</span><br><span class="line">            System.out.println(<span class="string">&quot;已处理产品&quot;</span> + integer);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240318161119296.png" alt="image-20240318161119296"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--wait和notify</title>
      <link href="/2024/03/16/JUC%E5%AD%A6%E4%B9%A0--wait%E5%92%8Cnotify/"/>
      <url>/2024/03/16/JUC%E5%AD%A6%E4%B9%A0--wait%E5%92%8Cnotify/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：wait()和notify()有什么作用？</strong></p><p>​–解答：这两个方法都是Object中提供的方法，用于线程间的协作交互。wait方法能够将当前占有锁的线程进入等待状态，notify则可以唤醒等待队列中的一个线程</p><p><strong>问题：wait()和sleep()有什么区别？</strong></p><p>​–解答：这两个方法都能够使当前运行的线程进入等待状态(Time_waiting)。不同的是，1. 前者是Object中提供的对象且只有在获取到了锁对象(进入了synchronized代码块)的线程才能使用。而sleep是Thread的静态方法，在任何时候都能够调用该方法；2. 在synchronized代码块中，调用wait方法后线程会释放锁并进入等待状态，而调用sleep方法线程只会进入等待状态不会释放锁。在并发编程中建议使用wait方法，而不要使用sleep方法让线程进入等待状态。</p><p><strong>问题：什么是虚假唤醒？如何解决？</strong></p><p>​–解答：虚假唤醒是指当等待队列中有多个线程处于等待状态时，如果使用notify方法想要唤醒某个线程，可能唤醒的并不是预期线程的情况。可以使用notifayAll方法替代notify方法，该方法会唤醒等待队列中的所有线程，其中只有一个线程等待的条件发生改变，能够继续执行，这样可以避免虚假唤醒。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目使用Redis实现消息队列异步处理秒杀订单</title>
      <link href="/2024/03/15/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%A7%92%E6%9D%80%E8%AE%A2%E5%8D%95/"/>
      <url>/2024/03/15/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%A7%92%E6%9D%80%E8%AE%A2%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：为什么需要消息队列？</strong></p><p>​–解答：当前项目中使用java中提供的阻塞队列来存储订单，该阻塞队列有两个问题：1. 内存受限，不能超过机器的内存；2. 一旦机器宕机，位于队列中的信息会全部丢失。而消息队列就是专门用于存放中间信息的，相当于一个中转站，它不受限于机器本身，是一个第三方的组件。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%A7%92%E6%9D%80%E8%AE%A2%E5%8D%95/image-20240315212305725.png" alt="image-20240315212305725"></p><p><strong>问题：如何使用Redis实现消息队列？为什么不使用List以及PubSub？</strong></p><p>​–解答：目前市面上有专门的消息队列组件比如：MQ、RabbitMQ、Kafaka等，但其实也可以使用Redis的Stream数据结构实现。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%A7%92%E6%9D%80%E8%AE%A2%E5%8D%95/image-20240315220322697.png" alt="image-20240315220322697"></p><p><strong>问题：什么情况下会发生Stream消息漏读的情况？如何解决？</strong></p><p>​–解答：当消费者进程由于某种原因停止运行，那么在这段时间内生产者发送的消息就会被遗漏。可以使用消费者组机制解决，具体来说就是将消费者归为某个组，当消费者出现问题后，恢复时可以选择从pending-list中读取消息，pending-list中存放的是那些未处理的消息。并且采用这种机制后，每个消息处理后消费者需要发送ACK表示已经处理完了该消息，该消息才能从pending-list中移除。</p><p>​总结一句话：采用消息确认机制来解决消息漏读问题。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%A7%92%E6%9D%80%E8%AE%A2%E5%8D%95/image-20240315214657878.png" alt="image-20240315214657878"></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 秒杀优惠券表，与优惠券是一对一关系 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-03-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucherServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SeckillVoucherMapper, SeckillVoucher&gt; <span class="keyword">implements</span> <span class="title class_">ISeckillVoucherService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdGenerator uniqueIdGenerator;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderMapper voucherOrderMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript redisScript;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageStream</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">        redisScript.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;/RedisWork.lua&quot;</span>));</span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService currentProxy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="comment">//项目一启动就检查阻塞队列中是否有未处理的订单，有就进行处理</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            handleVoucherOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据id从数据库中查询对应的优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2.判断该优惠券是否开始以及结束</span></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动已结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        keys.add(RedisConstants.SECKILL_STOCK_KEY + id);</span><br><span class="line">        keys.add(RedisConstants.SECKILL_VOUCHER_KEY + id);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">seckillVoucherOrderId</span> <span class="operator">=</span> uniqueIdGenerator.generatorId(RedisConstants.SECKILL_VOUCHER_ID_PREFIX);</span><br><span class="line">        <span class="comment">//调用lua脚本判断库存是否充足以及该用户是否已经购买过该秒杀券,并将满足条件的订单加入消息队列</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> (Long)stringRedisTemplate.execute(redisScript, keys, userid + <span class="string">&quot;&quot;</span>,id + <span class="string">&quot;&quot;</span>,seckillVoucherOrderId + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.生成订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//2.1 填入订单id，使用全局唯一id生成器生成</span></span><br><span class="line">        voucherOrder.setId(seckillVoucherOrderId);</span><br><span class="line">        <span class="comment">//2.2 填入用户id</span></span><br><span class="line">        voucherOrder.setUserId(userid);</span><br><span class="line">        <span class="comment">//2.3 填入优惠券id</span></span><br><span class="line">        voucherOrder.setVoucherId(id);</span><br><span class="line">        currentProxy = (ISeckillVoucherService) AopContext.currentProxy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不断从消息队列中读取消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//读取消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().block(Duration.ofSeconds(<span class="number">2</span>)).count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(messageStream, ReadOffset.lastConsumed()));</span><br><span class="line">                <span class="keyword">if</span>(read.isEmpty() || read == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//未读到消息</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; message = read.get(<span class="number">0</span>);</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(message.getValue(), <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(),<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//ACK确认，注意：第137行和138行不可交换顺序，否则当更新数据库操作失败时，该订单会不翼而飞</span></span><br><span class="line">                currentProxy.createVoucherOrder(voucherOrder);</span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(messageStream,<span class="string">&quot;g1&quot;</span>,message.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                handlePaddinList();</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理订单过程发送异常，恢复时需要处理paddin-list中的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePaddinList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//读取消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(messageStream, ReadOffset.from(<span class="string">&quot;0&quot;</span>)));</span><br><span class="line">                <span class="keyword">if</span>(read.isEmpty() || read == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//未读到消息</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; message = read.get(<span class="number">0</span>);</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(message.getValue(), <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(),<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//ACK确认</span></span><br><span class="line">                currentProxy.createVoucherOrder(voucherOrder);</span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(messageStream,<span class="string">&quot;g1&quot;</span>,message.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理padding-list异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherOrder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//更新库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getId()).update();</span><br><span class="line">        voucherOrderMapper.insert(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--synchronized</title>
      <link href="/2024/03/14/JUC%E5%AD%A6%E4%B9%A0--Monitor/"/>
      <url>/2024/03/14/JUC%E5%AD%A6%E4%B9%A0--Monitor/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：什么是Monitor？</strong></p><p>​–解答：Monitor译为监视器，也叫管程。是一个同步工具，基于操作系统中的互斥锁实现。可以抽象为如下结构</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315122058095.png" alt="image-20240315122058095"></p><p><strong>问题：synchronized关键字是如何实现锁机制的？</strong></p><p>​–解答：java对象存储在堆中，具体来说由3部分组成：对象头、对象体和对齐字节。其中对象头中的Mark Word标记字(8字节)用来表示当前线程的锁状态。</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315125951203.png" alt="image-20240315125951203"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临界区</span></span><br><span class="line"><span class="keyword">synchronized</span>(Object o)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始，没有线程访问临界区，因此对象o的Mark Word是以下状态(后面会讲到，jvm做了优化，一开始锁对象其实是偏向锁的状态，偏向的是主线程)</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315125855032.png" alt="image-20240315125855032"></p><p>表明这是一个正常对象(即无锁状态)，此时，来了一个线程并且需要访问临界区，此时锁会升级为偏向锁，对象o的Mark Word的状态发生改变</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315130215486.png" alt="image-20240315130215486"></p><p>当一个线程访问临界区代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出临界区时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的线程ID。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>如果此时又来了另一个线程，并且也要访问临界区，锁会升级为轻量级锁。成功获取锁的线程会在自己的栈帧中创建一个Lock Recoder的空间，会将锁对象的Mark Word中的内容复制到该空间中，而Mark Word中会存放指向该空间的指针。如果该操作失败，JVM会查看锁对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经获得了锁，可以进入临界区。</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315134645348.png" alt="image-20240315134645348"></p><p>当资源竞争更加激烈时，锁对象会升级为重量级锁。锁对象的Mark Word会指向一个Monitor对象，成功获取该锁的线程会被存放在Monitor的owner中，对于获取锁失败的线程都会进入EntryList中陷入阻塞状态。</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315135926975.png" alt="image-20240315135926975"></p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/image-20240315135950638.png" alt="image-20240315135950638"></p><p><strong>问题：什么是轻量级锁，什么是重量级锁？两者有什么区别？</strong></p><p>​–解答：轻量级锁是将锁对象和线程绑定起来，轻量级锁主要用于线程分开访问临界区的情况；而重量级锁将锁对象和Monitor对象绑定，对于获取锁失败的线程直接进入自旋，如果失败进入阻塞状态，可以解决所有情况下的线程安全问题，但是性能差。轻量级锁可以升级为重量级锁</p><p><strong>问题：什么是锁膨胀？发生在什么情况下？这个过程是怎样的？</strong></p><p>​–解答：指锁升级。这个过程对用户来说是透明的，且过程不可逆。当锁已不能满足线程间并发访问资源时，就会发生锁膨胀。</p><p><strong>问题：什么是自旋优化？有什么作用？</strong></p><p>​–解答：自旋优化是锁的一种优化策略，指的是当线程获取锁失败时，不会立即进入阻塞状态，而是稍微等待一下再重试，重试几次都失败后再进入阻塞状态。可以减少唤醒操作，提高性能。</p><p><strong>问题：什么是偏向锁？有什么作用？</strong></p><p>​–解答：如上所述，偏向锁是一种非常低级的锁，主要用于只有一个线程访问临界区的情况，使用偏向锁不需要进行检查和CAS操作，性能好。默认情况下，每个对象的初始状态都是偏向锁状态，而不是无锁状态。</p><p><strong>问题：为什么调用了对象的hashCode方法后，会撤销偏向锁？而轻量级锁以及重量级锁无影响？</strong></p><p>​–解答：这和偏向锁实现的机制有关，当一个对象的状态变为偏向锁时，会将偏向线程的id存放在Mark Word的前54位中(见上图)。这54位有一部分原本是用来存放hashcode的值，但是在java中有一种特性：只有你调用了对象的hashcode方法后，这部分区域存放的才真正是hashcode的值，其他时候这部分存放的都是0，有点类似懒加载。因此当你调用了对象的hashcode后，就没有地方存放线程id了，自然就无法转换为偏向锁了。相较于偏向锁，轻量级锁和重量级锁在更换Mark Word中的内容之前，都会找一个容器存放起来，因此调用对象的hashcode方法时，依然可以转换为轻量级锁以及重量级锁。</p><p><strong>问题：什么是批量重偏向？有什么作用？</strong></p><p>​–解答：这是jvm中的一种优化策略，当同类型的锁偏向失败发生了19次后，第20次以及之后的偏向失败都会进行重偏向，锁对象会更改偏向线程，而不是升级为轻量级锁。</p><p><strong>问题：什么是批量撤销？发生在什么情况下？</strong></p><p>​–解答：当同类型的锁偏向失败39次时，第40次及之后的同类型锁对象都会撤销偏向锁状态(包括新创建的同类型的锁)</p><p><strong>问题：撤销之后会发生什么？</strong></p><p>​解答：按照正常的流程走，只是不能转换为偏向锁而已，可以升级为轻量级锁和重量级锁，只不过相较于偏向锁，性能较低。</p><p><img src="/../images/JUC%E5%AD%A6%E4%B9%A0--Monitor/view.png" alt="preview"></p><p>关于java中的锁可以参考以下文章：</p><p><a href="https://segmentfault.com/a/1190000023665056">java - 偏向锁的【批量重偏向与批量撤销】机制 - 个人文章 - SegmentFault 思否</a></p><p><a href="https://zhuanlan.zhihu.com/p/265613664">史上最全java中锁的总结！ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/SCDN_CP/article/details/86491792?ops_request_misc=%7B%22request_id%22:%22171047670816800188594181%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171047670816800188594181&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-86491792-null-null.142%5Ev99%5Epc_search_result_base3&utm_term=Markword&spm=1018.2226.3001.4187">Java对象结构与锁实现原理及MarkWord详解_java打印锁持有者-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus学习4--MybatisPlus中提供的插件</title>
      <link href="/2024/03/14/MybatisPlus%E5%AD%A6%E4%B9%A04/"/>
      <url>/2024/03/14/MybatisPlus%E5%AD%A6%E4%B9%A04/</url>
      
        <content type="html"><![CDATA[<p>####分页插件</p><p>问题：如何在MybatisPlus中使用分页插件？</p><p>​–解答：这也是MybatisPlus相较于Mybatis功能更加强大的一个方面，在MybatisPlus中封装了分页功能，使用户可以更加方便的使用分页操作。具体使用方法为：</p><ol><li>创建分页配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.deng.dao.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusPageConfig</span> &#123;</span><br><span class="line">    <span class="comment">//MybatisPlusInterceptor是MybatisPlus中提供的一个拦截器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusPage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">pageConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        pageConfig.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> pageConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用分页功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//Page类是MybatisPlus中用于分页功能的类</span></span><br><span class="line">    Page&lt;User&gt; userPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">1</span>,<span class="number">1L</span>);</span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPage(userPage, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层执行的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> id,name,age,email <span class="keyword">FROM</span> t_user LIMIT ?</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="number">1</span>(Long)</span><br></pre></td></tr></table></figure><p>page类中一些常用的方法，也是在开发分页功能经常用到的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">page.getCurrent();<span class="comment">//返回值为long类型，表示当前所在页面</span></span><br><span class="line">page.getPages();<span class="comment">//返回值为long类型，表示总页数</span></span><br><span class="line">page.getTotal();<span class="comment">//返回值为long类型，表示总记录数 = pages * size</span></span><br><span class="line">page.getSize();<span class="comment">//返回值为long类型，表示页面大小</span></span><br><span class="line">page.getRecords();<span class="comment">//返回值为List&lt;&gt;类型，表示页面中的记录</span></span><br><span class="line">page.hasNext();<span class="comment">//返回值为boolean类型，表示该页是否有下一页</span></span><br><span class="line">page.hasPrevious();<span class="comment">//返回值为boolean类型，表示该页是否有上一页</span></span><br></pre></td></tr></table></figure><p>​在MybatisPlus中还提供了乐观锁插件、代码生成器、多数据源配置以及MybatisX插件(IDEA中的插件)等功能，具体使用可以参考MybatisPlus官网。这些功能可以让我们更便捷、更迅速的操作数据库中的表。</p><p><a href="https://baomidou.com/">MybatisPlus</a></p>]]></content>
      
      
      <categories>
          
          <category> MybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus学习3</title>
      <link href="/2024/03/14/MybatisPlus%E5%AD%A6%E4%B9%A03/"/>
      <url>/2024/03/14/MybatisPlus%E5%AD%A6%E4%B9%A03/</url>
      
        <content type="html"><![CDATA[<p>问题：MybatisPlus中如何进行有条件查询？</p><p>​–解答：在MybatisPlus中进行条件查询有两种方式，第一种就是在XxxMapper中编写自定义SQL语句；另一种就是使用MybatisPlus提供的条件查询抽象类Wrapper，该抽象类是MybatisPlus中的顶级条件查询父类，我们一般使用其子类的子类来进行条件查询。</p><p><img src="/../images/MybatisPlus%E5%AD%A6%E4%B9%A03/image-20240314105215080.png" alt="image-20240314105215080"></p><p>​LambdaWrapper可以使用Lambda表达式指定查询或修改条件，优点是可以确保字段的正确；</p><p>​UpdateWrapper和QueryWrapper分别对应修改和查询时指定条件，相较于使用Lambda语法，可能会出现字段书写错误导致数据库中出现错误信息。</p><h5 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h5><p>QueryWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询name中有‘张’,年龄在10~20之间并且邮箱不为空的记录</span></span><br><span class="line">    queryWrapper.like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张&quot;</span>).between(<span class="string">&quot;age&quot;</span>,<span class="number">10</span>,<span class="number">20</span>).isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    <span class="keyword">for</span>(User u : users)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层执行的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Preparing: <span class="keyword">SELECT</span> id,name,age,email <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> (name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ? <span class="keyword">AND</span> email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="operator">%</span>张<span class="operator">%</span>(String), <span class="number">10</span>(<span class="type">Integer</span>), <span class="number">20</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryWrapper2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//只查询user的name和email字段</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层执行的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> name,email <span class="keyword">FROM</span> t_user</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: </span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Columns: name, email</span><br></pre></td></tr></table></figure><p>至于更多方法这里不再一一演示，请自行探索</p><hr><p>UpdateWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将指定id的记录的name值修改为王五</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;王五&quot;</span>).eq(<span class="string">&quot;id&quot;</span>,<span class="number">1768110773964066818L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.update(updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层执行的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">UPDATE</span> t_user <span class="keyword">SET</span> name<span class="operator">=</span>? <span class="keyword">WHERE</span> (id <span class="operator">=</span> ?)</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: 王五(String), <span class="number">1768110773964066818</span>(Long)</span><br></pre></td></tr></table></figure><p>至于更多方法这里不再一一演示，请自行探索</p><hr><p>LambdaWrapper</p><p>​使用方法和QueryWrapper、UpdateWrapper一样，只不过在指定字段时，使用的是函数式编程，防止字段写错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.like(User::getName, <span class="string">&quot;张&quot;</span>).between(User::getAge, <span class="number">10</span>, <span class="number">20</span>).isNotNull(User::getEmail);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(lambdaQueryWrapper);</span><br><span class="line">    <span class="keyword">for</span>(User u : users) System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> id,name,age,email <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> (name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ? <span class="keyword">AND</span> email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="operator">%</span>张<span class="operator">%</span>(String), <span class="number">10</span>(<span class="type">Integer</span>), <span class="number">20</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目秒杀优化</title>
      <link href="/2024/03/13/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/"/>
      <url>/2024/03/13/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>问题：当前秒杀功能的执行逻辑是怎样的？</p><p>​–解答：</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/image-20240314200959800.png" alt="image-20240314200959800"></p><p>问题：这种逻辑存在什么问题？</p><p>​–解答：所有处理均由一个线程完成，性能较低。</p><p>问题：如何进行优化？</p><p>​–解答：可以使用Redis完成检查库存是否充足和校验一人一单的过程，对于满足条件的线程(请求)，将其放入阻塞队列中，异步的处理这些请求(生成订单，扣减库存，将订单信息存入数据库中)</p><p>问题：为什么要用阻塞队列？</p><p>​–解答：因为我们想要异步的处理生成订单的请求，而不是一旦某个用户满足条件，就立即为他生成订单(这里的生成订单指的是扣减数据库中的库存)。</p><p>问题：BlockingQueue有哪些特性？</p><p>​–解答：本质上是一个队列，这也是一个接口，有多个实现类，这里选择的是ArrayBlockingQueue。阻塞队列最大的特点就是，当取不到数据时，该线程会一直等待，直到队列中有数据。</p><p>问题：那这样不会影响效率吗，因为要一直等待？</p><p>​–解答：由于我们在处理订单，也就是从阻塞队列中取数据时，是交给另一个线程来做的，因此对我们的主线程不会有影响，其实主线程在redis判断完后就基本上可以将秒杀结果返回给用户了。</p><p>问题：Redis中是如何工作的？</p><p>​–解答：这也是我们接下来要说到的。因为要保证Redis中操作的原子性，因此我们会将这些操作以Lua脚本的方式呈现。首先我们会判断对应优惠券的库存是否充足，这里我们可以使用String，Value结构来存储数据；至于校验该用户是否购买过该优惠券，则可以使用String，Set结构来存储数据。使用Set的好处有很多，比如key中对应的value是唯一的，不会存在多个相同的value，这时只要调用set 的ismember命令就能够判断该用户是否购买过此优惠券。</p><p>​因此我们现在的秒杀流程变成了这样：</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/image-20240315114547926.png" alt="image-20240315114547926"></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 秒杀优惠券表，与优惠券是一对一关系 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-03-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucherServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SeckillVoucherMapper, SeckillVoucher&gt; <span class="keyword">implements</span> <span class="title class_">ISeckillVoucherService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdGenerator uniqueIdGenerator;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderMapper voucherOrderMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript redisScript;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">        redisScript.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;/RedisWork.lua&quot;</span>));</span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService currentProxy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="comment">//项目一启动就检查阻塞队列中是否有未处理的订单，有就进行处理</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">take</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">                    <span class="comment">//创建订单</span></span><br><span class="line">                    handleVoucherOrder(take);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据id从数据库中查询对应的优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2.判断该优惠券是否开始以及结束</span></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动已结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        keys.add(RedisConstants.SECKILL_STOCK_KEY + id);</span><br><span class="line">        keys.add(RedisConstants.SECKILL_VOUCHER_KEY + id);</span><br><span class="line">        <span class="comment">//3.调用lua脚本判断库存是否充足以及该用户是否已经购买过该秒杀券</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> (Long)stringRedisTemplate.execute(redisScript, keys, userid + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.生成订单</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">seckillVoucherOrderId</span> <span class="operator">=</span> uniqueIdGenerator.generatorId(RedisConstants.SECKILL_VOUCHER_ID_PREFIX);</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//4.1 填入订单id，使用全局唯一id生成器生成</span></span><br><span class="line">        voucherOrder.setId(seckillVoucherOrderId);</span><br><span class="line">        <span class="comment">//4.2 填入用户id</span></span><br><span class="line">        voucherOrder.setUserId(userid);</span><br><span class="line">        <span class="comment">//4.3 填入优惠券id</span></span><br><span class="line">        voucherOrder.setVoucherId(id);</span><br><span class="line">        <span class="comment">//4.4 将订单放入阻塞队列,等待处理</span></span><br><span class="line">        blockingQueue.add(voucherOrder);</span><br><span class="line">        currentProxy = (ISeckillVoucherService) AopContext.currentProxy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherOrder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        currentProxy.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherOrder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//5.更新库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        voucherOrderMapper.insert(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus学习2</title>
      <link href="/2024/03/13/MybatisPlus%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/13/MybatisPlus%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>问题：什么是MybatisPlus？为什么需要使用MybatisPlus？MybatisPlus如何使用？</p><p>​–解答：MybatisPlus是基于Mybatis而开发的一个持久层框架，在Mybatis中能够完成的操作在MybatisPlus中都能够完成，MybatisPlus的口号是“只做增强，不做修改”。</p><p>​–解答：相较于Mybatis，使用MybatisPlus更加方便，比如在MybatisPlus中提供了一个BaseMapper接口，在这个接口中提供了基本的CRUD操作，我们不需要在mapper.xml文件中编写SQL语句。</p><p>​–解答：使用方法非常简单，详细教程可以参考mybatisplus官网</p><p><a href="https://baomidou.com/">MybatisPlus</a></p><p>问题：在MybatisPlus中如何自定义SQL语句？</p><p>​解答：刚才提到BaseMapper接口中提供大量基础的CRUD操作，如果想要编写自定义SQL语句，就需要像在Mybatis中一样，需要在Xxxmapper.xml文件中进行。具体步骤为：</p><ol><li>需要在yaml文件中给mybatis-plus的mapper-locations属性进行配置，该属性有一个默认值，如图所示。表示默认情况下我们需要在类路径的mapper目录中创建XxxMapper.xml文件</li></ol><p><img src="/../images/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20240313183912320.png" alt="image-20240313183912320"></p><ol start="2"><li>在Mapper接口中定义相关方法，并在XxxMapper.xml文件中编写SQL语句</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.deng.dao.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>之后，我们就能使用自定义的sql查询语句了</li></ol><p><img src="/../images/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20240313184120278.png" alt="image-20240313184120278"></p><p>问题：为什么不让我们的Service类直接继承ServiceImpl类？</p><p>​–解答：在MybatisPlus中除了提供BaseMapper接口供持久层使用外，还提供了IService接口给Service层使用。该接口中也提供了大量基础的CRUD操作，并且提供了该接口的实现类ServiceImpl。理论上是可以让我们的Service类直接继承ServiceImpl类，但是这样做不利于面向接口编程。我们的接口中并没有这些方法，因此接口引用就无法使用这些方法。所以通常我们会让接口类继承IService接口，Service类继承ServiceImpl接口(避免重写IService中所有方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;<span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MybatisPlus有哪些常用注解？</p><p>​–解答：在MybatisPlus中提供了很多注解，其中比较常用的有</p><p>@TableName：作用于实体类上。用于标识该实体类对应的数据库表</p><p>@TableId：用于于属性上。用于标识该属性是主键。该注解有两个属性：value：用于保证数据库表字段名和类属性名一致；type：指定主键生成方式，默认按照雪花算法生成</p><p>@TableField：作用于属性上。用于保证数据库字段名和类属性名一致</p><p>@TableLogic：作用于属性上。用于逻辑删除，当执行delete语句时，实际上执行的是update语句，会修改被该注解作用的属性的值为1(0表示未删除，1表示逻辑删除)。当执行select语句时，只会显示标志位为0的表项。</p>]]></content>
      
      
      <categories>
          
          <category> MybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081操作系统学习-4</title>
      <link href="/2024/03/13/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A04/"/>
      <url>/2024/03/13/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A04/</url>
      
        <content type="html"><![CDATA[<h4 id="中断-Interrupt"><a href="#中断-Interrupt" class="headerlink" title="中断(Interrupt)"></a>中断(Interrupt)</h4><p><strong>问题：什么是中断？为什么需要中断？中断是如何产生的？操作系统中是如何处理中断的？</strong></p><p>​–解答：和page fault一样，中断也会引起trap机制。当发生中断时，系统需要停止当前运行的工作，优先处理中断事件。在操作系统中主要有3类中断：由软件引起的中断、时钟中断(用于时间片调度算法)以及外部设备引起的中断(比如网卡受到一个packet后，在某个时间点会产生中断将处理完的packet交给操作系统)。在本节主要介绍最后一种中断。</p><p>​在计算机中为了提高运行效率，几乎所有外部设备和CPU都是并行运行的，这样做的好处是可以充分利用CPU资源。因此当外部设备准备好了后(一些资源的初始化操作)，必须依靠某种机制使它们能够和CPU进行交互。这种机制就是中断，它们会产生一个中断，告诉操作系统我需要CPU。</p><p>​当产生中断时，我们需要在内核处理这些中断，因此会触发trap机制完成到内核的切换以及保存好那些重要的用户数据，这个过程在之前讲过，这里不再赘述。在操作系统中设置了PLIC(Platform Level Interrupt Control)用于将这些中断分发给CPU。更具体的流程是在PLIC中会存储大量中断信息，并且会通知CPU有这些中断需要处理，当某个CPU接收中断时，PLIC会将中断传送给CPU，CPU处理完后会通知PLIC，PLIC会清除掉已处理的中断信息。</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A04/image-20240319135551515.png" alt="image-20240319135551515"></p><p><strong>问题：和System Call以及page fault相比，外设中断有什么区别？</strong></p><p>​–解答：当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的context下。</p><p>​我们还需要对这些外部设备进行编程，以告诉它们在读写某个控制寄存器时，需要做出何种反应。</p><p>​最后，外部设备和CPU是并行运行的，在之前也讲到过，这是提升CPU使用的一种方法。</p><p><strong>问题：什么是设备驱动？</strong></p><p>​–解答：所谓设备驱动就是管理设备的代码，一般由top和bottom两部分组成，bottom中编写的是Interrupt Handler的逻辑，当CPU处理某个设备的中断时，它会执行这部分代码。top部分提供了一些接口用于与其他进程进行交互(由于Interrupt Handler不依赖任何一个进程的context，因此其他进程无法知道Interrupt Handler的地址)。在top和bottom之间通过一个队列buffer进行通信，Interrupt Handler向buffer中写入数据，top从buffer中读取数据。</p><p><strong>问题：如何对外部设备进行编程？</strong></p><p>​–解答：这些外部设备地址通常位于内存中某个特定区间，这由硬件开发人员决定，操作系统需要知道这些设备的地址，然后直接使用load&#x2F;store指令修改其中的内容。以下是SiFive主板上的一些设备地址</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A04/image-20240324093129416.png" alt="image-20240324093129416"></p><p>可以发现0x0C00_0000~0x0FFF_FFFF这部分地址分配给了PLIC设备</p><p><strong>问题：和处理中断相关的寄存器有哪些？分别有什么作用？</strong></p><p>​–解答：</p><ul><li>SIE（Supervisor Interrupt Enable）寄存器。这个寄存器中有一个bit（E）专门针对例如UART的外部设备的中断；有一个bit（S）专门针对软件中断，软件中断可能由一个CPU核触发给另一个CPU核；还有一个bit（T）专门针对定时器中断。我们这节课只关注外部设备的中断。</li><li>SSTATUS（Supervisor Status）寄存器。这个寄存器中有一个bit来打开或者关闭中断。每一个CPU核都有独立的SIE和SSTATUS寄存器，除了通过SIE寄存器来单独控制特定的中断，还可以通过SSTATUS寄存器中的一个bit来控制所有的中断。</li><li>SIP（Supervisor Interrupt Pending）寄存器。当发生中断时，处理器可以通过查看这个寄存器知道当前是什么类型的中断。</li><li>SCAUSE寄存器，这个寄存器我们之前看过很多次。它会表明当前状态的原因是中断。</li><li>STVEC寄存器，它会保存当trap，page fault或者中断发生时，CPU运行的用户程序的程序计数器，这样才能在稍后恢复程序的运行。</li></ul><p><strong>问题：xv6系统中是如何实现中断的？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.s081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus学习--1.入门程序</title>
      <link href="/2024/03/12/MyBatisPlus%E5%AD%A6%E4%B9%A0--1.%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/03/12/MyBatisPlus%E5%AD%A6%E4%B9%A0--1.%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="MybatisPlus概述及入门程序"><a href="#MybatisPlus概述及入门程序" class="headerlink" title="MybatisPlus概述及入门程序"></a>MybatisPlus概述及入门程序</h4><p>​MybatisPlus是由国人开发的基于Mybatis但功能更加强大的持久层框架。内部提供了大量接口，相较于Mybatis更加灵活、更加强大。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>引入依赖，SpringBoot3.0及以上需要使用以下MybatisPlus依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在application.yml中进行相关配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#数据源配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisplus?characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dch</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建Mapper接口以及实体类。并且需要告诉Spring mapper接口所在的包</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.dao.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.deng.dao.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Demo03Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​其中BaseMapper<T>是由MybatisPlus提供的接口，在这个接口中定义了非常多的操作，比如常见的CRUD都有，省去了编写SQL语句的麻烦。</p><p>​@TableName()注解用于告诉MybatisPlus需要操作数据库中表的名字，默认情况下会去寻找和BaseMapper接口中指定类型的同名表，在本例中默认会去找user表</p><ol start="4"><li>执行CRUD</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/MyBatisPlus%E5%AD%A6%E4%B9%A0--1.%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/image-20240312210022300.png" alt="image-20240312210022300"></p><p>​在MybatisPlus中默认会使用雪花算法生成id</p>]]></content>
      
      
      <categories>
          
          <category> MybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--synchronized使用</title>
      <link href="/2024/03/12/JUC--synchronized%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/12/JUC--synchronized%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>####synchronized</p><p>​synchronized关键字是java中实现互斥锁的一种方式，只能以某个对象作为锁，只有获得锁的线程才能进入代码区。</p><p>​使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    需要加锁的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized关键字加在成员方法上时，默认以本对象作为锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized关键字加在静态方法上时，默认以本类作为锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目使用Redisson框架</title>
      <link href="/2024/03/11/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redisson%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/03/11/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redisson%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>​在经过我们不断的改进后，可以说此时项目中的分布式锁是一个相对完善的锁，但依然存在着改进的空间。比如：</p><p>​当前项目中的锁是不可重入的锁：同一个线程无法多次获取同一把锁，有时候我们会有这样的需求：A方法中需要获取锁并会调用同一个类中的方法B，同时在B方法中也需要获取锁，如果当前系统的锁不是可重入锁，那么就会造成死锁问题。</p><p>​当前项目中的锁是不可重试的锁：当某个线程获取锁失败后，直接返回错误，该线程无法重试。</p><p>​当前项目中的锁在Redis集群模式下可能存在问题：在Redis集群模式下，主从节点间存在一定的同步延迟，如果主节点宕机而从节点又未能及时同步存储在主节点中的锁信息，可能会导致线程安全问题。</p><p>​以上几种问题可以自己实现解决方案，但是我们可以使用他人开发好的分布式框架——Redisson来解决以上问题，避免重复造轮子。Redisson是一个基于Redis的分布式框架。在解决以上问题的同时，Redisson实现的分布式锁利用watchdog机制实现了不断更新锁的有效期，避免因为线程阻塞而锁释放导致线程安全问题的出现</p><p>​使用步骤：</p><ol><li>引入Redisson依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        Redisson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redisson(有多种方式，这里使用的是配置类)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置Redisson</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">getRedisson</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis:192.168.21.128:6379&quot;</span>).setPassword(<span class="string">&quot;dch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//可以设置锁的重试时间(默认为-1表示不允许重试)、超时时间(默认30秒)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;每个用户只能购买一次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象，避免自身调用导致事务失效</span></span><br><span class="line">            <span class="type">ISeckillVoucherService</span> <span class="variable">currentProxy</span> <span class="operator">=</span> (ISeckillVoucherService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> currentProxy.createVoucherOrder(id);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目分布式锁释放存在的问题</title>
      <link href="/2024/03/11/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%87%8A%E6%94%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/11/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%87%8A%E6%94%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>​<img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%87%8A%E6%94%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/image-20240311194503493.png" alt="image-20240311194503493"></p><p>​以上这张图描述了这样一种场景：线程1在获取分布式锁后进入业务阻塞状态，并且阻塞时间甚至超过了我们设置的锁过期时间。在此期间，线程2成功获取了锁并开始执行业务，此时被阻塞的线程1又恢复运行并完成了业务，于是按照代码逻辑线程1会去释放锁，此时另一个线程3又来获取锁，造成了线程安全问题。</p><p>​出现该问题的本质原因在于在编写锁的释放代码时，并没有添加判断条件，这样做的漏洞就是释放的锁不一定是自己的锁。解决的方案也很简单，只需要在释放锁之前判断是否是自己的锁。可以使用UUID+线程id作为判断的标识，需要注意的是这种标识依旧无法做到完全唯一。如果想要实现标识完全唯一，可以使用每台电脑的MAC+线程id作为标识。本项目使用的是第一种方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 释放锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> LOCK_PREFIX + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(name);</span><br><span class="line">       <span class="keyword">if</span>(flag.equals(threadId)) &#123;</span><br><span class="line">           stringRedisTemplate.delete(name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​在某些极端情况下，当前代码还会出现问题。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%87%8A%E6%94%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/image-20240311203651449.png" alt="image-20240311203651449"></p><p>​上图表示的情景是线程1判断锁标识后想要执行下一步时，突然发生的阻塞，导致锁无法正常释放，因此又发生了线程安全问题。出现该问题的原因在于，编写释放锁的代码时，判断和释放是两个动作，不能保证操作的原子性。</p><p>​实现Redis操作原子性的一种方案为使用Lua语言，这是一种脚本语言，并且可以使用该语言对Redis进行操作。以下网站是一个关于Lua语言的学习网站。</p><p><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua学习网站</a></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--利用lua脚本实现redis语句的原子性</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//redis中提供的操作脚本语言的类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript redisScript;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">       redisScript.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">       redisScript.setResultType(Long.class);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 利用lua脚本释放锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span>&#123;</span><br><span class="line">       stringRedisTemplate.execute(redisScript, Collections.singletonList(KEY_PREFIX + name), lockId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​通过本节需要掌握：</p><ol><li>在释放锁时需要考虑这个锁是否是自己的锁</li><li>学会使用lua语言保证执行redis语句的的原子性</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--java中线程的状态</title>
      <link href="/2024/03/11/JUC--java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
      <url>/2024/03/11/JUC--java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：在java中的线程有哪些状态？和操作系统中线程的状态有何不同？线程有哪些常见的状态转换？</strong></p><p>​–解答：在java中线程有6种状态，分别是NEW、RUNNABLE、WAITING、TIMED_WAITING、BLOCKED和TERMINATED。</p><p>​在操作系统中一个正在运行的线程由于需要等待某个条件满足才能继续运行时，就会进入等待状态。java语言基于操作系统提供的状态做了一些细化和改变(在操作系统层面，java中不同状态的线程其实是相同状态)。比如：由IO引起的等待在java中不算等待而是RUNNABLE状态(在操作系统层面，该线程还是处于等待状态)；由wait()，join()，park()引起的线程等待属于WAITING状态；由sleep(long time)，wait(long time)等方法引起的线程等待属于TIMED_WAITING状态；争抢锁资源失败的线程属于BLOCKED状态。而这些状态在操作系统中都属于等待状态。</p><p><img src="/../images/JUC--java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/image-20240311170244451.png" alt="image-20240311170244451"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--守护线程</title>
      <link href="/2024/03/11/JUC--%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/03/11/JUC--%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​在java中默认情况下只要有一个线程处于运行状态，那么整个java程序就不会停止运行。需要注意的是main线程只是java程序中的其中一个线程，main线程的结束不代表整个java程序的结束。</p><p>​在java中有一种特殊的线程——守护线程，该线程的特点是当程序中不存在其他非守护线程运行时，该守护线程会自动结束运行。比如垃圾回收器线程就是一种守护线程。可以使用setDaemon(true)方法将一个普通线程转换为守护线程</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081操作系统学习-3</title>
      <link href="/2024/03/11/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A03/"/>
      <url>/2024/03/11/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A03/</url>
      
        <content type="html"><![CDATA[<h4 id="Page-faults"><a href="#Page-faults" class="headerlink" title="Page faults"></a>Page faults</h4><p>​page faults译为页面错误，是指发生在计算机操作系统中的一种情况，当程序需要访问某个页面但该页面不在内存中时，就会发生页面错误。</p><p>​关于page faults，我们需要知道的是当用户程序触发了page fault之后，会触发trap机制，系统会跳转到内核状态。并且会将引起出错的虚拟地址存放在STVAL寄存器中，将出错原因存放在SCAUSE寄存器中。(为了便于保存，会将出错原因和数字关联起来，比如15表示的是由store指令引起的page fault)</p><p>​针对page fault最直接的解决方案为给用户程序增加指定数量的空闲的物理内存(eager allocation)，但这种方式的缺点是在大多数情况下，用户程序并不知道自己会用到多少内存，因此在分配的内存中可能有大部分内存实际上根本没有使用。</p><p>#####lazy allocation</p><p>​另一种更加聪明的方法是在逻辑上增加内存，只有当用户实际使用这些内存时才真正分配内存(lazy allocation)</p><p>#####zero fill on demand</p><p>​还有一个使用非常频繁的功能：zero fill on demand，如果你查看用户程序的地址空间，你会发现存在3个区域：test，data和BSS。其中test区域用来存放程序的指令，data区域用来存放初始化了的全局变量，BSS区域则用来存放未初始化或者初始化为0的全局变量。在计算机中会存在许多未初始化或初始化为0的page，如果每个page都映射一块物理地址，会消耗相当多的内存，并且这些内存不一定会全部使用。一种优化策略是，面对如此多的存储0的page，在物理内存中只分配一个全为0的page(该page是只读的)，让这些全为0的page都映射到这个物理page上，当某个page需要修改时，才在物理内存中重新分配一个page，并初始化为0，再重新执行指令。这样做的好处是在程序启动的时候会节省大量的物理内存，缺点是当需要修改page中的内容时，会发生page fault，需要重新分配page，这个过程时间较长(进入内核就是一个非常漫长的过程)。</p><p>#####copy on write fork</p><p>​在操作系统中还有一个优化技巧：Copy On Write Fork。我们知道，当调用fork系统调用创建子进程时，这个子进程会拷贝父进程的地址空间。在shell中这种拷贝非常频繁，并且子进程往往使用exec调用另一些程序，这将会丢弃从父进程拷贝而来的地址空间。这显然是一种浪费，为了避免这种浪费，我们的做法是创建子进程时，子进程将会使用父进程的地址空间(物理地址)，并且这个地址空间将会被设置为只读。</p><p>​当子进程需要修改内存内容时，将会触发page fault，因为在向一个只读地址写入数据。接着会创建一个新的物理内存page，将触发page fault的物理地址拷贝至新的page中并映射到对应的用户程序，再将父进程的PTE设置为可读写的，最后重新执行指令</p><p>​疑问：当父进程想要修改内存内容时，系统如何操作？</p><p>​猜测：一种方案是在触发page fault后，会创建一个新的物理page，将子进程有关的内容拷贝至该page，此时父进程中有关的PTE设置为可读写的，再重新执行指令</p><p>​另一种方案是在触发page fault后，会创建一个新的物理page，将父进程有关的内容拷贝至该page，并映射父进程，再重新执行指令。</p><p>​个人认为是第一种方案，第二种方案有点鸠占鹊巢的感觉，设计的不够优雅。最主要的原因还是如果采用第二种方案，还需要执行更换页表操作，如果采用第一种方案，当子进程移入新的page后，父进程中的指令可以直接执行。</p><h5 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h5><p>​正如之前提到的，每个用户程序都由3部分组成：text、data和BSS，对于BSS采取的优化策略是zero fill on demand。对于text和data部分我们真的有必要使用eager allocation的方式将它们全部加载到内存中吗？毕竟，用户程序可能只会使用这些数据的一部分，而且如果这些数据非常庞大将它们加载到内存中将会是一件非常耗时的工作。为什么不再等等。</p><p>​因此当我们给这些程序分配内存时，并不会给它们实际分配内存，会将它们的PTE的valid标志位设置为0，表示该条记录无效。这种情况下，当程序执行第一条指令(虚拟地址为0的指令)时，就会触发page fault，我们需要将和这些page对应的程序文件保存在某个地方(一般是外存),这样当发生page fault时page fault handler就能从程序文件中读取数据加载到内存中，并将内存page映射到page table，再重新执行指令。</p><p>​以上流程存在的一个问题为：当需要加载的数据的容量大于物理内存时，即发生OOM(out of memory)时，操作系统该如何应对。</p><p>​一种做法是将一些page撤回到外存中，空闲出来的物理内存用来存放当前需要加载的数据。这里常用的撤回策略是LRU算法，又被称为最近最少使用算法，该算法优先撤回那些最近一段时间内使用频率最低的page(可以根据access标志位来判断，该标志位会被定期清空)。这里的一种优化方案是优先撤回那些未被修改的page(dirty标志位为0)，因为这些page在撤回时不需要写回外存</p><p><strong>以上这些优化都是操作系统在内存上的优化，其核心思想是laze allocation策略，只在程序真正需要内存时才给它分配内存</strong></p><h5 id="Memory-Mapped-Files"><a href="#Memory-Mapped-Files" class="headerlink" title="Memory Mapped Files"></a>Memory Mapped Files</h5><p>​在操作系统中提供了mmap系统调用将位于外存中的文件加载到内存中，该系统调用能够接收多个参数：VA(虚拟内存地址)、len(文件大小以字节为单位)、protection(标志该块内存是共享还是私有)、一些标志位、一个打开文件的文件描述符和offset(偏移量)。具体操作就是在内存中分配一块大小为len的内存，将对应文件中从偏移量处len大小的数据加载到内存中，并结合虚拟地址和标志位生成对应的PTE。当执行完操作后，会有一个对应的unmap系统调用，表明应用程序完成了对文件的操作，该系统调用会将被修改过的block写回到外存中。</p><p>​以上行为是eager式加载，一种更加聪明的做法是使用lazy allocation来加载文件。即操作系统不会立刻将指定内容拷贝至内存，而是在一个地方记录该PTE对应的信息：比如文件描述符、偏移量等(此时PTE的valid标志位为0)，当发生page fault时才会从指定文件中将指定数据加载到内存。执行完后，同样会调用unmap。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.s081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目集群模式下的线程安全问题</title>
      <link href="/2024/03/10/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/10/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>​我们之前在实现一人一单的功能时，为了防止线程安全问题，解决方案为使用synchronized关键字将用户id作为锁对象，保证同一个用户只能有效发送一次请求。</p><p>​但是这种加锁方式只能在单体项目中有效，对于集群项目，也就是有多台服务器的项目，这种加锁方式会失效。主要原因在于，synchronized的原理其实是依靠JVM中的锁监视器，该监视器会查看是否已经有某个线程占用了锁，如果锁已经被占用，那么其他线程也就无法获取锁。</p><p>​但在集群模式下，不同的机器拥有不同的JVM，JVM中存储的信息自然也不相同。因此依靠synchronized实现的锁机制自然也会失效。</p><p>​解决方案为使用分布式锁，实现分布式锁的核心就是让锁监视器的监视范围由一台机器扩展为多台机器。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image-20240310202848044.png" alt="image-20240310202848044"></p><p>​因此锁监视器必然不能是机器中的部件。目前，主要有3种实现分布式锁的方案：MySql、Redis和Zookeeper</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image-20240310202919962.png" alt="image-20240310202919962"></p><p>​本项目使用Redis实现分布式锁，使用Redis实现锁的机制其实在解决缓存击穿问题时已经使用过，其核心就是利用Redis中的setnx语句，该语句会判断在Redis中是否已经存在目标key，如果存在则操作失败，也就意味着获取锁失败。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image-20240310203311058.png" alt="image-20240310203311058"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockImpl</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LockImpl</span><span class="params">(String name,StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = KEY_PREFIX + name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 能否获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long timeout)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(name, thread, timeout, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过本节需要掌握</p><ol><li>使用Redis实现分布式锁</li><li>知道实现分布式锁的几种方案</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--使用Interrupt实现两阶段终止线程</title>
      <link href="/2024/03/10/JUC--%E4%BD%BF%E7%94%A8Interrupt%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/03/10/JUC--%E4%BD%BF%E7%94%A8Interrupt%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​如果我们想要在一个线程中优雅的终止另一个线程，可以使用interrupt方法实现，所谓优雅的终止指的是不是突然终止某个线程，而是告诉被终止的线程你即将被终止，让该线程可以在终止之前做一些工作</p><p>​假设我们需要实现一个监控类，这个类需要不断取获取系统当前的信息，并且系统可以决定终止该类的执行。</p><p>​我们的想法肯定是让一个线程不断的轮询，获取系统信息，那么如何终止该线程呢？如果直接调用stop方法，可能会造成死锁，因为有些资源会永远无法释放。</p><p>​正确的做法是，当想要终止另一个线程时，可以调用对应的线程的interrupt方法，该方法可以将线程的中断标识位置为true，接下来只需要通过isInterrupt来获取中断标识位(还有一个静态方法interruptted也能够获取中断标识位，与isInterrupt不同的是后者在返回标识位后会清除标识位，即如果标识位为true的话会置为false)，如果为true直接跳出循环。需要注意的是如果当前需要中断的线程处于sleep、wait、join等状态时，调用它的interrupt会使该线程出现异常并清空中断标识位(置为false)，因此我们需要再调用一次interrupt方法</p><p>​需要注意的是interrupt方法只会将线程的中断标识位置为true，并不会真的中断线程，具体的中断逻辑需要由程序员自己实现。</p><p>​总结</p><ul><li>1 中断标志位，默认false</li><li>2 t2 —-&gt; t1发出了中断协商，t2调用t1.interrupt()，中断标志位true</li><li>3 中断标志位true，正常情况，程序停止，^_^</li><li>4 中断标志位true，异常情况， 就是t1过程中调用了sleep 、join 、 wait 方法 会抛出一个 InterruptedException(中断异常)，</li><li>将会把中断状态将被清除，并且将收到InterruptedException 。中断标志位重新设置为false 导致无限循环</li><li></li><li>5 所以如果要线程中调用sleep 、join 、 wait 方法 需要在catch块中，需要再次给中断标志位设置为true，2次调用停止程序才OK</li></ul><p>原文链接：<a href="https://blog.csdn.net/m0_71149992/article/details/125504970">https://blog.csdn.net/m0_71149992/article/details/125504970</a></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Supervisor</span> <span class="variable">supervisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Supervisor</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        supervisor.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        supervisor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supervisor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread moniter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始监控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        moniter = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(interrupted)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;将监控信息保存至日志文件中&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;moniter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        moniter.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止监控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        moniter.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/JUC--%E4%BD%BF%E7%94%A8Interrupt%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/image-20240310180339004.png" alt="image-20240310180339004"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--线程中常用的方法</title>
      <link href="/2024/03/10/JUC--%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2024/03/10/JUC--%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>setName()</td><td>设置线程的名字</td></tr><tr><td>getName()</td><td>返回线程的名字</td></tr><tr><td>sleep(int x)</td><td>使线程休眠，线程进入阻塞状态</td></tr><tr><td>start()</td><td>启动线程</td></tr><tr><td>run()</td><td>该方法中可以编写线程需要完成的工作</td></tr><tr><td>setPriority(int priority)</td><td>设置线程的优先级，数字越大，优先级越高</td></tr><tr><td>getPriority()</td><td>获取线程优先级</td></tr><tr><td>interrupt()</td><td>打断线程，当打断的线程的状态为阻塞时，相当于唤醒该线程(由阻塞变为就绪)，其打断标记位为false；如果打断的是一个正常运行的线程，该线程的打断标记位为true，<strong>并且该线程并不会停止运行</strong></td></tr><tr><td>yield()</td><td>线程的让步，让cpu先执行其他线程，让步后的线程进入就绪状态，不一定成功（因为调度器可能还是执行该线程）</td></tr><tr><td>join()</td><td>线程插队，插队一旦成功，一定会先执行完插队的线程。一般用于线程间的同步</td></tr><tr><td>isInterrupt()</td><td>获取线程的打断标记位</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInterrupt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     Thread.currentThread().setName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     t1.start();</span><br><span class="line">     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">     t1.interrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/JUC--%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/image-20240310171825357.png" alt="image-20240310171825357"></p><p>​可以发现，t1即使被打断了，依然会继续执行,似乎interrupt对该线程没有影响。因此需要根据打断标记位来退出循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInterrupt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.currentThread().setName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br></pre></td></tr></table></figure><p><img src="/../images/JUC--%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/image-20240310172224776.png" alt="image-20240310172224776"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2024/03/10/%E7%AE%97%E6%B3%95--%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2024/03/10/%E7%AE%97%E6%B3%95--%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="滑动窗口题集"><a href="#滑动窗口题集" class="headerlink" title="滑动窗口题集"></a>滑动窗口题集</h4><p><a href="https://leetcode.cn/problems/minimum-window-substring">LeetCode76</a></p><p>​维护一个滑动窗口，需要判断窗口中是否含有目标串所有字符。如何快速判断该窗口中是否含有目标串所有字符呢？可以使用一个哈希表记录目标串中的各个字符数，<strong>并使用一个变量记录目标串中的字符种类</strong>。当该变量为0时说明当前窗口包含目标串中所有字符。</p><p>​使用指针i，j分别表示窗口的右指针和左指针，右指针每向右移动一次，都要判断左指针能否向右移动，从而使子串最短。判断方法为：用一个哈希表记录此时窗口中含有的各个字符数，当前左指针表示的字符数是否大于目标串需要的字符数，如果大于说明左指针可以移动。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span> str[] = s.toCharArray();</span><br><span class="line">        <span class="type">char</span> tstr[] = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length;</span><br><span class="line">        <span class="type">int</span> need[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="type">int</span> window[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cntNeed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tstr.length; i ++)&#123;</span><br><span class="line">            need[getIdx(tstr[i])] ++;</span><br><span class="line">            <span class="keyword">if</span>(need[getIdx(tstr[i])] == <span class="number">1</span>)cntNeed++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> getIdx(c);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(++window[idx1] == need[idx1])&#123;</span><br><span class="line">                cntNeed --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//z</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx2</span> <span class="operator">=</span> getIdx(str[j]);</span><br><span class="line">                <span class="keyword">if</span>(window[idx2] &gt; need[idx2])&#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                    window[idx2] --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cntNeed == <span class="number">0</span> &amp;&amp; (res.length() == <span class="number">0</span> || res.length() &gt; i - j + <span class="number">1</span>))res = s.substring(j,i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIdx</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)<span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--用户注册</title>
      <link href="/2024/03/10/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C/"/>
      <url>/2024/03/10/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：布隆过滤器是如何解决缓存穿透问题的？它有什么优缺点？</strong></p><p>​–解答：布隆过滤器本身是由一个很长的二进制位数组和一些无偏哈希函数组成。这些哈希函数会分别对要插入的数据进行散列，会将数组对应下标处的值置为1，相当于把这个数据存入到布隆过滤器。通过布隆过滤器能够判定数据库中指定数据是否不存在，只要布隆过滤器中没有该数据，那么数据库中就一定没有该数据，从而避免访问数据库。</p><p>​–它的优点就是：时间复杂度低：O(n),n为哈希函数数量；安全，存储的不是数据本身；节省内存，存储空间小</p><p>​–它的缺点是：存在误判：通过布隆过滤器无法判断某个数据是否一定存在于数据库中；不易取出数据，因为存储的不是数据本身(即不能反序列化)；很难删除元素</p><p><strong>问题：这样听起来，布隆过滤器和Redis很像，它们都是缓存，都是修改数据库时需要将数据存入，为什么布隆过滤器就能解决缓存穿透而Redis就不行呢，况且前者还存在误判？</strong></p><p>​–解答：实际上redis以及一些哈希数据结构比如set都具有判断某个key是否在存在的功能，这里redis有缓存穿透是因为此处Redis的是当作缓存使用的，而缓存的使用逻辑就是“如果缓存中没有数据，就去数据库中查看”，因此会有缓存穿透问题。你可以使用两级redis，一级当作缓存，一级用来判断数据库中是否有key。这里使用布隆过滤器的一个原因是布隆过滤器所占用的内存非常小。</p><p><strong>问题：如何避免海量用户注册请求？</strong></p><p>​–解答：一种简单的方法就是添加分布式锁，这样当同一个请求，这里指的是用户名相同的请求，同一时间只有一个能成功，而当该请求成功后，其他请求再请求时就会失败，因为数据库中已经有该用户名了？</p><p><strong>问题：那如果是不同用户名的请求呢？</strong></p><p>​–解答：理论上来说，这是一个小概率事件，因为这种情况需要满足两个条件：极短时间，大量请求。当然如果真的发生了，那显然我们的系统会受到严重的影响。</p><p><strong>问题：也就是说没有什么解决方案吗？</strong></p><p>​–解答：遇到以上情况，或许我们会使用限流的方式来加以优化，也就是限制短时间内的请求数。我们可以规定某个时间段内的最大请求数。这是以后要学的知识，就目前来说，我们的系统已经足以应付大量请求了。</p><p><strong>问题：什么是分库分表？</strong></p><p>​–解答：分库分表是一种面对高并发、大数据量时的一种优化方案。分库分表实际上对应3种操作：分库、分表和既分库又分表，分别对应不同的使用场景。</p><p><strong>问题：为什么要进行分库分表？</strong></p><p>​–解答：对于一些并发量非常大以及数据量非常大的系统，比如我们的短链接系统。如果只有一个数据库，以及单张表的话，很难满足高性能、高可用和高扩展的要求。</p><p><strong>问题：如何进行分库分表？以什么作为分片件？为什么？</strong></p><p>ShardingSphere使用</p>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目秒杀券</title>
      <link href="/2024/03/09/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E5%88%B8/"/>
      <url>/2024/03/09/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E5%88%B8/</url>
      
        <content type="html"><![CDATA[<h4 id="秒杀券功能"><a href="#秒杀券功能" class="headerlink" title="秒杀券功能"></a>秒杀券功能</h4><p><strong>乐观锁解决超卖问题</strong></p><p>​秒杀系统的难点在于解决高并发、多请求，在以上情况下非常容易出现超卖现象，即卖出去商品的数量大于商品的库存数量。出现这种问题的原因在于，我们判断一个用户能否购买该券的前提是从数据库中查到的券的库存数量是否大于0，某一时刻同时来了大量请求假设为100，此时它们查到的数据都大于0假设为5，于是每个线程都会去更新数据库，导致数据库中库存的值为-95，这就造成了超卖。</p><p>​<img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E5%88%B8/image-20240309192938068.png" alt="image-20240309192938068"></p><p>​解决该问题的常见方法就是加锁，这里介绍两种比较常用的锁。</p><ol><li>悲观锁：这种锁的特点就是对于每个请求都需要拿到锁之后才能继续执行，并且同一时刻只能有一个请求拿到锁。其优点就是成功率高，缺点是由于每个线程都需要进行排队，效率低下。</li><li>乐观锁：这种锁的特点它认为线程安全问题不一定会发生，只在数据库更新数据时判断此时是否有人修改过数据，如果数据被修改过，则不更新数据。这种锁的优点是支持线程并发，性能高，缺点是请求成功率低——只要数据不对就需要不断重试。</li></ol><p>​针对乐观锁的设计，一般有两种方案。</p><ol><li>版本号法：在数据库表字段中再增加一个版本字段，查询时同时查数据和版本号，更新时判断此时版本号和之前的版本是否一致</li><li>直接使用要查询的数据作为版本字段，更新时判断此时的数据和之前查询的数据是否一致</li></ol><p>​本项目采用的是乐观锁并且使用的是第二种设计方案，为了提高请求的成功率，在更新数据时我们只需要判断库存是否大于0即可(只要此时库存大于0，即使和之前查询到的结果不一致依然不会出现超卖现象)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.SeckillVoucher;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.mapper.SeckillVoucherMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UniqueIdGenerator;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.IdGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 秒杀优惠券表，与优惠券是一对一关系 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-03-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucherServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SeckillVoucherMapper, SeckillVoucher&gt; <span class="keyword">implements</span> <span class="title class_">ISeckillVoucherService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdGenerator uniqueIdGenerator;</span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据id从数据库中查询对应的优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2.判断该优惠券是否开始以及结束</span></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动已结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.查询库存是否充足</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span>(stock &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.更新库存并使用乐观锁防止超卖问题</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, id).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.生成订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//5.1 填入订单id，使用全局唯一id生成器生成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">voucherOrderId</span> <span class="operator">=</span> uniqueIdGenerator.generatorId(<span class="string">&quot;voucherOrder&quot;</span>);</span><br><span class="line">        voucherOrder.setId(voucherOrderId);</span><br><span class="line">        <span class="comment">//5.2 填入用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//5.3 填入优惠券id</span></span><br><span class="line">        voucherOrder.setVoucherId(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​其实还有另一种方案，既可以提高使用悲观锁的性能又能提高乐观锁的成功率——分库分表，不同的请求可以访问不同数据库。</p><h5 id="一人一单功能"><a href="#一人一单功能" class="headerlink" title="一人一单功能"></a>一人一单功能</h5><p>​由于是秒杀券，商家肯定不希望某个人获得全部的券，而是保证一个用户只能获得一张券。</p><p>​一种简单的实现方案为查询数据库中是否已存在该用户购买这张券的记录，如果存在则报错。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E5%88%B8/image-20240309195812264.png" alt="image-20240309195812264"></p><p>​但是这种做法也存在和超卖现象一样的问题。因此，也必须使用锁机制来预防该问题，和超卖问题不同的是该问题不能使用乐观锁，只能使用悲观锁即snychronized等工具。那么这就有两个问题：以什么作为锁？把锁加在何处？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.SeckillVoucher;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.mapper.SeckillVoucherMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UniqueIdGenerator;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.AopContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.IdGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 秒杀优惠券表，与优惠券是一对一关系 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-03-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucherServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SeckillVoucherMapper, SeckillVoucher&gt; <span class="keyword">implements</span> <span class="title class_">ISeckillVoucherService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdGenerator uniqueIdGenerator;</span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据id从数据库中查询对应的优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2.判断该优惠券是否开始以及结束</span></span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;活动已结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.查询库存是否充足</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span>(stock &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">            <span class="comment">//获取代理对象，避免自身调用导致事务失效</span></span><br><span class="line">            <span class="type">ISeckillVoucherService</span> <span class="variable">currentProxy</span> <span class="operator">=</span> (ISeckillVoucherService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> currentProxy.createVoucherOrder(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//4.一人一单判断</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, id).count();</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//该用户已经下过单</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;每个用户只能购买一次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.更新库存并使用乐观锁防止超卖问题</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, id).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.生成订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1 填入订单id，使用全局唯一id生成器生成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">voucherOrderId</span> <span class="operator">=</span> uniqueIdGenerator.generatorId(<span class="string">&quot;voucherOrder&quot;</span>);</span><br><span class="line">        voucherOrder.setId(voucherOrderId);</span><br><span class="line">        <span class="comment">//6.2 填入用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//6.3 填入优惠券id</span></span><br><span class="line">        voucherOrder.setVoucherId(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​这里的做法是将操作数据库的操作剥离出来形成一个方法，并以用户名作为锁，因为我们只需要拦截同一个用户的多次请求。并且可以发现我们是将锁加在调用者中，因为如果把锁加在剥离出来的方法上(由于我们规定了锁对象，因此只能使用代码块的方式加锁)，可能会出现锁已释放但事务还未提交(因为Spring中事务需要在方法执行完毕后才提交)，依然有线程安全问题，为了避免该情况的发生，我们将锁加在调用者上。</p><p>​从这里可以学习到：当想要给某个方法中某部分代码加锁并且这部分代码还要求事务时，可以将这部分代码单独抽离出来形成一个新的方法，并将锁加在调用者的对应代码上。</p><p>​这里还有一个值得我们注意的问题，那就是Spring事务失效的问题。(详细内容参考<a href="https://blog.csdn.net/HJW_233/article/details/131502536?spm=1001.2014.3001.5506">Spring事务@Transactional常见的8种失效场景（通俗易懂）_事务失效的8大场景-CSDN博客</a>)</p><p><strong>自调用失效：</strong>同一个类中，一个方法调用另一个方法，被调用方法上的事务不生效</p><p><strong>失效原因：</strong>spring事务底层使用动态代理，若同一个类中的方法吊用另一个方法，则不存在对象之间的代理关系，被调用方法的事务失效</p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">接口：HelloService，</span><br><span class="line">接口实现类：HelloServiceImpl</span><br><span class="line">方法：fun、fun2，fun2调用fun</span><br><span class="line"> </span><br><span class="line"># 新建类实现fun调用fun2</span><br><span class="line">新建类HelloServiceImpl2，方法fun2在HelloServiceImpl2中</span><br><span class="line">在类中注入HelloServiceImpl对象实例，方法fun在HelloServiceImpl中，</span><br><span class="line">在HelloServiceImpl2的fun2中，调用HelloServiceImpl的fun方法</span><br><span class="line"> </span><br><span class="line"># application.getBean</span><br><span class="line">在fun2中使用application.getBean(HelloService.class)获取对象helloService，</span><br><span class="line">然后使用helloService.fun实现方法调用</span><br><span class="line"> </span><br><span class="line"># AopUtils.currentProxy()</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span>，将exposeProxy = <span class="literal">true</span></span><br><span class="line">在fun2中使用((HelloService)AopContext.currentProxy()).fun()实现方法调用</span><br></pre></td></tr></table></figure><p>这里使用的是第三种方法</p><p>​通过本节需要掌握</p><ol><li>乐观锁和悲观锁的使用</li><li>如何实现一个秒杀功能</li><li>Spring事务失效的8种场景以及解决方案</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--线程运行原理</title>
      <link href="/2024/03/09/JUC--%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2024/03/09/JUC--%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h4><p>​在java中有三块用于存储数据的内存：栈、堆和方法区，其中方法区用来存储类加载后形成的字节码，堆用来存储引用类型的数据以及成员变量，而栈用来存储线程。</p><p>​每个线程都有属于自己的线程栈，栈与栈之间互不影响。每个线程栈都有一个个栈帧组成，每个栈帧对应着一个方法，存储着该方法所需要的局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFrame</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        method1(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过debug可以看到以上代码对应的栈结构</p><p><img src="/../images/JUC--%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20240309163410591.png" alt="image-20240309163410591"></p><h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>​所谓线程的上下文切换指的是某个线程由占有CPU的状态变为不占有CPU的状态。发生线程上下文切换时需要保存当前线程运行的状态，会使用PC(程序计数器)保存当前线程运行的指令，除此之外还需要保存线程中的一些变量等信息，可见发生线程的上下文切换需要完成许多工作，因此频繁的发生线程上下文切换会影响系统性能，需要尽可能避免。</p><p>​一般有以下原因会导致线程上下文切换：</p><ol><li>CPU时间片到</li><li>有更高优先级的线程到来</li><li>垃圾回收(发生垃圾回收时，所有工作线程都需要进入等待状态，让垃圾回收线程先工作，实际上可以归为第二种原因)</li><li>线程自己调用sleep，wait，join，lock等方法</li></ol><p>第一二种情况取决于操作系统使用的调度算法。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--用户信息脱敏展示</title>
      <link href="/2024/03/08/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B1%95%E7%A4%BA/"/>
      <url>/2024/03/08/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>​针对用户中的一些敏感信息，不能不展示，因为有时候需要用到这些数据，但又不能完全展示，因为可能会暴露用户的隐私(比如手机号，身份证号等信息)，因此需要对这些数据进行脱敏处理，即只展示数据的部分信息，其余部分用特殊字符表示。</p><p>​本项目中使用的是自定义Json序列化的方式，在SpringMVC中当用户信息返回给浏览器时默认会使用Jackson进行序列化，我们只需要改变此处的序列化方式就能达到给用户信息脱敏的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.shortlink.admin.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.DesensitizedUtil;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于给手机号进行脱敏处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDesensitizationSerializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(String phone, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">safePhone</span> <span class="operator">=</span> DesensitizedUtil.mobilePhone(phone);</span><br><span class="line">        jsonGenerator.writeString(safePhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要在需要脱敏的字段上使用@JsonSerialize注解并指明序列化器即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize(using = PhoneDesensitizationSerializer.class)</span></span><br><span class="line"><span class="keyword">private</span> String phone;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B1%95%E7%A4%BA/image-20240308215714626.png" alt="image-20240308215714626"></p><p>可以发现，用户的手机号码的信息成功进行了脱敏处理。</p>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081操作系统学习-2</title>
      <link href="/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/"/>
      <url>/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h4 id="Trap机制"><a href="#Trap机制" class="headerlink" title="Trap机制"></a>Trap机制</h4><p>​今天要讨论的内容是程序是如何完成从用户空间到内核空间的切换的，这种机制称为trap，今天的讨论会更加深入，更加底层也更加困难，希望大家能够尽可能的跟上。</p><p>​在xv6系统中，我们的设计是当用户程序发生系统调用、异常以及中断时，将会触发trap机制，完成由用户空间到内核空间的转换。</p><p>​以用户程序调用系统调用触发trap机制为例，研究底层是如何完成这种切换的。在这个过程中硬件的状态非常重要，有很多工作都是将硬件的状态由适合用户空间的状态改为适合内核的状态。而在诸多硬件中，我们最关心的是32个用户寄存器的状态(RISC-V中提供了32个寄存器，包括了堆栈寄存器Stack Register)，除了用户寄存器外还有一些对该过程非常重要的寄存器：</p><p>​STAP寄存器，指向了当前程序的最高级页表的地址；</p><p>​PC寄存器，也叫程序计数器，存储当前程序将要执行的指令；</p><p>​STVEC寄存器，指向内核中处理trap指令的起始地址；</p><p>​SEPC寄存器，在处理trap过程中用于保存PC寄存器中的值；</p><p>​用于表示系统当前状态的标识位mode</p><p>​SSRATCH寄存器，xx；</p><p>在接下来的讨论中我们可以看到这些寄存器是如何使用的。</p><p>​在进入底层之前，我们来思考一下，从用户空间转换为内核空间需要完成哪些工作。</p><ol><li>保存用户空间32个寄存器的内容</li><li>保存当前程序计数器(pc)中的内容</li><li>修改之前提到的内核标志位，标识系统此时进入内核区</li><li>将用户页表切换为内核页表</li><li>将堆栈寄存器指向内核中的一个地址，因为需要使用一个堆栈来执行内核中的程序</li></ol><p>其中1，2项工作的目的是在内核完成对应任务后，利用保存好的数据恢复用户程序的执行。</p><p>​接下来我们深入研究一下这个过程，观察操作系统内部做了哪些工作来完成该任务。当我们在shell中调用write系统调用时，实际上会执行以下代码</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309130042385.png" alt="image-20240309130042385"></p><p>​这是一个汇编程序，第一个语句表示将SYS_wirte中的数据加载到a7寄存器中，在xv6系统中SYS_write对应的是数字16(之前说过在用户空间执行的这些系统调用其实是某个数字的映射)。接下来会执行ecall指令，从这里开始系统进入了内核，内核完成工作后会执行ret将执行结果返回给shell。</p><p>​我们来看下这个过程究竟发生了什么，可以肯定的是系统一开始肯定是位于用户空间的，我们可以打印当前pc中的内容</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309132305756.png" alt="image-20240309132305756"></p><p>可以发现将要执行的指令为0xde6这就是ecall指令。还可以查看当前页表中的内容</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309131142145.png" alt="image-20240309131142145"></p><p>​可以发现该页表只有6条记录，这是因为shell是一个非常小的程序，它的内存占用非常小，只有3条记录真正用于该程序，还有一条是无效page作为guard page使用(第3条记录)，这几条记录的地址都比较小，这也证明了我们当前还处于用户区(用户区占用的地址都是比较小的地址，内核区的地址比较大，这样设计的好处是使用户区的内存很难影响到内核区)。</p><p>​接下来，我们来看一下执行了ecall指令后，系统发生了哪些变化。首先来查看一下将要执行的指令，同样打印pc中的内容</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309132458211.png" alt="image-20240309132458211"></p><p>​可以发现这是一个非常大的地址，进一步查看当前页表中的内容</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309132713383.png" alt="image-20240309132713383"></p><p>​可以发现和之前的页表完全相同。</p><p>​根据以上信息我们现在可以知道的只是我们当前将要执行的指令发生了变化。那么它之前存储的那个值也就是0xde6又被保存到了哪里？系统现在是在内核还是在用户区？接下来会执行哪些操作呢？</p><p>​对于第一个问题，我的解答是oxde6将会保存在SEPC寄存器中，而STVEC寄存器中的内容也就是0x3ffffff0会被加载到pc中，这也就是为什么系统当前执行的指令是这个，至于STVEC中的内容这是内核在返回用户空间之前设置的(正如之前提到的在设备启动时会先进入机器模式，然后迅速进入内核模式最后返回到用户空间)，第二个问题我们马上就会知道，至于最后一个问题，我们不妨来查看一下</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309133732748-17099626548461.png" alt="image-20240309133732748"></p><p>​可以发现系统其实已经执行完了一条指令，这条指令非常重要，待会我们也会讨论这条指令。这些指令其实是进入内核后首先需要执行的指令，也是trap机制中最开始要执行的指令。</p><p>​可以知道的是系统当前执行的指令为0x3ffffff000，你会发现这是页表中最后一条记录的地址。那么现在我可以肯定的告诉你们，我们现在已经进入了内核。因为页表中最后一条记录的u标志位为0，表示该记录只能由内核操作，而刚才我们看到系统确实执行了这条指令，也就是说系统使用了页表中的最后一条记录，而只有内核才能使用该条记录。</p><p>​页表中的最后一个page其实是trampoline page，这是一个非常重要的page，它包含了内核的trap处理代码。其实页表中最后两条记录存在于每个用户程序的页表中，这是因为ecall指令不会完成页表切换的工作(这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。)，因此必须设计一种方法至少完成进入内核的一些初始化操作。因此内核小心的将这两条记录放置在每个用户程序的页表中(由于ecall指令不会完成切换页表以及设置堆栈等操作，这是一种迫不得已的选择)，至于另一条记录有什么作用，我们待会也会讲到。</p><p>​之所以能够安心的将这两条如此重要的记录放置在每个用户程序的页表中，我们刚才也提到了这两条记录的u标志位为0，用户程序无法使用这两条记录，因此能够保证内核的安全。</p><p>​这里还有一个值得我们思考的问题：既然ecall不会完成页表的切换，而系统当前已经进入了内核，也就是说我们的内核程序当前使用的是用户程序的页表，为啥系统没有崩溃呢？</p><p>​–解答：这是因为我们当前还处于trampoline程序中，而该程序依赖的trampoline page在用户页表和内核页表中的映射关系是一样的。也就是说该程序可以通过用户页表找到对应的物理地址，也能通过内核页表找打对应的物理地址。</p><p>​我们来总结一下，ecall指令到底完成了哪些工作：</p><pre><code>1. 设置mode标志位，标志系统进入内核空间1. 将pc中的内容保存到SEPC寄存器中1. 将STVEC寄存器中的内容加载到pc中，再根据pc中的内容跳转到指定位置</code></pre><p>​ecall指令只完成了一小部分工作，想要运行位于内核区的其他c程序，还需要完成很多工作。</p><p>​要想运行c程序，需要使用寄存器，而现在这些寄存器中存放着用户程序中的值。因此，必须将这些寄存器中的值保存在某个地方，而这个地方就是用户页表中另一条记录指向的trapframe page。我们可以查看一下trapframe page中存放了什么</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309152411407.png" alt="image-20240309152411407"></p><p>​可以看到很多内容都对应着寄存器的名字，因此如何保存寄存器值的一半答案就是这些值最终会被保存在trapframe page中，另一半答案和我们之前看到的csrrw a0,sscratch,a0指令有关。该指令的作用是交换a0和sscratch中的值，其中sscratch中的值就是0x3fffffe000即trapframe 的位置(和STVEC一样，也是由内核提前设置好的)。为什么需要交换这两个寄存器的值呢？因为刚才说了，程序执行时需要寄存器的参与，我们需要一个空闲寄存器，（由于函数调用时往往将第一个参数存放在a0中，内核交换过程就是是由调用一个函数完成，因此a0中存放着sscratch中的值)，我们具体来看一下关于保存的代码</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309153527051.png" alt="image-20240309153527051"></p><p>​这是trampoline中的代码，可以发现保存时以a0作为基准，加上偏移量作为存放的地址。在此之后，会执行以下代码(同样位于trampoline中)</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/image-20240309153833461.png" alt="image-20240309153833461"></p><p>​ld sp,8(a0)表示将a0偏移8个字节所在的地址加载到sp中，而这个地址就是内核的Stack Pointer，这是一个比较重要的节点。</p><p>​在之后会向t1寄存器中写入内容，这里写入的是kernel page table的地址，接下来会交换SATP和t1寄存器的内容，至此一切工作准备就绪，可以运行位于内核中的c程序了。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.s081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081操作系统学习-1</title>
      <link href="/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>​最近也是在学习MIT6.s081，学了一段时间后，知识点很多也很杂，今天在复习的同时也顺带将这些知识点串一下。</p><p>​<strong>首先，我们需要知道什么是操作系统？操作系统有什么用？</strong></p><p>​那么我认为，操作系统它也是一个程序，只不过它是一个特殊的程序。为什么呢？操作系统能够执行一些特殊的指令，比如创建进程，分配内存等。而普通的程序没有执行这些操作的权限，那有人可能会说，不对啊，我平时使用java等编程语言也能创建进程啊。别急，等下会介绍这个话题。这是因为操作系统能够直接操控最底层的硬件资源，一般的操作系统会将这些硬件资源进行抽象，比如将磁盘等存储器抽象为文件，将CPU抽象为进程。为什么要设计操作系统呢？一方面，是为了方便用户更好的使用计算机，因为直接和硬件打交道太麻烦了，用户必须得输入二进制指令才能和计算机进行交互，有了操作系统后，可以基于操作系统开发出更加高级的语言来和计算机进行交互，比如汇编，C，C++等；但其实最重要的一点是，设计操作系统是为了保护底层硬件，用户可以直接操控底层硬件是一种非常可怕且危险的形式，有些不怀好意的人他们编写的程序可能会使你的计算机崩溃，这不是一种好的设计。因此操作系统必须具有很强的隔离性，它能够阻止恶意程序攻击你的设备。但与此同时，操作系统也必须拥有良好的交互性，比如刚才就有人提问使用java也能够创建进程这其实就是和操作系统间的交互。或许这听起来很矛盾，但一个真正的操作系统确实如此，这也是设计一个好的操作系统的难点。接下来，我们来看一下操作系统的组织结构，可能会让你了解操作系统是如何保证强隔离性的同时又有一定的交互性。</p><p>​<strong>操作系统的组织结构</strong></p><p>​上一节中讲到，一个好的操作系统必须提供极强的隔离性，从而保证底层硬件的安全，同时它又得提供一定得交互性，那么本节我们来探讨在xv6操作系统中是如何实现的。我们先来介绍一下隔离性，其实在设计操作系统时，主要通过两种措施来实现其隔离性。</p><p>######建立一堵墙：</p><p>​这是一个很好的想法，如果我们想把两样东西分隔开来，我们可以在它们中间设立一些障碍，至少柏林曾经有过一段时间就被一堵墙分隔成了两部分，不是吗。那么在操作系统中这堵墙就叫做user&#x2F;kernel mode，也就是说操作系统将计算机分成了两部分，上面的那部分叫做user space用户区，下面那部分叫做kernel space内核区，内核区中存放着操作系统的所有功能模块(但其实这是宏内核的划分方法，而xv6系统使用的就是宏内核，在微内核系统中，操作系统中部分功能模块也位于用户区)。一切特殊权限指令都将也必须在内核区执行，这保证了操作系统的隔离性</p><img src="../images/MIT6.S081操作系统学习/image-20240302151522555.png" alt="image-20240302151522555" style="zoom:50%;" /><h6 id="独立的空间："><a href="#独立的空间：" class="headerlink" title="独立的空间："></a>独立的空间：</h6><p>​这也是一个很好的想法，当我们将两个人安置在不同的房间里，他们自然也无法干扰对方了。在操作系统中我们将这个空间叫做页(大小一般为4KB)。每个程序(进程)都只会在自己的页面中活动，而操作系统需要保证每个程序的房间里不会出现其他程序的物品，实现这项功能的技术称为虚拟内存和内存管理系统(MMU)。在计算机中每条地址指令的内容都指的是虚拟地址，需要通过转化才能得到其真正的物理地址。在操作系统中提供了一种数据结构来方便进行这种转化——页表，页表中存放着每个页面对应的物理地址，其实就是一种映射结构。在xv6系统中，每条虚拟地址需要使用64位二进制数字，但实际有效的是后39位，其中最后12位表示偏移量(offset)，27位表示用于转化为页面。你们或许会问，既然只使用39位，为啥需要64位二进制。我想说的是，这不是我们能够决定的，64位二进制是由底层硬件决定的，你的存储器芯片具有64位二进制，那么你的地址就是64位，你当然可以将这64位二进制都用掉，但是一般我们不会这么做，因为我们需要保留一部分以供未来进行扩展使用。但主要的原因是，xv6系统只是一个小型操作系统，39位已经足以支撑我们整个系统结构了。</p><p><img src="/../images/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/image-20240318105019800.png" alt="image-20240318105019800"></p><p>​上图展示的是xv6系统中每个进程所拥有的虚拟地址空间，可以看到地址是从0开始的，接下来这部分内存用于存储用户数据比如一些全局变量等，然后是栈空间。还有相当大的一部分空间：heap，这部分空间用于该进程进行内存扩展。</p><p>​接下来，我们仔细研究一下页表这个结构，很显然，页表必须存储在内存中某个位置。既然我们的虚拟地址中有27位用于表示页表，那也就意味着页表中需要存放2^27条记录，而在xv6系统中每条记录需要使用64位二进制，这是一块相当大的内存，可能在某些页表占用内存较小的系统中是这么设计的(将所有页面与物理地址的映射关系存放在一个页表中)。但显然我们不能这么设计，一种更好的做法是设置多级页表，什么意思呢？也就是说在更高一级的页表中存放着比它低一级页表的位置，而在最低一级页表中存放着该虚拟地址对应的物理地址。这听起来或许很抽象，让我们用一张图来说明这一切。</p><img src="../images/MIT6.S081操作系统学习/image-20240229101310378.png" style="zoom:50%;" /><p>​通过这张图，我们可以了解xv6系统中虚拟地址是如何转化为其物理地址的。在xv6系统中设置了3级页表，当接收到一个虚拟地址时，先通过satp(位于CPU中的一个寄存器，存放着当前进程最高一级页表的地址)，获取最高一级页表的首地址，通过偏移量(L2)获取该地址对应的第二级页表的首地址，再通过偏移量(L1)获取该地址对应的最低级页表的首地址，然后通过偏移量(L0)找到该地址对应的物理地址的首地址(再计算机中地址都是以块的形式存在的，块的大小和页的大小一致)，最后通过偏移量(offset)获取该地址中存放的数据。尽管这个过程十分繁琐，有点类似链表，但是经过这种操作，页表所需要的内存确实降低了：每个页表中只需要存放2^9条数据，总共有3*2 ^9条数据。但是这种做法有一个明显的缺点：每次转化都需要访问内存3次，在效率上是个问题。</p><p>​一种提高效率的方法是：设置缓存，即每次转化，先从缓存中查看是否已经有该数据，如果有则直接返回结果；如果没有，再利用上述过程得到其物理地址，并将其存放入缓存中。至于缓存中存在的一些问题，比如：数据一致性问题，大家有兴趣的可以自行了解，这里不再深入讨论。</p><p>​需要注意的是，每个进程都有自己的页表，因此当CPU进行进程切换时，会加载对应进程的页表地址到satp寄存器中，并且清空缓存。</p><p>​再上述图片中我们还可以了解到的是，在xv6系统中页表中存放的每条数据只使用了54位二进制(剩下10位作为保留位)，其中44位用于表示内存(<strong>难道xv6的内存空间有几TB那么大？</strong>)，10位用作标志位。在这10位标志位中，最低位表示该条记录是否是有效记录，接下来3位分别表示是否可以对该记录进行读、写、执行操作。</p><p>​至此，我们终于初步了解了操作系统是如何保证其强隔离性的。我们用几句话简单概括一下，通过设置user&#x2F;kernel mode将用户区和内核区隔离，保证用户程序无法直接执行特殊指令，从而提供了指令隔离；通过虚拟内存技术，保证了各个程序间内存上互不干扰，从而提供了内存隔离。</p><h5 id="一定的交互性"><a href="#一定的交互性" class="headerlink" title="一定的交互性"></a>一定的交互性</h5><p>​经过前几节的学习，我相信你已经对操作系统的隔离性有了一定的认识，由于这些知识点非常重要也是操作系统中比较难的一部分，因此我们花了比较多的时间来学习，我相信这些时间是值得的。好了，接下来我们放松点，来了解一下操作系统是如何提供交互的，当然，这个知识点也很重要，希望你们也能够好好听讲。</p><p>​一个完全封闭的操作系统是没有意义的，因为没有用户可以使用它。因此操作系统必须具有一定的交互能力，一种想法就是在墙的两边安装电话线，通过电话实现交流。在两边分别有两个接线员，用户区的负责人叫做ECALL，内核区的负责人叫做syscall，而电话线叫做中断程序。操作系统给用户区提供了许多电话号码(也就是系统调用)，当用户拨打了这个电话号码，ECALL会为其接线，当syscall收到后，它首先会打开某个开关(一个标志位，表示系统现在的状态)，表示系统现在进入到内核区，然后它会查看该用户的请求是否合理，如果合理再由它打电话给相应人员去完成；否则它会拒绝该请求，完成后它会关掉开关进入用户模式。</p><p>​以上这个例子是我对操作系统进行交互时的理解，比较学术的说法就是。操作系统提供了许多系统调用，所谓系统调用就是一些接口，其具体实现都位于内核区。当用户程序使用了这些系统调用时，ECALL函数将该系统调用作为参数传入(在xv6系统中这些系统调用都是由一个数字表示，比如read对应的数字为0)。然后会触发一个软中断，该中断程序位于内核，因此就成功从用户区切换为内核区。位于内核区的syscall函数会检查请求是否合理，并调用真正的系统函数来完成请求。</p><p>​以上就是对操作系统的交互性的认识，我们也稍微总结一下。首先操作系统通过提供系统调用接口来实现和用户区的交互，用户区通过ECALL来实现内核区的转换，有一个标志位用于标识当前是位于用户区还是内核区，当然该标志位由内核控制，最后在用户区调用的系统函数，最终是在内核区执行的。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.s081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>O(1)时间复杂度求动态数据的中位数</title>
      <link href="/2024/03/08/O(1)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E5%87%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2024/03/08/O(1)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E5%87%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>​中位数大家都知道，就是一些数经过排序后最中间的数。具体来说如果有n个排好序的数，当n为奇数时，这些数的中位数就是下标为n&#x2F;2（下取整）的数；当n为奇数时，这些数的中位数就是下标为n&#x2F;2和下标为n&#x2F;2+1的数的平均数。</p><p>​如果给定一个无序数组，并且数组中的数据是动态的，存在删除和新增操作，如何在O(1)的时间复杂度内快速得到该数组的中位数呢？</p><p>​详细题目可以参考<a href="https://leetcode.cn/problems/find-median-from-data-stream">LeetCode295</a></p><p>​这里提供的思路为：用一个大根堆维护数组中较小的一半的数，用一个小根堆维护数组中较大的一半的数，当数组的长度为偶数时，该数组的中位数等于两个堆顶元素的平均值；当数组的长度为奇数时，该数组的中位数等于小根堆的堆顶元素(因为优先插入的是小根堆，所以当数组长度为奇数时，小根堆中的元素个数比大根堆多一)</p><p>​具体的维护方式为：当小根堆和大根堆中的元素个数相等时，此时如果发生数据的添加，需要往小根堆中添加元素，为了使小根堆中的元素始终是数组中较大的一半，先将该元素插入大根堆中，再将大根堆的堆顶元素插入小根堆中；如果不相等，往大根堆中添加元素，为了使大根堆中的元素始终是数组中较小的一半，先将该元素插入小根堆中，再将小根堆的堆顶元素插入大根堆中。至于数据的删除，也可以按照同样的思路，只要保证小根堆中存储的是较大一半的数，大根堆中存储的是较小一半的数即可。</p><p>​实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt;heapMax;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt;heapMin;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        heapMax = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a,Integer b)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        heapMin = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeMax</span> <span class="operator">=</span> heapMax.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeMin</span> <span class="operator">=</span> heapMin.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sizeMax == sizeMin)&#123;</span><br><span class="line">            heapMax.add(num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> heapMax.poll();</span><br><span class="line">            heapMin.add(top);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            heapMin.add(num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> heapMin.poll();</span><br><span class="line">            heapMax.add(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> heapMin.size() + heapMax.size();</span><br><span class="line">        <span class="type">double</span> median;</span><br><span class="line">        <span class="keyword">if</span>(size % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            median = (<span class="type">double</span>)(heapMin.peek() + heapMax.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            median = heapMin.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--全局统一返回实体</title>
      <link href="/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5--%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AE%9E%E4%BD%93/"/>
      <url>/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5--%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AE%9E%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h4 id="全局统一返回实体"><a href="#全局统一返回实体" class="headerlink" title="全局统一返回实体"></a>全局统一返回实体</h4><p>​为了使在返回给浏览器数据时更加方便，适配各种返回情况，比如只返回成功或失败的信息、返回信息和数据，只返回数据等等。提高开发效率</p><p>全局统一返回实体的设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serial;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局返回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5679018624309023727L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正确返回码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUCCESS_CODE</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS_CODE.equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Accessors注解：位于Lombok插件包中，作用于类和属性上，对属性的getter和setter方法有影响。有三个属性：fluent、chain和prefix</p><p>fluent属性：默认为false，当该属性为true时，表示去除getter和setter方法的get和set，也就是说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(fluent = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(fluent = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.name(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chain属性：默认为false，当该属性为true时，调用bean的set方法可以返回该对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prefix属性：该属性是一个字符串数组，能够去掉getter和setter方法中属性指定的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(prefix = &#123;&quot;xx&quot;,&quot;yy&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String xxName;</span><br><span class="line">    <span class="keyword">private</span> String yyAge;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局统一返回实体构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.exception.AbstractException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局返回对象构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Results</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造成功响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造带返回数据的成功响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE)</span><br><span class="line">                .setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建服务端失败响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">failure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(BaseErrorCode.SERVICE_ERROR.code())</span><br><span class="line">                .setMessage(BaseErrorCode.SERVICE_ERROR.message());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 &#123;<span class="doctag">@link</span> AbstractException&#125; 构建失败响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">failure</span><span class="params">(AbstractException abstractException)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorCode</span> <span class="operator">=</span> Optional.ofNullable(abstractException.getErrorCode())</span><br><span class="line">                .orElse(BaseErrorCode.SERVICE_ERROR.code());</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> Optional.ofNullable(abstractException.getErrorMessage())</span><br><span class="line">                .orElse(BaseErrorCode.SERVICE_ERROR.message());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(errorCode)</span><br><span class="line">                .setMessage(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 errorCode、errorMessage 构建失败响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">failure</span><span class="params">(String errorCode, String errorMessage)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(errorCode)</span><br><span class="line">                .setMessage(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问：为啥要特意创建一个类来实例化另一个类？</p><p>解答：为了代码整洁？</p><p>通过本节需要掌握</p><ol><li>全局统一返回实体的设计和使用</li><li>一些注解的使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--异常码的设计和使用</title>
      <link href="/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%BC%82%E5%B8%B8%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%BC%82%E5%B8%B8%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>####异常码的设计和使用</p><p>​为了更快的确定异常原因，从而快速定位出错地点并解决异常。可以使用异常码，每个异常码都对应一个特定的错误。本项目参考阿里巴巴开发手册，将出错原因大体上分为3类：用户端出错，服务器端出错以及远端第三方组件出错，分别用大写英文字母A、B、C标识，每个类别下使用6位数字来表示出错原因，因而总共可以表示30万种错误。每个大类中根据内容详细程度不同，分为3个级别，级别越高内容越详细。</p><p>异常码设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Interface IErrorCode&#123;</span><br><span class="line">    String code;</span><br><span class="line">    String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础异常码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础错误码定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BaseErrorCode</span> <span class="keyword">implements</span> <span class="title class_">IErrorCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 一级宏观错误码 客户端错误 ==========</span></span><br><span class="line">    CLIENT_ERROR(<span class="string">&quot;A000001&quot;</span>, <span class="string">&quot;用户端错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 二级宏观错误码 用户注册错误 ==========</span></span><br><span class="line">    USER_REGISTER_ERROR(<span class="string">&quot;A000100&quot;</span>, <span class="string">&quot;用户注册错误&quot;</span>),</span><br><span class="line">    USER_NAME_VERIFY_ERROR(<span class="string">&quot;A000110&quot;</span>, <span class="string">&quot;用户名校验失败&quot;</span>),</span><br><span class="line">    USER_NAME_EXIST_ERROR(<span class="string">&quot;A000111&quot;</span>, <span class="string">&quot;用户名已存在&quot;</span>),</span><br><span class="line">    USER_NAME_SENSITIVE_ERROR(<span class="string">&quot;A000112&quot;</span>, <span class="string">&quot;用户名包含敏感词&quot;</span>),</span><br><span class="line">    USER_NAME_SPECIAL_CHARACTER_ERROR(<span class="string">&quot;A000113&quot;</span>, <span class="string">&quot;用户名包含特殊字符&quot;</span>),</span><br><span class="line">    PASSWORD_VERIFY_ERROR(<span class="string">&quot;A000120&quot;</span>, <span class="string">&quot;密码校验失败&quot;</span>),</span><br><span class="line">    PASSWORD_SHORT_ERROR(<span class="string">&quot;A000121&quot;</span>, <span class="string">&quot;密码长度不够&quot;</span>),</span><br><span class="line">    PHONE_VERIFY_ERROR(<span class="string">&quot;A000151&quot;</span>, <span class="string">&quot;手机格式校验失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 二级宏观错误码 系统请求缺少幂等Token ==========</span></span><br><span class="line">    IDEMPOTENT_TOKEN_NULL_ERROR(<span class="string">&quot;A000200&quot;</span>, <span class="string">&quot;幂等Token为空&quot;</span>),</span><br><span class="line">    IDEMPOTENT_TOKEN_DELETE_ERROR(<span class="string">&quot;A000201&quot;</span>, <span class="string">&quot;幂等Token已被使用或失效&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 一级宏观错误码 系统执行出错 ==========</span></span><br><span class="line">    SERVICE_ERROR(<span class="string">&quot;B000001&quot;</span>, <span class="string">&quot;系统执行出错&quot;</span>),</span><br><span class="line">    <span class="comment">// ========== 二级宏观错误码 系统执行超时 ==========</span></span><br><span class="line">    SERVICE_TIMEOUT_ERROR(<span class="string">&quot;B000100&quot;</span>, <span class="string">&quot;系统执行超时&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 一级宏观错误码 调用第三方服务出错 ==========</span></span><br><span class="line">    REMOTE_ERROR(<span class="string">&quot;C000001&quot;</span>, <span class="string">&quot;调用第三方服务出错&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    BaseErrorCode(String code, String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">message</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常的设计和使用"><a href="#异常的设计和使用" class="headerlink" title="异常的设计和使用"></a>异常的设计和使用</h4><p>​根据异常码的分类，因此产生的异常也分为3类.</p><p><strong>异常类设计</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象项目中三类异常体系，客户端异常、服务端异常以及远程服务调用异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ClientException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RemoteException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String errorCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String errorMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, throwable);</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorCode.code();</span><br><span class="line">        <span class="built_in">this</span>.errorMessage = Optional.ofNullable(StringUtils.hasLength(message) ? message : <span class="literal">null</span>).orElse(errorCode.message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientException</span> <span class="keyword">extends</span> <span class="title class_">AbstractException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, BaseErrorCode.CLIENT_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(String message, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, throwable, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ClientException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&#x27;&quot;</span> + errorCode + <span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;message=&#x27;&quot;</span> + errorMessage + <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 远程服务调用异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteException</span> <span class="keyword">extends</span> <span class="title class_">AbstractException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, BaseErrorCode.REMOTE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteException</span><span class="params">(String message, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, throwable, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RemoteException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&#x27;&quot;</span> + errorCode + <span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;message=&#x27;&quot;</span> + errorMessage + <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceException</span> <span class="keyword">extends</span> <span class="title class_">AbstractException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, BaseErrorCode.SERVICE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Optional.ofNullable(message).orElse(errorCode.message()), throwable, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ServiceException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&#x27;&quot;</span> + errorCode + <span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;message=&#x27;&quot;</span> + errorMessage + <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​在处理异常上，设置全局异常拦截器，统一处理产生的所有异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.collection.CollectionUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.exception.AbstractException;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.result.Result;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.result.Results;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.FieldError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截参数验证异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">validExceptionHandler</span><span class="params">(HttpServletRequest request, MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> ex.getBindingResult();</span><br><span class="line">        <span class="type">FieldError</span> <span class="variable">firstFieldError</span> <span class="operator">=</span> CollectionUtil.getFirst(bindingResult.getFieldErrors());</span><br><span class="line">        <span class="type">String</span> <span class="variable">exceptionStr</span> <span class="operator">=</span> Optional.ofNullable(firstFieldError)</span><br><span class="line">                .map(FieldError::getDefaultMessage)</span><br><span class="line">                .orElse(StrUtil.EMPTY);</span><br><span class="line">        log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;</span>, request.getMethod(), getUrl(request), exceptionStr);</span><br><span class="line">        <span class="keyword">return</span> Results.failure(BaseErrorCode.CLIENT_ERROR.code(), exceptionStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截应用内抛出的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = &#123;AbstractException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">abstractException</span><span class="params">(HttpServletRequest request, AbstractException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex.getCause() != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString(), ex.toString(), ex.getCause());</span><br><span class="line">            <span class="keyword">return</span> Results.failure(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString(), ex.toString());</span><br><span class="line">        <span class="keyword">return</span> Results.failure(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截未捕获异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">defaultErrorHandler</span><span class="params">(HttpServletRequest request, Throwable throwable)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; &quot;</span>, request.getMethod(), getUrl(request), throwable);</span><br><span class="line">        <span class="keyword">return</span> Results.failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUrl</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(request.getQueryString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> request.getRequestURL().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request.getRequestURL().toString() + <span class="string">&quot;?&quot;</span> + request.getQueryString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@SneakyThrows注解：可作用于方法和构造函数上，可以帮助捕获异常，简化代码，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">utf8ToString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用该注解后，可以使代码更加简洁。该注解位于Lombok中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">utf8ToString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过本节需要掌握</p><ol><li>异常码的设计和使用</li><li>异常类的设计和使用</li><li>全局异常处理器的设计</li><li>@SneakyThrows注解的使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目全局唯一ID生成器</title>
      <link href="/2024/03/07/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2024/03/07/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="开发全局唯一ID生成器"><a href="#开发全局唯一ID生成器" class="headerlink" title="开发全局唯一ID生成器"></a>开发全局唯一ID生成器</h4><p>​保证id唯一的方法有很多种，本项目使用的是基于Redis的id生成器，其基本原理是借助于Redis自带的increment自增方法。</p><p>​<strong>生成原理</strong>：以long类型作为生成id的类型，long类型具有64位，将这64位分为三部分，[63,63],[32,62],[0,31]。最高位是符号位，是一个固定值0，表示生成的id是非负数，后面63位需要决定生成id的唯一性。具体方法为，[0,31]位上填充由Redis的increment方法生成的值，[32,62]位填充当前时间距离某个基准时间的时间(一般以秒作为单位，69年后生成的值才会超过31位)。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E5%99%A8/image-20240307191739286.png"></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用于生成全局唯一ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniqueIdGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2024.01.01 00:00:00作为基准时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIME_BEGIN</span> <span class="operator">=</span> <span class="number">1704067200L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的业务生成不同的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix 业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">generatorId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> now - TIME_BEGIN;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy:MM:dd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">timeStamp</span> <span class="operator">=</span> simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//为了便于管理和查询，将当日时间融入key中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + timeStamp;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(key);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> interval &lt;&lt; <span class="number">32</span> | count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习完本节需要掌握以下知识点：</p><ol><li>如何通过Redis生成全局唯一ID</li><li>时间戳的巧用</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--创建线程</title>
      <link href="/2024/03/07/JUC--%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/03/07/JUC--%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在java中创建一个线程有3种方法。</p><p>一.直接new一个Thread对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread1</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;t1 is doing&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>二.通过Runnable接口辅助创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 is doing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对第二种方法可以通过lambda对其简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;t3 is doing&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑问</strong></p><p>以上代码中可以发现有new Runnable这个操作，Runnable是一个接口，为啥能够被实例化？</p><p>–解答：在java中接口和抽象类是不能被实例化的，在这里也不例外.而这里其实是使用了匿名内部类，也就是说new出来的这个对象不是Runnable，而是一个实现了该接口的子类，这也是为什么run方法上出现@Override注解的原因。等价于以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2 is doing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现，相较于使用匿名内部类，后者需要额外创建一个类，更加麻烦。因此对于那些只在某些只使用一次的接口实现子类，可以使用匿名内部类的方式创建，这也是我们经常使用的方式，比如在给集合排序时，就会使用匿名内部类来实现Comparator接口。</p><p>三.通过FutureTask辅助创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread4</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">      FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;t4 is doing&quot;</span>);</span><br><span class="line">              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">      thread4.start();</span><br><span class="line">      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> task.get();</span><br><span class="line">      System.out.println(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​FutureTask实现了RunnableFuture接口，而RunnableFuture继承了Runnable接口，因此FutureTask也实现了Runnable接口。</p><p>​FutureTask类中提供了两个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​第一种构造方法的Callable也是一个接口，里面有一个抽象方法call()，用于返回计算结果.FutureTask的get方法能够获取该返回值，需要注意的是该get方法是一个阻塞式线程，它会一直等待这个返回值，所以如果你将task.get()语句放在thread4.start()语句之前，就会发生死锁现象。</p><p>​需要注意的是，以上3中创建线程的方法中，其实只有第一种方法才是真正创建了一个线程，后两者只是创建了线程所要运行的任务，即run方法中的内容，不过由于后两种方法能够将创建线程和线程要运行的任务分开，是编程更加灵活，因此也更受青睐。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2024/03/07/%E7%AE%97%E6%B3%95--%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2024/03/07/%E7%AE%97%E6%B3%95--%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="单调栈题集"><a href="#单调栈题集" class="headerlink" title="单调栈题集"></a>单调栈题集</h4><p>​单调栈是一种特殊的栈，因为栈中的元素大小是单调的而得名单调栈。经过预处理(预处理的时间复杂度为O(n))，可以在O(1)的时间复杂度求出数组中每个元素右边(左边)第一个大于(小于)该元素的值的下标。是一种非常常用且好用的数据结构</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram">LeetCode84</a></p><p>​这道题我一开始的想的暴力做法是枚举两个自由度，第一个自由度表示该矩形的起始位置(start)，另一个自由度表示该矩形的结束位置(end)，在枚举的过程中维护一个最小高度(minH)并更新答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">minH</span> <span class="operator">=</span> heights[i];</span><br><span class="line">   res = Math.max(res,minH);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j ++)&#123;</span><br><span class="line">       minH = Math.min(minH,heights[j]);</span><br><span class="line">       res = Math.max(res,(j - i + <span class="number">1</span>) * minH);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这似乎也是一种暴力思路，但是由于我一开始想的暴力做法是以上做法，导致我想利用双指针来进行优化，还是没想出来。</p><p>​但其实还有另一种暴力思路，枚举当前该高度能够形成的最大矩形，也要枚举两个自由度，一个就是数组中的每个高度height，另一个就是左右两边第一个比它小的高度的下标minL，minR，该矩形的面积就是height * (minL - minR)。在这种思路下，我一下子就想到了使用单调栈来优化。因为单调栈能够在O(1)的时间复杂度内得到左右两边第一个小于某个数的下标(在经过预处理的情况下)，因此总的时间复杂度为O(n)</p><p>​实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> minL[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//minL[i]表示左边第一个小于heights[i]的下标</span></span><br><span class="line">        <span class="type">int</span> minR[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//minR[i]表示右边第一个小于heights[i]的下标</span></span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line">        Stack&lt;Integer&gt;stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                minR[i] = n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minR[i] = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                minL[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minL[i] = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举每个高度下能够形成的最大矩形</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> heights[i] * (minR[i] - minL[i] - <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res,s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/maximum-width-ramp">LeetCode962</a></p><p>​本题求解的问题是：大于某个数且距离最远的数的位置。暴力做法是枚举两个自由度，枚举每个数再枚举每个比它大的数,时间复杂度为O(n^2^).稍微优化的做法是在枚举比它大的数时可以倒着枚举，如果发现距离比当前答案还小就可以剪枝。</p><p>​一种更加优化的做法是利用单调栈，因为要求解距离最大值，可以预处理处以A[0]为起始点的递减序列，这个序列就是暴力做法中的一个自由度(意味着我们不必枚举每个数，而只要枚举这个序列中的数)。可以使用反证法证明这个自由度一定位于该递减序列中，如果答案是i-k，且k不在此递减序列中，那么意味着k前面没有比它更小的数，但这也意味着k位于该递减序列中(因为我们的递减序列是以下标为0开始的)。接下来，只要倒着枚举另一个自由度即可。(一旦比栈中数大，更新答案)。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxWidthRamp</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Stack&lt;Integer&gt;min = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        min.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[min.peek()])min.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!min.isEmpty() &amp;&amp; nums[min.peek()] &lt;= nums[i])&#123;</span><br><span class="line">                res = Math.max(res,i - min.peek());</span><br><span class="line">                min.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目开发缓存工具类</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存工具类"><a href="#缓存工具类" class="headerlink" title="缓存工具类"></a>缓存工具类</h4><p>​在解决缓存技术中存在的问题时，其解决方案基本上是有固定套路的</p><p>​针对缓存穿透问题(指查询数据既不存在于缓存中，也不存在于数据库中，如果有用户恶意刷该请求，会给数据库造成巨大压力，影响系统性能)，有以下两种解决方案：</p><ol><li>当数据库查询不到数据时，给缓存返回空值。这个方案也是有问题的，比如此后不久数据库中插入了该数据，那么直到缓存中的空值过期，否则用户一直无法取到对应数据，并且会消耗额外的内存。</li><li>采用布隆过滤器技术：这是一种利用二进制来判断缓存中是否有对应数据的技术，作用于用户请求和Redis之间，能够过滤掉缓存和数据库中都不存在数据的请求。但是实现复杂，并且存在误判可能(类似于哈希冲突)</li></ol><p>​针对缓存雪崩问题(指某一段时间，缓存中的大量数据失效在项目初始化时，有大量数据同时加入缓存，又称为数据预热或者缓存服务挂了，导致大量请求涌入数据库，给数据库造成巨大压力，影响系统性能)，有以下解决方案</p><ol><li>给缓存中的每条数据设置随机的过期时间。该方案只能解决前一种情况</li><li>针对第二种情况，可以采用缓存集群以及设置多级缓存的方式加以解决。</li></ol><p>​针对缓存击穿问题(通常是针对某些热点key，比如某些促销活动，在很短时间内有大量请求涌入，此时某个key失效，会导致大量请求不断涌入数据库，给数据库造成巨大压力，不仅影响用户体验，还可能使系统崩溃)，有以下解决方案：</p><ol><li>给缓存中的数据设置逻辑过期时间，即缓存中的每条数据都不会失效，而是让程序员在编写代码时判断该数据是否有效。这种做法的优点是性能较高，但是由于缓存中的数据不会失效，因此保证不了数据一致以及消耗了额外内存。</li><li>设置互斥锁，即当第一个线程发现缓存中无数据时，它会去访问数据库同时给该数据上锁，上锁的目的是让其他线程无法访问缓存从而也引发缓存重构。这种做法的优点是能够保证数据的一致性，缺点是由于线程必须等待，因此性能较低</li></ol><p>从上面这几种缓存中出现的问题，我们可以得出缓存中的问题基本上都是关于数据不一致的以及数据库压力过大的问题，由于使用场景颇多，如果每次开发时，都要额外写一套代码，既繁琐代码也没得到复用，基于以上情况，开发一个缓存工具类，具有以下功能。</p><ol><li><p>可以将任意java对象存储进String类型的value中，并可以设置有效时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time,timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以将任意java对象存储进String类型的value中，并可以设置逻辑过期时间，用于处理缓存击穿问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogic</span><span class="params">(String key,Object value,Long time,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(value);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    </span><br><span class="line">       stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里针对逻辑过期的做法是对数据进行再封装，符合OCP原则。</p></li><li><p>根据key查询数据并反序列化为指定类型，当无该数据时将空值存储进redis中用于解决缓存穿透问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key查询数据并反序列化为指定类型，当无该数据时将空值存储进redis中用于解决缓存穿透问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix 前缀和id组合在一起构成key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dbFeedBack 由调用者指定查询数据库的逻辑，是查询商户还是其他逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 返回值类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; 由调用者指定id类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;ID&gt; 由调用者指定返回值类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;R,ID&gt;R <span class="title function_">queryWithPassThrough</span><span class="params">(String prefix, ID id, Class&lt;R&gt;type,Function&lt;ID,R&gt; dbFeedBack,Long time,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> prefix + id;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(json != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">R</span> <span class="variable">ret</span> <span class="operator">=</span> dbFeedBack.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="literal">null</span>)&#123;</span><br><span class="line">        set(key,<span class="string">&quot;&quot;</span>,time,timeUnit);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        set(key,ret,time,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据key查询数据并反序列化为指定类型，并使用逻辑过期解决缓存击穿问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R,ID&gt;R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String prefix,ID id,Class&lt;R&gt;type,Function&lt;ID,R&gt;dbFeedBack,Long time,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> prefix + id;</span><br><span class="line">    <span class="comment">//查看Redis中是否有该商户</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">        <span class="comment">//Redis中有该商户，直接返回</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">cacheData</span> <span class="operator">=</span> JSONUtil.toBean(json,type);</span><br><span class="line">        <span class="keyword">return</span> cacheData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(json != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//shopJson是空字符串，说明数据库中也没有该店铺</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始缓存重建</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span>(!lock)&#123;</span><br><span class="line">            <span class="comment">//有其他线程在重建，进入等待</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithLogicalExpire(prefix,id,type,dbFeedBack,time,timeUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = dbFeedBack.apply(id);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数据库中也没有该数据，查询错误,向Redis中插入空数据防止缓存穿透,并设置2min有效期</span></span><br><span class="line">            set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            setWithLogic(key,ret,CACHE_SHOP_TTL,TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        delLock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//设置互斥锁防止缓存击穿,设置锁的有效期为10s，防止发生故障锁未释放</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;0&quot;</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过本节需要掌握以下知识点：</p><ol><li>如何通过互斥锁来解决缓存击穿问题的，互斥锁是如何实现的</li><li>在编写该工具类时泛型的使用以及Function是如何使用的</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小未出现正整数</title>
      <link href="/2024/03/06/O(n)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E6%95%B0%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"/>
      <url>/2024/03/06/O(n)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E6%95%B0%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="O-n-时间复杂度常数空间求解最小未出现正整数"><a href="#O-n-时间复杂度常数空间求解最小未出现正整数" class="headerlink" title="O(n)时间复杂度常数空间求解最小未出现正整数"></a>O(n)时间复杂度常数空间求解最小未出现正整数</h4><p><a href="https://leetcode.cn/problems/first-missing-positive">LeetCode41</a></p><p>​这道题的难点在于，既要求时间复杂度控制在O(n)，有要求常数级空间复杂度。</p><p>​假设抛开时间复杂度复杂度这一要求，我们可以使用快排或者二分来实现，都能满足常数时间复杂度的要求。</p><p>​如果抛开空间复杂度这一要求，我们可以额外创建一个哈希表来记录数组中的数，能够满足O(n)时间复杂度的要求。</p><p>​如果想要满足这两个要求，这是一种思维上的挑战。这里的想法是，其实题目中有一个隐含条件，那就是[1,2,…n]这个数组，我们只要保证让n以内的数在nums中有序，再通过对比这个数组就能找出最小未出现正整数，这也是排序做法的思路。做法就是让这些数回到它们本应该在的位置，比如2应该在nums下标为1的位置，同理，n应该在nums下标为n-1的位置，遍历nums每个数，将n以内的数交换至对应的位置，这样就能实现nums数组的部分有序性，这样就既符合时间复杂度O(n)(交换的次数非常少),常数级空间复杂度。</p><p>​实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                <span class="comment">//由于nums[i] - 1依赖于nums[i]因此以下这种交换规则是错误的，期间nums[i]已经改变了</span></span><br><span class="line">                <span class="comment">// int temp = nums[i];</span></span><br><span class="line">                <span class="comment">// nums[i] = nums[nums[i] - 1];</span></span><br><span class="line">                <span class="comment">// nums[nums[i] - 1] = temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="字典树Tire题集"><a href="#字典树Tire题集" class="headerlink" title="字典树Tire题集"></a>字典树Tire题集</h4><p><a href="https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii">LeetCode3045</a></p><p>​讲一下这道题使用字典树的做法，首先介绍一下什么是字典树。字典树是一种处理字符串的数据结构，通常用于快速统计某些字符串出现的次数，比如：给定一个字符串数组[a,a,c,abc,ab],以下就是该字符串数组形成的字典树。</p><img src="../images/算法--字典树/image-20240219161255454.png" style="zoom:50%;" /><p>​这棵树可以表示以字符串a出现了2次，ab出现了1次，abc出现了1次，c出现了1次</p><p>​这道题的特别之处在于，不仅要求我们匹配前缀还要匹配后缀。比如ab虽然是abc的前缀但不是它的后缀，因此不符合题意。这里灵神提供的一种思路是将前缀和后缀综合考虑，比如字符串abcde、abcdesabcde，将它们的前后缀综合考虑变为{(a,e),(b,d),(c,c),(d,b),(e,a)},{(a,e),(b,d),(c,c),(d,b),(e,a),(s,s),…},可以发现经过这样转化后，只需判断前者是否是后者的前缀即可判定，<strong>某个字符串是否既是另一个字符串的前缀，又是另一个字符串的后缀，而这样就可以直接使用字典树解决</strong>。为了进一步简化，我们可以将这个键值对映射为一个数字。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countPrefixSuffixPairs</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="type">char</span> s[] = words[i].toCharArray();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;<span class="comment">//每次都需要从根节点开始遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length; j ++)&#123;</span><br><span class="line">                <span class="comment">//将键值对映射为一个数字，一种简单的哈希</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">pair</span> <span class="operator">=</span> (s[j] - <span class="string">&#x27;a&#x27;</span>) &lt;&lt; <span class="number">5</span> | (s[s.length - <span class="number">1</span> - j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                cur = cur.son.computeIfAbsent(pair,k -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                res += cur.cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    Map&lt;Integer,Node&gt;son = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E6%A0%88/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="栈题集"><a href="#栈题集" class="headerlink" title="栈题集"></a>栈题集</h4><ul><li><p>栈是一种特殊的数据结构，具有先进后出的特点。可以把栈想象成一个桶，当从桶中取出物品时，先放入的物品会后取出，并且只有将上面的物品取出后，处于桶下面的物品才能取出。</p></li><li><p>在java中也提供了这种数据结构，位于java.util包下，名称为Stack。以下是有关Stack的一些常用操作</p></li><li><pre><code class="java">//初始化Stack&lt;Integer&gt;stack = new Stack&lt;&gt;();//向栈中存放数据stack.push(1);//取出栈顶元素int x = stack.pop();//查看栈顶元素int top = stack.peek();//移除栈中对应的元素stack.remove(1);//查看栈是否为空stack.isEmpty();//返回栈的大小stack.size();//翻转栈Collections.reverse(stack);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[LeetCode155](https://leetcode.cn/problems/min-stack)</span><br><span class="line"></span><br><span class="line">​本题要求实现一个最小栈，与普通栈相比，多了一个返回栈中最小值的功能(要求时间复杂度为常数级别)。我一开始的思路是打算用优先队列来做的，但不知道为什么过不了。以上问题已解决，主要是在定义优先队列的排序规则时使用了减法导致数据溢出，代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class MinStack &#123;</span><br><span class="line">    private Stack&lt;Data&gt; stack;</span><br><span class="line">    private int index;</span><br><span class="line">    private PriorityQueue&lt;Data&gt;heap;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        stack = new Stack&lt;&gt;();</span><br><span class="line">        heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Data&gt;()&#123;</span><br><span class="line">            public int compare(Data a,Data b)&#123;</span><br><span class="line">                return a.getData() - b.getData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        index = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int val) &#123;</span><br><span class="line">        Data data = new Data(val,index++);</span><br><span class="line">        stack.push(data);</span><br><span class="line">        heap.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        Data data = stack.pop();</span><br><span class="line">        heap.remove(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack.peek().getData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        return heap.peek().getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//设计这个类来避免优先队列remove时将所有的数字都移除，比如heap中有1，2，2，这时执行heap.remove(2),就会将所有2移除，而我们只是想要移除其中一个2.</span><br><span class="line">class Data&#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private int ord;</span><br><span class="line"></span><br><span class="line">    public Data()&#123;&#125;;</span><br><span class="line">    public Data(int data,int ord)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.ord = ord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData()&#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>以下是看了题解后的写法，题解的做法是使用辅助栈。因为由于栈具有先进后出的特点，只要上面的数不被弹出，那么下面的数就一定还在栈中，因此可以使用一个辅助栈来记录每个状态下，栈的最小值，相当于维护一个前缀最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;tempStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        tempStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span>(tempStack.isEmpty())&#123;</span><br><span class="line">            tempStack.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> tempStack.peek();</span><br><span class="line">            <span class="keyword">if</span>(top &gt; val)tempStack.push(val);</span><br><span class="line">            <span class="keyword">else</span> tempStack.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        tempStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(dfs)/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(dfs)/</url>
      
        <content type="html"><![CDATA[<h4 id="深度优先遍历-dfs"><a href="#深度优先遍历-dfs" class="headerlink" title="深度优先遍历(dfs)"></a>深度优先遍历(dfs)</h4><h5 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h5><p><a href="https://leetcode.cn/problems/generate-parentheses">LeetCode22</a></p><p>​本题要求生成给定数量的”()”，问有多少种生成方案。比如：要求生成3对括号，那么生成结果可以是”()()()”、”((()))”、”(()())”。</p><p>​解决本题的关键在于需要保证在生成”)”时，在此之前至少有一个未被配对的”(“。因此我dfs的主要参数有已使用的”(“数量，未被配对的”(“数量。接下来在生成”(“时只需保证”(“的数量还未使用完；生成”)”时只需保证在此之前至少有一个未被配对的”(“。</p><p>​实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt;res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftNum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span> s[] = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span> * n];</span><br><span class="line">        leftNum = n;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> leNum,<span class="type">int</span> noCoupleNum,<span class="type">char</span> s[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">2</span> * leftNum)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(s);</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//保证&quot;(&quot;的数量还未使用完</span></span><br><span class="line">        <span class="keyword">if</span>(leNum &lt; leftNum)&#123;</span><br><span class="line">            s[u] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>,leNum + <span class="number">1</span>,noCoupleNum + <span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在此之前至少有一个未被配对的&quot;(&quot;</span></span><br><span class="line">        <span class="keyword">if</span>(noCoupleNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s[u] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>,leNum,noCoupleNum - <span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/palindrome-partitioning">LeetCode131</a></p><p>​本题要求对给定字符串进行分割，使得每个子串都是回文串。</p><p>​解决方法就是直接枚举每个子串是否是回文串。模拟样例：s&#x3D;”aab”.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>,j = i = <span class="number">0</span>,子串为<span class="string">&quot;a&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">i = <span class="number">1</span>,j = i = <span class="number">1</span>,子串为<span class="string">&quot;a&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">i = <span class="number">2</span>,j = i = <span class="number">2</span>,子串为<span class="string">&quot;b&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">i = <span class="number">3</span> = s.length(),将path加入res中,回溯,path=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">         i = <span class="number">2</span>,j = <span class="number">3</span> &gt; s.length() - <span class="number">1</span>,回溯,path=&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    i = <span class="number">1</span>,j = <span class="number">2</span>,子串为<span class="string">&quot;ab&quot;</span>不是回文串</span><br><span class="line">    i = <span class="number">1</span>,j = <span class="number">3</span> = s.length() - <span class="number">1</span>,回溯,path=&#123;&#125;</span><br><span class="line">i = <span class="number">0</span>,j = <span class="number">1</span>,子串为<span class="string">&quot;aa&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;aa&quot;</span>&#125;</span><br><span class="line">i = <span class="number">2</span>,j = i = <span class="number">2</span>,子串为<span class="string">&quot;b&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">i = <span class="number">3</span> = s.length(),将path加入res中,回溯,path=&#123;<span class="string">&quot;aa&quot;</span>&#125;</span><br><span class="line">i = <span class="number">2</span>,j = <span class="number">3</span> &gt; s.length() - <span class="number">1</span>,回溯,path=&#123;&#125;</span><br><span class="line">i = <span class="number">0</span>,j = <span class="number">2</span>,子串为<span class="string">&quot;aab&quot;</span>不是回文串</span><br><span class="line">i = <span class="number">0</span>,j = <span class="number">3</span> &gt; s.length() - <span class="number">1</span>,至此,递归结束</span><br></pre></td></tr></table></figure><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt;res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt;path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,s,path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判定是否为回文串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,String s)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left++) != s.charAt(right--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,String s,List&lt;String&gt;path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(i,j,s))&#123;</span><br><span class="line">                path.add(s.substring(i,j + <span class="number">1</span>));</span><br><span class="line">                dfs(j + <span class="number">1</span>,s,path);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉树题集"><a href="#二叉树题集" class="headerlink" title="二叉树题集"></a>二叉树题集</h4><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">Leetcode105</a></p><p>这道题要求我们根据二叉树的前序遍历和中序遍历还原这棵二叉树。这是一个定理：只要给定一棵树的前序遍历和中序遍历或者后序遍历和中序遍历，我们就能够唯一构造出这棵树。需要注意的是如果只给定前序遍历和后续遍历，虽然也能构造出一棵树，但不唯一。</p><p>其原理为：由于前序遍历的特点为先遍历根节点，再遍历左儿子，最后遍历右儿子。因此通过前序遍历&#x2F;后序遍历可以知道根节点(整棵树的根节点以及子树的根节点)，再通过中序遍历可以知道根节点的左子树和右子树。这样我们就能够唯一确定这棵树。比如给定某棵树的前序遍历集合为[3,4,5,7,9,10],再给定其中序遍历集合为[4,5,3,7,10,9].</p><p>首先，通过前序遍历集合可以知道3是根节点，再定位到中序遍历集合中，4、5是它的左子树；7、10、9是它的右子树。因为前序遍历集合中4在5前，因此4才是3的左儿子；7在10和9前，因此它是3的右儿子。这样不断重复操作，最终还原这棵二叉树</p><img src="../images/算法--二叉树/image-20240217153009329.png" style="zoom:50%;" /><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt;indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="comment">//思路：从preorder中取出根节点，再在inorder中找到该节点的位置，该位置左边的</span></span><br><span class="line">        <span class="comment">//节点为根节点的左子树，右边的节点为根节点的右子树。如此不断递归</span></span><br><span class="line">        n = preorder.length;</span><br><span class="line">        <span class="comment">//更快定位某节点在中序遍历集合中的位置，用哈希表记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            indexMap.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> dfs(preorder,inorder,<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> preorder[],<span class="type">int</span> inorder[],<span class="type">int</span> preorder_left,<span class="type">int</span> preorder_right,<span class="type">int</span> inorder_left,<span class="type">int</span> inorder_right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_left &gt; preorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preorder_left];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndexInorder</span> <span class="operator">=</span> indexMap.get(rootVal);<span class="comment">//根节点在中序遍历集合中的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size_left</span> <span class="operator">=</span> rootIndexInorder - inorder_left;<span class="comment">//左子树的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size_right</span> <span class="operator">=</span> inorder_right - rootIndexInorder;<span class="comment">//右子树的大小</span></span><br><span class="line">        root.left = dfs(preorder,inorder,preorder_left + <span class="number">1</span>,preorder_left + size_left,inorder_left,rootIndexInorder - <span class="number">1</span>);</span><br><span class="line">        root.right = dfs(preorder,inorder,preorder_left + <span class="number">1</span> + size_left,preorder_right,rootIndexInorder + <span class="number">1</span>,inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定的是后序遍历集合和中序遍历集合，那么根节点是post_right,且由于后续遍历的规则为“左右根”，我们需要通过右子树的大小确定左右子树中的元素。</p><p>题目见<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">LeetCode106</a></p><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt;postorderIndexOfInorder;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> postorder.length;</span><br><span class="line">        postorderIndexOfInorder = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            postorderIndexOfInorder.put(inorder[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dfs(postorder,inorder,<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> postorder[],<span class="type">int</span> inorder[],<span class="type">int</span> postorder_left,<span class="type">int</span> postorder_right,<span class="type">int</span> inorder_left,<span class="type">int</span> inorder_right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder_left &gt; postorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postorder_right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> postorderIndexOfInorder.get(rootVal);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size_left</span> <span class="operator">=</span> index - inorder_left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size_right</span> <span class="operator">=</span> inorder_right - index;</span><br><span class="line">        root.right = dfs(postorder,inorder,postorder_right-size_right,postorder_right-<span class="number">1</span>,index+<span class="number">1</span>,inorder_right);<span class="comment">//构建右子树</span></span><br><span class="line">        root.left = dfs(postorder,inorder,postorder_left,postorder_right-<span class="number">1</span>-size_right,inorder_left,index-<span class="number">1</span>);<span class="comment">//构建左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/path-sum-iii">LeetCode437</a></p><p>​这道题给定一个目标值，要求我们求出给定二叉树路径和为目标值的路径数量。需要注意的是，这里的路径并不是指从根节点到叶子节点，而是任意一个及以上节点形成且只能由父节点指向子节点的路径。比如：</p><img src="../images/算法--二叉树/image-20240217153009329.png" style="zoom:50%;" /><p>在这棵树中：3是一条路径，3-&gt;4是一条路径，4-&gt;5是一条路径，但是4-&gt;3-&gt;7不是路径。</p><p>​其解决方案是利用前缀和的思想，两个节点的前缀和之差就是这两个节点之间的路径和。但仅依靠前缀和还比较麻烦，因为我们需要枚举这两个节点，需要维护两个自由度。但是这道题规定了路径只能由父节点指向子节点，可以转化为给定一个数组和一个目标值，0 &lt; i &lt; j &lt; n，求满足arr[i] + arr[j] &#x3D; target的索引对的数量，比较暴力的做法是两重循环枚举，但更巧妙的做法是用一个哈希表记录这些数出现的数量，这样只需遍历一次。</p><p>​由于规定了路径只能由父节点指向子节点，因此当遍历完当前节点后，需要执行恢复操作。比如以上述二叉树为例，当遍历完节点4后，接着会遍历节点7，为了消除节点4的影响，必须从哈希表中减去它的前缀和。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long,Integer&gt;prefixSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        prefixSum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSum.put(<span class="number">0L</span>,<span class="number">1</span>);<span class="comment">//根节点的前缀和</span></span><br><span class="line">        dfs(root,targetSum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum,<span class="type">long</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (<span class="type">long</span>)root.val;<span class="comment">//前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> prefixSum.getOrDefault(sum - targetSum,<span class="number">0</span>);<span class="comment">//另一个满足要求的节点数量，因为当前节点的前缀和为sum，目标值为target，需要满足要求sum - sum2 = target =&gt; sum2 = sum - target</span></span><br><span class="line">        ans += cnt;<span class="comment">//更新答案</span></span><br><span class="line">        cnt = prefixSum.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(sum,++cnt);<span class="comment">//更新哈希表</span></span><br><span class="line">        dfs(root.left,targetSum,sum);</span><br><span class="line">        dfs(root.right,targetSum,sum);</span><br><span class="line">        cnt = prefixSum.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(sum,--cnt);<span class="comment">//恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree">LeetCode2476</a></p><p>​给定一棵二叉搜索树，所谓二叉搜索树是一棵特殊的二叉树，需要满足以下条件：</p><p>root.val &gt; root.left.val; root.val &lt; root.right.val.再给定对于一个数，要求在这棵树中找到大于等于这个数的最小值max以及小于等于这个数的最大值min。我的思路就是直接根据搜索二叉树的性质直接遍历两次二叉树，分别找到max和min。在一般情况下，其时间复杂度为log(n),是可以通过的，但是本题有一个特殊样例，该二叉树是一条链，其时间复杂度为O(n),会超时。</p><p>​提到搜索二叉树，一定要想到中序遍历。因为搜索二叉树经过中序遍历得到的结果是一个严格递增的序列，这往往是一个突破口。而一般看到题中求解最大值最小，最小值最大，一般可以使用二分进行求解。二分有两种模板，向左寻找的模板可以得到第一个大于等于目标值的数(还有一种特殊情况，整个数组中的数都小于目标值)；向右寻找的模板可以得到第一个小于等于目标值的数(还有一种特殊情况，整个数组中的数都大于目标值)。而这两个数分别对应大于等于目标值的最小值和小于等于目标值的最大值。而二分的时间复杂度是确定的log(n),最后一个样例也能通过。</p><hr><p><a href="https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree">LeetCode2673</a></p><p>​要使得所有叶子节点到根节点的路径和相等，不妨先考虑让互为兄弟的叶子节点到根节点的路径和相等需要的最少操作数。因为这两个叶子节点是兄弟节点，所以它们到根节点之间的cost都一样，因此只需要保证这两个叶子节点的cost一样即可，达到这个目的的最小操作数就是让cost等于它们中较大的那个数。接着使用同样的思路考虑其父节点。</p><p>例如：</p><img src="../images/算法--二叉树/image-20240228115017594.png" style="zoom:50%;" /><p>从最后一个非叶子节点开始枚举(<strong>对于一棵满二叉树，节点个数&#x2F;2为最后一个非叶子节点的编号</strong>)。其左儿子cost为3，右儿子cost为4，因此让它们的cost等于较大的数4，cost[3] &#x3D; 5 + 4 &#x3D; 9.节点2的左儿子cost为2，右儿子cost为4，它们最终的cost为4，cost[2] &#x3D; 4 + 4 &#x3D; 8.于是转化为求让这样一棵满二叉树所有叶子节点到根节点的路径和相等的最小操作数。</p><p>​<img src="../images/算法--二叉树/image-20240228115652973.png" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h4 id="动态规划题集"><a href="#动态规划题集" class="headerlink" title="动态规划题集"></a>动态规划题集</h4><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array">LeetCode2369</a></p><p>​本题的状态定义为dp[i + 1]表示下标0-i的子数组是否可以是有效划分，状态转移方案为</p><pre><code>      1. nums[i] == nums[i - 1],问题就转化为查看0-(i-2)的子数组是否是有效划分，根据状态定义就是dp[i - 1]      2. nums[i] == nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2],问题就转化为查看0-(i - 3)的子数组是否是有效划分，根据状态定义就是dp[i - 2]      3. nums[i] == nums[i - 1] + 1 &amp;&amp; nums[i - 1] == nums[i - 2] + 1,问题就转化为查看0-(i - 3)的子数组是否是有效划分，根据状态定义就是dp[i - 2]</code></pre><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//dp[i + 1]表示0-i的子数组是否为有效划分</span></span><br><span class="line">        <span class="type">boolean</span> dp[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] || i &gt; <span class="number">1</span> &amp;&amp; dp[i - <span class="number">2</span>] &amp;&amp; (</span><br><span class="line">                nums[i - <span class="number">2</span>] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] || </span><br><span class="line">                nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            ))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟样例：nums[4,4,4,5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">0</span>]:<span class="literal">true</span>;</span><br><span class="line">nums[i] == nums[i-<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">i = <span class="number">2</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">1</span>]:<span class="literal">false</span>;</span><br><span class="line">dp[i-<span class="number">2</span>]=dp[<span class="number">0</span>]:<span class="literal">true</span>;</span><br><span class="line">nums[i-<span class="number">2</span>]=nums[i-<span class="number">1</span>]=nums[i]=<span class="number">4</span>;</span><br><span class="line">dp[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">i = <span class="number">3</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="literal">true</span>,nums[i] != nums[i-<span class="number">1</span>];</span><br><span class="line">dp[i-<span class="number">2</span>]=dp[<span class="number">1</span>]:<span class="literal">false</span>;</span><br><span class="line">i = <span class="number">4</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">3</span>]=<span class="literal">true</span>,nums[i] != nums[i-<span class="number">1</span>];</span><br><span class="line">dp[i-<span class="number">2</span>]=dp[<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">4</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/longest-palindromic-substring">LeetCode5</a></p><p>​本题要我们求解给定字符串的最长回文子串，最暴力的做法就是遍历每个子串并判断是否为回文串，这种做法需要遍历两个自由度，并且判断子串是否为回文串也需要O(n)的时间复杂度，因此总的时间复杂度为O(n^3^)，会超时。</p><p>​一般遇到这种字符串的题目以及求解最大值最小值方案数，并且数据范围比较大的题，都需要通过动态规划来优化。但是很多人(包括我)都能想到是用动态规划解答，但是不知道如何定义状态，以及如何建立状态转移方程，因此只能干瞪眼，其实最佳做法就是直接去看题解，学习人家是如何定义状态的，以及状态是如何转移的，这样才是最高效的。只有刷了一定的题，有了经验后，或许下次遇到动态规划的题能够成功定义出状态以及建立状态转移方程。</p><p>​言归正传，看了人家的题解后，人家定义的状态是dp[i] [j]：表示[i,j]这个子串是否是回文串(我当时定义的状态是dp[i]：表示[0,i]这个子串是否是回文串，显然是有问题的，因为我这种定义将一个子串的头定死在了开头，这只是所有子串的一部分)。而[i,j]这个子串是否为回文串，可以由[i+1,j-1]这个子串推出，因为如果[i+1，j-1]这个子串是回文串的话，那么只需要保证s[i]&#x3D;&#x3D;s[j]就可以判断[i,j]这个子串是否为回文串。(在构建转移方程时，往往将前一个状态作为切入点，经常可以见到dp[i] &#x3D; dp[i - 1] + …，这也是动态规划比较快的原因：利用了之前求得的数据)。</p><p>dp[i,j] &#x3D; dp[i+1,j-1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]</p><p>​这里有两个特殊点需要特判，当子串长度为1和2时，比如[1,1],[1,2]。如果按照上述转移方程，需要判断dp[2] [0]和dp[2] [1],由于我们的状态定义需要保证i &lt; j，因此这两个状态不会更新，将会导致所有长度为1，2的子串的dp值都是false，这显然是不对的。因此最终的状态转移方程：</p><p>dp[i,j] &#x3D; true, i &#x3D;&#x3D; j；</p><p>dp[i,j] &#x3D; s[i] &#x3D;&#x3D; s[j],j &#x3D;&#x3D; i + 1;</p><p>dp[i,j] &#x3D;&#x3D; dp[i+1,j-1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= n; len ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; n; start ++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(end &gt;= n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[start][end] = (len == <span class="number">1</span> || len == <span class="number">2</span> || dp[start + <span class="number">1</span>][end - <span class="number">1</span>]) &amp;&amp; (s.charAt(start) == s.charAt(end));</span><br><span class="line">                <span class="keyword">if</span>(dp[start][end] &amp;&amp; len &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = len;</span><br><span class="line">                    res = s.substring(start,end + <span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存击穿问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>问题：什么是缓存击穿？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180010990.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180531358.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180806453.png"></p><p>实现互斥锁及其设计细节</p><p>实现逻辑过期</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存雪崩问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>问题：什么是缓存雪崩？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/image-20240301175041871.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存穿透问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>问题：什么是缓存穿透？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/image-20240301172050600.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存更新问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>主要有以下三种缓存更新策略</p><ol><li>内存淘汰：这种策略主要是利用Redis的内存淘汰机制，即当Redis中内存已满时，如果这时又新的数据到来，那么Redis就会按照一定策略淘汰掉一部分数据，从而让新数据进入。常见的淘汰策略有先进先出，最近未被使用(LUR)，最少未被使用等。这种更新策略的优点是不需要维护，又Redis自己维护，缺点是几乎不能保证数据一致性，Redis中可能会同时存在旧数据和新数据。</li><li>超时剔除：这种策略需要我们在Redis存储数据时为其设置一个有效时间，时间一到数据自然剔除，当用户查询数据时，由于缓存中没有该数据，就会从数据库中查找，进而更新进缓存中。因此这种策略具有一定的数据一致性，但是一致性不高，因为如果数据在有效期内发生的变化，需要等到有效期后才会被存储进缓存中，在此期间取出的数据都是旧数据。</li><li>主动更新：当我们修改数据库中的数据时，需要手动的去更新缓存中的数据。具有较好的数据一致性，但是维护成本大。</li></ol><p>需要根据不同业务场景来选择不同的更新策略，低一致性业务可以考虑内存淘汰，因为不需要维护；高一致性业务考虑主动更新。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/image-20240229211619395.png"></p><p>主要有以下三种主动更新方案</p><ol><li>Cache Aside调用者在更新数据库时更新缓存</li><li>Read&#x2F;Write Through缓存和数据库集成为一个服务，服务保证两者一致性，对外提供接口</li><li>调用者只操作缓存，使用一个独立的异步线程每间隔一段时间更新一次数据库</li></ol><p>为什么选择方案1？</p><p>操作缓存和数据库时需要考虑的3个问题</p><ol><li><p>删除缓存还是更新缓存？为什么？</p><p>删除缓存。因为删除缓存可以和更新缓存达到相同的目的，但是性能更好。如果选择更新缓存，意味着当我们更新数据库中的数据时，顺便更新缓存中的数据。而如果选择删除缓存，意味着更新数据库中的数据时，删除缓存中对应的数据，当用户查询该数据时，由于缓存中没有，因此会向数据库中查询，也能得到正确的数据，这样做的好处在于，只有当用户请求对应数据时才会向缓存中存入，节省了内存。</p></li><li><p>如何保证缓存和数据库的操作同时成功或失败？</p><p>通过事务保证删除缓存和更新数据库两个操作的原子性，在分布式系统中需要通过另一种技术实现</p></li><li><p>先操作缓存还是数据库？</p><p>如果选择先删除缓存，由于更新数据库的时间比较长，如果此时来了大量请求，会给数据库造成极大压力；</p></li></ol><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/image-20240229213623162-17096998984914.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目使用缓存进行商户查询</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="使用缓存进行商户查询"><a href="#使用缓存进行商户查询" class="headerlink" title="使用缓存进行商户查询"></a>使用缓存进行商户查询</h4><p><strong>问题：为什么要使用缓存？常见的缓存有哪些？</strong></p><p>​使用缓存能够减少向数据库的查询次数，从而提高性能，缓解数据库压力。常见的缓存技术有连接池、线程池、常量池等。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229192530778.png"></p><img src="../images/Redis--黑马点评项目使用缓存查询商户信息/image-20240229192805575.png" style="zoom:50%;" /><p>以下是查询商户列表使用缓存前后消耗的时间，可以发现，使用缓存后，查询时间从1.52秒提示到了158毫秒，性能得到了极大的提升。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229203438458.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229203525250-17096995639353.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目集群session共享问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="集群session共享问题及解决方案"><a href="#集群session共享问题及解决方案" class="headerlink" title="集群session共享问题及解决方案"></a>集群session共享问题及解决方案</h4><p><strong>问题：之前的设计方案是什么？有什么问题？解决方案是什么？为什么使用这种解决方案(Redis)？</strong></p><p>​当前我们的系统结构作为单体项目是可以的，但是一旦用户量比较大，想要转化为集群项目，这种架构就不行了。主要原因是，当前系统中，我们是基于session来进行数据共享的，但session中的数据只能在同一个服务器中进行共享，如果我们想要扩展为集群项目，使用session就无法做到多个服务器之间数据的共享。因此，必须使用另一种工具作为数据共享。而Redis能够很好的胜任这一要求。</p><p>​1. Redis本身是一个数据库，而数据库本身就是用于存储数据以便进行数据共享的；2. Redis的数据是存放在内存中的，读取速率快，性能好；3. Redis支持各种数据类型，能够很好的满足各种数据的存储。</p><p><strong>验证码存储进Redis以什么作为Key，Value选择什么数据类型？</strong></p><p>​以手机号作为key，value选择String类型即可，为了减少内存消耗，一般会给验证码存储进Redis时设置一个有效期。</p><p>用户信息存储进Redis以什么作为Key，Key的选择需要满足什么条件(唯一，易携带)？为什么不用手机号作为Key？Value选择什么数据类型，为什么选择这种数据类型？</p><p>​key需要具备唯一性以及请求时方便携带的特点。一般使用一个随机化字符串token作为key，如果使用手机号作为key会暴露用户信息，value选择hash类型，hash结构可以将对象中每个字段但独立存储，可以针对单个字段做CRUD</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/image-20240228204035007.png"></p><p><strong>什么是token，它和cookie和session有什么区别？</strong></p><p>​session顾名思义，就是指一种会话技术，由于HTTP协议是无状态协议，当客户端和服务器端建立连接后，它们之间的状态就会断开。这种特点为鉴别用户是否是同一个造成了困难，为了解决该问题，就提供了session机制。当客户端向服务器发送请求时，如果该客户是第一次发送请求，服务器会创建一个session对象用于表示两者建立连接的状态，并生成一个sessionid，sessionid会随着响应报文发送给客户端。客户端收到后会将其存放在cookie中，下一次请求时，请求路径会携带cookie，服务器收到后根据cookie找到对应的session，找到两者的连接。token也是用于鉴权的，它的作用就相当于sessionid，只不过它一般是按照某种加密方式生成的一个字符串，使用token相对于cookie来说更加安全方便，相对于session来说消耗的内存更小，因此现在项目中一般使用token作为鉴权令牌使用。</p><p><strong>如何定期更新Redis中存储的用户信息(用户活跃时不断更新Redis)？以及对其进行优化</strong></p><p>​为了减少内存消耗，一般会给存储进Redis中的数据设置一个有效期，有效期一到，Redis就会自动清除数据。这就会引发一个问题，有时候你用着用着就自动退出登录了。这是我们需要解决的问题，常见的解决方案是，当用户在页面上活跃时，就定期去更新这个有效期。做法就是，再设置一个拦截器，一个拦截器用于更新token有效期，另一个用于鉴权登录。</p><p>​</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/image-20240229172514521.png"></p><p><strong>设置拦截器的执行顺序？</strong></p><p>​需要保证更新token有效期的拦截器先执行，可以通过设置拦截器的order属性来规定拦截器的执行顺序，order值越小，优先级越高。</p><p>​拦截器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.RefreshInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserLoginInteceptorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInteceptorHandler</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">//放行请求，这些请求不做拦截</span></span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher-order/**&quot;</span></span><br><span class="line">                        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拦截器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//token为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看redis中是否有用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="keyword">if</span>(entries.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将map转化为UserDTO类型</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//更新Redis数据</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目初始化</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="开发短信验证登录功能"><a href="#开发短信验证登录功能" class="headerlink" title="开发短信验证登录功能"></a>开发短信验证登录功能</h4><p>开发流程：</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240227194335725.png"></p><h5 id="发送短信模块"><a href="#发送短信模块" class="headerlink" title="发送短信模块"></a>发送短信模块</h5><p>​当点击我的之后会弹出登录页面，要求输入手机号获取验证码，当输入手机号点击发送验证码后，通过抓包发现浏览器会发送如下报文</p><img src="../images/Redis--黑马点评项目初始化/image-20240227195645100.png" alt="image-20240227195645100" style="zoom:50%;" /><p>可以看到，浏览器会以post方式向服务器发送请求，并携带请求参数：phone&#x3D;xxx。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//校验手机号是否合法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">phoneInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">        <span class="comment">//如果不合法</span></span><br><span class="line">        <span class="keyword">if</span>(phoneInvalid)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不合法,请重新输入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果合法，则生成验证码(一个六位数随机数),并保存在session中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">//m</span></span><br><span class="line">        log.debug(<span class="string">&quot;成功发送验证码：&quot;</span> + code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginFormDTO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginFormDTO,HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//验证手机号是否正确</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginFormDTO.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证码是否一致</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginFormDTO.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cachecode</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(code == <span class="literal">null</span> || !cachecode.equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据库中是否有该用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">        <span class="comment">//保存用户</span></span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户保存到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验登录"><a href="#校验登录" class="headerlink" title="校验登录"></a>校验登录</h5><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228195552226.png"></p><p>问题：拦截器和过滤器有什么区别？拦截器的作用是什么？为什么要使用ThreadLocal？详细介绍一下ThreadLocal？</p><p>​拦截器是SpringMVC中提供的类，也是用于拦截请求，和过滤器不同的是，它拦截的是DispatcherServlet和控制器方法之间的请求。而过滤器拦截的是用户和Servlet间的请求。而且过滤器是基于Servlet的，它只能用于web程序，而拦截器是Spring的组件，由Spring控制，不仅能用于web程序，还能用于其他程序。</p><p>​拦截器是基于java反射机制(动态代理实现的)，而过滤器是基于回调函数(doFilter方法)实现的，当一个过滤器执行完后，会调用doFilter方法返回执行上一级Filter</p><p>​鉴于两者都能够拦截请求，因此常被用来作为鉴权登录模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-02-28</span></span><br><span class="line"><span class="comment"> * 校验用户登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginInteceptorHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//查看session中是否有用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//进行拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);<span class="comment">//401表示未得到授权</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserLoginInteceptorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInteceptorHandler</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">//放行请求，这些请求不做拦截</span></span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher-order/**&quot;</span></span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何保护用户敏感信息"><a href="#如何保护用户敏感信息" class="headerlink" title="如何保护用户敏感信息"></a>如何保护用户敏感信息</h5><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228201228430.png"></p><p>​从图中可以看出，当前系统中，当我们登录时，会将用户的一些敏感信息暴露在浏览器中，这非常危险。因此我们需要解决该问题，那么常用的解决方案就是，定义两个用户实体，一个是数据库用户实体，另一个是返回给浏览器的用户实体，后者相对于前者缺少了用户的敏感信息，更加安全，如下图所示。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228202022415-17096985435601.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo结合主题Matery构建绝美博客</title>
      <link href="/2024/03/06/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/06/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>​之前那个主题既不美观也不好用，我就上网搜了搜hexo的主题，发现了matery这个主题。最吸引我的其实不是它绚丽的色彩，而是它可以搜索文章以及热点图的功能，于是我赶紧搜索了一下如何下载该主题。</p><p>​首先点击以下链接访问位于github上的matery主题项目，根据readme文档操作，需要注意的是在复制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>类似以上形式的内容时，在Typora中如果出现了以下情形，需要将多余的”—“删除</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305184436062.png"></p><p>我当时就是没有删除，导致每次我执行hexo s时都会报以下错误</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305184845222.png"></p><p>解决了以上问题后，我又有一个新问题：如何给我的文章分类，这个也很简单(然而当时却花了我不少时间)。按照readme文档的提示，我们在创建文章时，只要在顶部按照格式写上它的信息即可，比如</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305185152689.png"></p><p>就表示这篇文章名称为：hexo结合主题Matery构建绝美博客</p><p>发表日期为：2024-03-05</p><p>作者为：dch</p><p>位于hexo这个类别下</p><p>标签是hexo和matery</p><p>最后附上搭建好的图片</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305185437028.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--8.手写简易版Mybatis框架</title>
      <link href="/2023/11/22/Mybatis%E5%AD%A6%E4%B9%A0--8.%E6%89%8B%E5%86%99Mybatis%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/11/22/Mybatis%E5%AD%A6%E4%B9%A0--8.%E6%89%8B%E5%86%99Mybatis%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="手写Mybatis框架"><a href="#手写Mybatis框架" class="headerlink" title="手写Mybatis框架"></a>手写Mybatis框架</h4><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>创建maven项目，引入相关依赖，打包方式改为jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>创建Resources工具类，获得核心配置文件。再创建SqlSessionFactoryBuilder类和SqlSessionFactory类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具类，用于获取一个InputStream输入流</span></span><br><span class="line"><span class="comment"> * 从类路径下加载资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    <span class="comment">//工具类的方法一般都是静态的，也就是说不用实例化对象就能调用方法</span></span><br><span class="line">    <span class="comment">//为了避免new对象，将工具类私有化，这是一种习惯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Resources</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource 类路径下的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title function_">getResource</span><span class="params">(String resource)</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(resource);</span><br><span class="line">        <span class="keyword">return</span> resourceAsStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>设计SqlSessionFactoryBuilder和SqlSessionFactory类。</p><ol><li>通过build方法创建SqlSessionFactory对象，所以SqlSessionFactoryBuilder中有一个build方法。</li><li>build方法中肯定有参数，这些参数需要用来初始化SqlSessionFactory对象</li><li>思考SqlSessionFactory中会有哪些属性。通过观察核心配置文件可知(一个environment对应一个SqlSessionFactory对象)，SqlSessionFactory中应该有事务管理属性、数据源属性以及sqlMapper属性。其中前两个属性都可以封装为一个对象，最后一个属性其实对应的就是mapper标签(用于关联sqlMapper.xml文件的)。mapper标签可能有多个，而且mapper.xml文件中的sql语句也会有多条，用对象来维护不可行。解决方案：使用map集合来维护，key值存放sqlId，value存放一个sqlMapperStatement对象(封装了sql语句以及其他属性)</li><li>因此，在SqlSessionFactory类中应该有3个属性：1. 事务管理器对象 2. 数据源对象 3. map集合</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.deng.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../../../%E7%AC%94%E8%AE%B0/MyBatis/8.%E6%89%8B%E5%86%99Mybatis%E6%A1%86%E6%9E%B6.assets/image-20231123102458089.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSessionFactoryBuilder</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析核心配置文件创建SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource 核心配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream resource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactory</span>();</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个SqlSessionFactory对应一个数据库</span></span><br><span class="line"><span class="comment"> * 通过SqlSessionFactory可以创建一个或多个SqlSession对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line">    <span class="comment">//事务管理器属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据源属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//mapper</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,SqlMapperStatement&gt; mapperStatements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个pojo类，包含sql语句以及一个resultType属性(简化了，实际上还有其他属性)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlMapperStatement</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String sqlId;</span><br><span class="line">    <span class="keyword">private</span> String resultType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlMapperStatement</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlMapperStatement</span><span class="params">(String sqlId,String resultType)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlId = sqlId;</span><br><span class="line">        <span class="built_in">this</span>.resultType = resultType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSqlId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlId</span><span class="params">(String sqlId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlId = sqlId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResultType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResultType</span><span class="params">(String resultType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resultType = resultType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sqlId=&quot;</span> + sqlId + <span class="string">&quot; resultType=&quot;</span> + resultType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><p>抽取(设计)事务管理器属性。</p><p>我们知道在mybatis中有两种事务状态：JDBC和MANAGED。因此不能直接在SqlSessionFactory中写死或者采用都写上的方法(太不美观)。可以使用多态的方法，定义一个父接口transcation，让这两个类都去实现该接口，根据用户的参数动态绑定相关类和方法。在父接口中提供管理事务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务管理接口，其他事务类都要实现该接口</span></span><br><span class="line"><span class="comment"> * 在该接口中定义事务管理的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h5><p>进一步思考：如何管理事务？需要通过connection对象，也就是说我们需要在事务管理器中获得connection对象。我们很快就想到了数据源，因为它的定义就是提供connection对象的都可以称为数据源。那么进一步思考，既然在事务管理器中有数据源对象，那么SqlSessionFactory中还有必要有数据源属性吗？当然没必要，因为其可以通过Transaction对象获取数据源。</p><p>进一步思考：如何设计数据源对象？由于数据源也有3个属性：POOLED、UNPOOLED和JNDI。因此也可以采用多态的方式，定义一个父接口。并且在jdk中已经定义了一个数据源接口：javax.sql.DataSource,任何数据源对象都要实现该接口，这是一个规范。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLFeatureNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示不使用数据库连接池，每次获得的connection对象都是新创建的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnPooledDataSource</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.sql.DataSource&#123;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnPooledDataSource</span><span class="params">(String driver,String url,String username,String password)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLoginTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PrintWriter <span class="title function_">getLogWriter</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginTimeout</span><span class="params">(<span class="type">int</span> seconds)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogWriter</span><span class="params">(PrintWriter out)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTransaction</span> <span class="keyword">implements</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="comment">//设置自动提交的标志，true表示自动提交，false表示不自动提交</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> autoCommit;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h5><p>完成SqlSessionFactoryBuilder的编写，测试能否成功创建SqlSessionFactory对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.god.ibatis.utils.Resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSessionFactoryBuilder</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析核心配置文件创建SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource 核心配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream resource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Map&lt;String,SqlMapperStatement&gt;map = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//存放sqlMapper.xml文件的路径</span></span><br><span class="line">        List&lt;String&gt;sqlMapperXmlPath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析核心配置文件</span></span><br><span class="line">            <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(resource);</span><br><span class="line">            <span class="comment">//获得根标签</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">configuration</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">            <span class="comment">//获得environments标签</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">environments</span> <span class="operator">=</span> configuration.element(<span class="string">&quot;environments&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">aDefault</span> <span class="operator">=</span> environments.attributeValue(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">            <span class="comment">//environment[@id=&#x27;&quot;+Default+&quot;&#x27;];</span></span><br><span class="line">            <span class="comment">//Element environment = environments.element(&quot;environment[@id=&#x27;&quot; + aDefault + &quot;&#x27;]&quot;);</span></span><br><span class="line">            List&lt;Element&gt; environmentlist = environments.elements(<span class="string">&quot;environment&quot;</span>);</span><br><span class="line">            <span class="type">Element</span> <span class="variable">transactionElm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">dataSourceElm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//根据default属性获取对应的environment标签</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; environmentlist.size(); i ++)&#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> environmentlist.get(i);</span><br><span class="line">                <span class="keyword">if</span>(e.attributeValue(<span class="string">&quot;id&quot;</span>).equals(aDefault))&#123;</span><br><span class="line">                    transactionElm = e.element(<span class="string">&quot;transactionManager&quot;</span>);</span><br><span class="line">                    dataSourceElm = e.element(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">mappers</span> <span class="operator">=</span> configuration.element(<span class="string">&quot;mappers&quot;</span>);</span><br><span class="line">            List&lt;Element&gt; mapper = mappers.elements(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">            mapper.forEach(mappert -&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> mappert.attributeValue(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">                sqlMapperXmlPath.add(s);</span><br><span class="line">            &#125;);</span><br><span class="line">            dataSource = getDataSource(dataSourceElm);</span><br><span class="line">            transaction = getTransaction(transactionElm,dataSource);</span><br><span class="line">            map = getMap(sqlMapperXmlPath);</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactory</span>(transaction,map);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个事务管理器对象，作为sqlSessionFactory的属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transactionElm 核心配置文件中的数据源标签</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源对象作为其属性之一</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个事务管理器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Transaction <span class="title function_">getTransaction</span><span class="params">(Element transactionElm,DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> transactionElm.attributeValue(<span class="string">&quot;type&quot;</span>).trim().toUpperCase();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constant.JDBC_TRANSACTION.equals(type)) &#123;</span><br><span class="line">            transaction = <span class="keyword">new</span> <span class="title class_">JdbcTransaction</span>(dataSource,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(constant.MANAGED_TRANSACTION.equals(type))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> transaction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析核心配置文件，返回一个数据源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSourceElm 核心配置文件中的数据源标签</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回数据源对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">(Element dataSourceElm)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> dataSourceElm.attributeValue(<span class="string">&quot;type&quot;</span>).trim().toUpperCase();</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;Element&gt; properties = dataSourceElm.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        properties.forEach(property -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> property.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> property.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            map.put(name,value);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (constant.POOLED_DATASOURCE.equals(type)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(constant.UNPOOLED_DATASOURCE.equals(type))&#123;</span><br><span class="line">            dataSource = <span class="keyword">new</span> <span class="title class_">UnPooledDataSource</span>(map.get(<span class="string">&quot;driver&quot;</span>),map.get(<span class="string">&quot;url&quot;</span>),map.get(<span class="string">&quot;username&quot;</span>),map.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(constant.JNDI_DATASOURCE.equals(type))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Map&lt;String,SqlMapperStatement&gt;集合作为SqlSessionFactory的属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sqlMapperXmlPath sqlMapper.xml文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个map集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,SqlMapperStatement&gt; <span class="title function_">getMap</span><span class="params">(List&lt;String&gt;sqlMapperXmlPath)</span>&#123;</span><br><span class="line">        Map&lt;String,SqlMapperStatement&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sqlMapperXmlPath.forEach(path -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//解析sqlMapper.xml文件</span></span><br><span class="line">                <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">                <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(Resources.getResource(path));</span><br><span class="line">                <span class="type">Element</span> <span class="variable">mapper</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> mapper.attributeValue(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">                List&lt;Element&gt; tags = mapper.elements();</span><br><span class="line">                tags.forEach(tag -&gt; &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> tag.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">resultType</span> <span class="operator">=</span> tag.attributeValue(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">sqlId</span> <span class="operator">=</span> namespace + <span class="string">&quot;.&quot;</span> + id;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> tag.getTextTrim();</span><br><span class="line">                    <span class="type">SqlMapperStatement</span> <span class="variable">sqlMapperStatement</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlMapperStatement</span>(sql, resultType);</span><br><span class="line">                    map.put(sqlId,sqlMapperStatement);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h5><p>设计SqlSession类。通过SqlSessionFactory的openSession方法创建SqlSession对象。</p><p>因为需要通过SqlSession执行sql语句，所以SqlSession中必须要有connection对象和sql语句。这些都可以通过SqlSessionFactory对象获得，因此往SqlSession对象中传入SqlSessionFactory对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSession</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSession</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSession</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>&#123;</span><br><span class="line">        sqlSessionFactory.getTransaction().commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>&#123;</span><br><span class="line">        sqlSessionFactory.getTransaction().rollback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        sqlSessionFactory.getTransaction().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h5><p>在SqlSession类中编写执行sql语句的方法。这里只实现insert和selectOne方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.god.ibatis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSession</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSession</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSession</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入sql语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sqlId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 插入数据库表的对象，要求对象属性为String类型，因为其他类型没有实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String sqlId,Object object)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> sqlSessionFactory.getTransaction().getConnection();</span><br><span class="line">            Map&lt;String, SqlMapperStatement&gt; mapperStatements = sqlSessionFactory.getMapperStatements();</span><br><span class="line">            <span class="type">SqlMapperStatement</span> <span class="variable">sqlMapperStatement</span> <span class="operator">=</span> mapperStatements.get(sqlId);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> sqlMapperStatement.getSql();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> sql.replaceAll(<span class="string">&quot;#\\&#123;[a-zA-Z0-9_$]*&#125;&quot;</span>, <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql1);</span><br><span class="line">            <span class="comment">//给第几个?传什么值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">jingIndex</span> <span class="operator">=</span> sql.indexOf(<span class="string">&quot;#&quot;</span>,fromIndex);</span><br><span class="line">                <span class="keyword">if</span>(jingIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">youkuoIndex</span> <span class="operator">=</span> sql.indexOf(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="comment">//获取属性名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> sql.substring(jingIndex + <span class="number">2</span>, youkuoIndex).trim();</span><br><span class="line">                <span class="comment">//获取方法名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;get&quot;</span> + propertyName.toUpperCase().charAt(<span class="number">0</span>) + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//利用反射机制获取方法</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(methodName);</span><br><span class="line">                <span class="comment">//调用方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">propertyValue</span> <span class="operator">=</span> getMethod.invoke(object);</span><br><span class="line">                <span class="comment">//给?传值</span></span><br><span class="line">                preparedStatement.setString(index,propertyValue.toString());</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            count = preparedStatement.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询sql语句，返回一条记录，本方法只考虑单条件的查询即?只有一个，且参数必须为String类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sqlId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">selectOne</span><span class="params">(String sqlId,Object param)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlMapperStatement</span> <span class="variable">sqlMapperStatement</span> <span class="operator">=</span> sqlSessionFactory.getMapperStatements().get(sqlId);</span><br><span class="line">            <span class="type">String</span> <span class="variable">godbatisSql</span> <span class="operator">=</span> sqlMapperStatement.getSql();</span><br><span class="line">            <span class="type">String</span> <span class="variable">resultType</span> <span class="operator">=</span> sqlMapperStatement.getResultType();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> godbatisSql.replaceAll(<span class="string">&quot;#\\&#123;[a-zA-Z0-9]*&#125;&quot;</span>, <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> sqlSessionFactory.getTransaction().getConnection();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//本框架只考虑参数为String类型的</span></span><br><span class="line">            ps.setString(<span class="number">1</span>,param.toString());</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> resultSet.getMetaData();</span><br><span class="line">                <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();</span><br><span class="line">                Class&lt;?&gt; resultClass = Class.forName(resultType);</span><br><span class="line">                obj = resultClass.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= columnCount; i ++)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnName(i + <span class="number">1</span>).trim();</span><br><span class="line">                    <span class="comment">//这里可以体现出为什么要求查询出来的数据库表的字段名和pojo类的属性名一致</span></span><br><span class="line">                    <span class="comment">//拼接set方法，给对象的属性赋值</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;set&quot;</span> + columnName.toUpperCase().charAt(<span class="number">0</span>) + columnName.substring(<span class="number">1</span>);</span><br><span class="line">                    <span class="type">Method</span> <span class="variable">setMethod</span> <span class="operator">=</span> obj.getClass().getDeclaredMethod(methodName, String.class);</span><br><span class="line">                    setMethod.invoke(obj,resultSet.getString(columnName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>&#123;</span><br><span class="line">        sqlSessionFactory.getTransaction().commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>&#123;</span><br><span class="line">        sqlSessionFactory.getTransaction().rollback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        sqlSessionFactory.getTransaction().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--20.Mybatis注解式开发</title>
      <link href="/2023/11/22/Mybatis%E5%AD%A6%E4%B9%A0--20.Mybatis%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2023/11/22/Mybatis%E5%AD%A6%E4%B9%A0--20.Mybatis%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis的注解式开发"><a href="#MyBatis的注解式开发" class="headerlink" title="MyBatis的注解式开发"></a>MyBatis的注解式开发</h4><ul><li><p>到目前为止，我们都是在mapper.xml文件中编写sql语句，但其实mybatis提供了一种语法，可以不使用mapper.xml文件来编写sql语句，而是通过注解的方式来实现。</p></li><li><p>在实际开发中，我们采用混合式方法编写sql语句。对于一些简单sql语句，我们使用注解来实现，对于较复杂的sql语句我们还是使用mapper.xml文件进行编写</p></li><li><pre><code class="java">public interface CarMapper &#123;    @Insert(&quot;insert into t_car values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&quot;)    int insert(Car car);    @Delete(&quot;delete from t_car where id = #&#123;id&#125;&quot;)    int delete(Long id);    @Update(&quot;update t_car set car_num = #&#123;carNum&#125;,brand=#&#123;brand&#125;,guide_price=#&#123;guidePrice&#125;,car_type=#&#123;carType&#125;&quot; +            &quot;where id = #&#123;id&#125;&quot;)    int update(Car car);    @Select(&quot;select * from t_car where id = #&#123;id&#125;&quot;)    Car select(Long id);&#125;</code></pre></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--19.Mybatis中的分页插件</title>
      <link href="/2023/11/22/Mybatis%E5%AD%A6%E4%B9%A0--19.Mybatis%E4%BD%BF%E7%94%A8PageHelper/"/>
      <url>/2023/11/22/Mybatis%E5%AD%A6%E4%B9%A0--19.Mybatis%E4%BD%BF%E7%94%A8PageHelper/</url>
      
        <content type="html"><![CDATA[<h4 id="Mybatis使用PageHelper"><a href="#Mybatis使用PageHelper" class="headerlink" title="Mybatis使用PageHelper"></a>Mybatis使用PageHelper</h4><ul><li><p>PageHelper是他人开发出来方便mybatis进行分页操作的一个插件。</p></li><li><p>分页查询中的两个重要概念：</p><ul><li>pageNum：页号，表示要查询第几页的信息</li><li>pageSize：每页可以显示的记录条数</li></ul></li><li><p>用户发送请求时，需要将这两个信息一起发送。</p></li><li><p>在mysql中可以使用limit关键字来进行分页操作。比如select * from xxx limit 0,3;表示显示开头3条记录。limit后的第一个参数表示起始位置，第二个参数表示显示多少条记录。</p></li><li><p>通过分析我们可以得到以下关系式：</p><ul><li>startIndex &#x3D; (pageNum - 1) * pageSize; </li><li>因此根据用户从前端传来的pageNum和pageSize参数，可以使用limit关键字从数据库中获取相关数据</li></ul></li><li><p>其实获取分页相关的数据并不难(直接通过limit关键字即可)，但是想要获取分页相关的信息就没那么简单，比如是否还有下一页、上一页(通过limit很难做到)，因此我们需要使用pageHelper插件</p></li></ul><h5 id="PageHelper插件"><a href="#PageHelper插件" class="headerlink" title="PageHelper插件"></a>PageHelper插件</h5><ul><li><p>使用PageHelper插件进行分页，更加方便简单</p></li><li><p>使用方法</p><ol><li><p>引入pageHelper插件依赖</p><ul><li><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;            &lt;version&gt;5.3.1&lt;/version&gt;        &lt;/dependency&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在mybatis核心配置文件中配置插件</span><br><span class="line"></span><br><span class="line">   * ```xml</span><br><span class="line">     &lt;!--    mybatis分页拦截器--&gt;</span><br><span class="line">         &lt;plugins&gt;</span><br><span class="line">             &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;</span><br><span class="line">         &lt;/plugins&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>编写java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">CarMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CarMapper.class);</span><br><span class="line">    <span class="comment">//注意：在执行SQL语句(select)之前需要开启pageHelper</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    PageHelper.startPage(startIndex,pageSize);</span><br><span class="line">    List&lt;Car&gt; cars = mapper.selectAll();</span><br><span class="line">    cars.forEach(car -&gt; System.out.println(car));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过PageInfo对象获取分页信息</p><ul><li><pre><code class="java">public void testSelectByPage()&#123;        SqlSession sqlSession = SqlSessionUtil.getSqlSession();        CarMapper mapper = sqlSession.getMapper(CarMapper.class);        //注意：在执行SQL语句(select)之前需要开启pageHelper        int startIndex = 2;        int pageSize = 2;        PageHelper.startPage(startIndex,pageSize);        List&lt;Car&gt; cars = mapper.selectAll();//        cars.forEach(car -&gt; System.out.println(car));        PageInfo&lt;Car&gt; carpageInfo = new PageInfo&lt;Car&gt;(cars,2);        System.out.println(carpageInfo);    &#125;/**这也是我们使用PageHelper的目的PageInfo中包含的信息PageInfo&#123;pageNum=2(页数), pageSize=2(页的大小), size=2, startRow=3(数据库表的起始), endRow=4(数据库表的结束), total=4(数据库表的数据大小), pages=2(总页数), list=Page&#123;count=true, pageNum=2, pageSize=2, startRow=2, endRow=4, total=4, pages=2, reasonable=false, pageSizeZero=false&#125;[法拉利, BMW], prePage=1(前一页的编号), nextPage=0(后一页的编号，当为最后一页时，后一页编号为0), isFirstPage=false(是否是第一页), isLastPage=true(是否是最后一页), hasPreviousPage=true(前面是否还有页), hasNextPage=false(后面是否还有页), navigatePages=2(导航栏中显示的页), navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;**/</code></pre></li><li></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--18.Mybatis的逆向工程</title>
      <link href="/2023/11/21/Mybatis%E5%AD%A6%E4%B9%A0--18.Mybatis%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
      <url>/2023/11/21/Mybatis%E5%AD%A6%E4%B9%A0--18.Mybatis%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="Mybatis的逆向工程"><a href="#Mybatis的逆向工程" class="headerlink" title="Mybatis的逆向工程"></a>Mybatis的逆向工程</h4><ul><li>使用mybatis的逆向工程(别人开发的工具)，可以根据数据库表动态生成对应的pojo类，mapper接口以及mapper.xml文件。</li><li>使用逆向工程组件需要进行的配置<ul><li>生成pojo类的类名，包名以及生成位置</li><li>生成mapper接口的接口名，包名以及生成位置</li><li>mapper.xml文件的文件名及生成位置</li><li>指定哪些表参与逆向工程</li><li>….</li></ul></li></ul><h5 id="第一步：在pom文件中引入配置信息"><a href="#第一步：在pom文件中引入配置信息" class="headerlink" title="第一步：在pom文件中引入配置信息"></a>第一步：在pom文件中引入配置信息</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.deng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-010<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--                组件的位置--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--         允许覆盖，如果使用该组件前已经有pojo类、mapper接口等，那么使用该组件生成的--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--            内容会覆盖之前的内容--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--            插件依赖--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第二步：在根路径下编写generatorConfig-xml文件"><a href="#第二步：在根路径下编写generatorConfig-xml文件" class="headerlink" title="第二步：在根路径下编写generatorConfig.xml文件"></a>第二步：在根路径下编写generatorConfig.xml文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--targetRuntime有两个值</span></span><br><span class="line"><span class="comment">    MyBatis3Simple：生成基础版，只有简单的增删改查</span></span><br><span class="line"><span class="comment">    MyBatis3：生成增强版，除了基础的增删改查外，还有复杂的增删改查--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;MysqlContext&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span> <span class="attr">defaultModelType</span>=<span class="string">&quot;flat&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--防止生成重复代码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否去除生成日期--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否去除注释--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;dch&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 对应生成的pojo所在包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.deng.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否开启子包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否去除字段名的前后空白--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 对应生成的mapper.xml所在目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.deng.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否开启子包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mapper接口所在包名及位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.deng.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否开启子包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数据库表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_car&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Car&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：在增强版中，会生成一个XxxExample类，这个类是用来封装条件的。也就是说，当我们想有条件的查询时，需要通过调用这个类的相关方法来完成。这是一种QBC查询风格，是面向对象的而不是面向sql语句的查询方式。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--16.Mybatis的高级映射及延迟加载</title>
      <link href="/2023/11/17/Mybatis%E5%AD%A6%E4%B9%A0--16.Mybatis%E7%9A%84%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E5%8F%8A%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/"/>
      <url>/2023/11/17/Mybatis%E5%AD%A6%E4%B9%A0--16.Mybatis%E7%9A%84%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E5%8F%8A%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="Mybatis的高级映射及延迟加载"><a href="#Mybatis的高级映射及延迟加载" class="headerlink" title="Mybatis的高级映射及延迟加载"></a>Mybatis的高级映射及延迟加载</h4><h5 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h5><ul><li><p>之前我们使用mybatis时，都是单表映射——一张数据库表对应一个java类。但在实际应用中，往往有多张表，且这些表之间是存在某种关系的比如：一对一、一对多、多对一等，针对以上情况，mybatis中提供了高级映射机制，来解决数据库表与java对象之间的映射关系。</p></li><li><p>以下以班级表和学生表为例</p></li><li><p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0--16.Mybatis%E7%9A%84%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E5%8F%8A%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/image-20231120111007507.png"></p></li><li><p>有两种解决方案：</p><ol><li><p>将表的关系看作是多对一，即多个学生对应一个班级。以多的一方(Student)作为主表，Student对象作为主对象，Clazz对象作为副对象。通过Student对象可以找到对应的Clazz对象，因此在Student中添加一个Clazz属性。</p><ul><li><p>mybatis中实现多对一映射的方法</p><ol><li><p>一条sql语句，级联属性的方法</p><ul><li><pre><code class="xml">    &lt;resultMap id=&quot;studentResultMap&quot; type=&quot;student&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;clazz.cid&quot; column=&quot;cid&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;clazz.cname&quot; column=&quot;cname&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; resultMap=&quot;studentResultMap&quot;&gt;        select        s.id,s.name,c.cid,c.cname        from t_stud s left join t_clazz c on s.cid = c.cid        where s.id = #&#123;id&#125;    &lt;/select&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 一条sql语句，采用association标签进行表的关联。</span><br><span class="line"></span><br><span class="line">   * ```xml</span><br><span class="line">         &lt;resultMap id=&quot;studentResultMap2&quot; type=&quot;student&quot;&gt;</span><br><span class="line">             &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">             &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;</span><br><span class="line">     &lt;!--        property: 需要关联的pojo类的属性，在本例中就是Student类的clazz属性--&gt;</span><br><span class="line">     &lt;!--        javaType：需要关联的Java类，在本例中就是Clazz类，这里使用了别名--&gt;</span><br><span class="line">             &lt;association property=&quot;clazz&quot; javaType=&quot;Clazz&quot;&gt;</span><br><span class="line">                 &lt;id property=&quot;cid&quot; column=&quot;cid&quot;&gt;&lt;/id&gt;</span><br><span class="line">                 &lt;result property=&quot;cname&quot; column=&quot;cname&quot;&gt;&lt;/result&gt;</span><br><span class="line">             &lt;/association&gt;</span><br><span class="line">         &lt;/resultMap&gt;</span><br><span class="line">         &lt;select id=&quot;selectById2&quot; resultMap=&quot;studentResultMap2&quot;&gt;</span><br><span class="line">             select</span><br><span class="line">             s.id,s.name,c.cid,c.cname</span><br><span class="line">             from</span><br><span class="line">             t_stud s left join t_clazz c on s.cid = c.cid</span><br><span class="line">             where s.id = #&#123;id&#125;</span><br><span class="line">         &lt;/select&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>前两种方法都是通过一条sql语句进行多表查询的方式，接下来这种方法是通过两条sql语句进行分步查询。即先根据id获取student，再通过student获得clazz对象。</p><ul><li><pre><code class="xml">    &lt;!--StudentMapper.xml--&gt;&lt;resultMap id=&quot;StudentResultMapStep&quot; type=&quot;student&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;        &lt;association property=&quot;clazz&quot;                     select=&quot;com.deng.mybatis.mapper.ClazzMapper.selectByCidStep2&quot;                     column=&quot;cid&quot;&gt;&lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectByIdStep1&quot; resultMap=&quot;StudentResultMapStep&quot;&gt;        select id,name,cid from t_stud where id = #&#123;id&#125;    &lt;/select&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">* ```xml</span><br><span class="line">  &lt;!--ClazzMapper.xml--&gt;  </span><br><span class="line">  &lt;select id=&quot;selectByCidStep2&quot; resultType=&quot;clazz&quot;&gt;</span><br><span class="line">          select cid,cname from t_clazz where cid = #&#123;cid&#125;</span><br><span class="line">      &lt;/select&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>这种做法的好处在于，代码可复用以及支持延迟加载(懒加载)</p></li><li><p>因为拆解成了两步，每一步都可以被复用</p></li><li><p>支持延迟加载：在使用的时候执行查询语句，不使用的时候不执行查询语句。可以提高性能。</p></li><li><p>比如：<strong>如果我只需要查询student的name，通过前两种方式会将两个表进行匹配，查询时间是n*m的。而如果使用第三种方式并且开启延迟加载，那么就只会执行一条sql语句，查询时间为n。</strong></p></li><li><pre><code class="java">Preparing: select id,name,cid from t_stud where id = ?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">* 可以在mybatis核心配置文件中的settings标签添加以下代码，开启全局延迟加载，使用后只要是分步查询都会开启延迟加载功能</span><br><span class="line">       </span><br><span class="line">* ```xml</span><br><span class="line">          &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&gt;&lt;/setting&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>可以在association标签中通过设置fetchType &#x3D; eager来局部关闭延迟加载</p></li></ul></li></ol></li></ul></li><li><p>就是将表之间的关系看成是一对多，在本例中就是指一个班级对应多个学生。在这种关系下，我们需要将班级表作为主表，班级对象作为主对象。实现的原理就是，先查询某个班级，再通过该班级查询学生。因此需要在Clazz类中添加一个Student集合属性，用来存放查询到的学生。</p><ul><li><p>mybatis中实现一对多关系间的映射的方法</p><ol><li><p>collection标签(类似一对多中的association标签)，一条sql语句。通过多表连接查询</p><ul><li><pre><code class="xml">    &lt;resultMap id=&quot;selectByCollectionMap&quot; type=&quot;Clazz&quot;&gt;        &lt;id property=&quot;cid&quot; column=&quot;cid&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;cname&quot; column=&quot;cname&quot;&gt;&lt;/result&gt;        &lt;!--        property: 需要关联的pojo类的属性，在本例中就是Clazz类的studs属性--&gt;&lt;!--        ofType：需要关联的Java类，在本例中就是Student类，这里使用了别名--&gt;        &lt;collection property=&quot;studs&quot; ofType=&quot;student&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;            &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectByCollection&quot; resultMap=&quot;selectByCollectionMap&quot;&gt;        select        c.cid,c.cname,s.id,s.name        from        t_clazz c left join t_stud s on c.cid = s.cid        where c.cid = #&#123;cid&#125;    &lt;/select&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">   * </span><br><span class="line">  </span><br><span class="line">2. 分步查询.两条sql语句，先根据cid查询clazz对象，再通过cid查询student对象。有同学可能会问，为啥不直接根据cid查询student，那是因为这样做无法查出班级名称。</span><br><span class="line">  </span><br><span class="line">   * ```xml</span><br><span class="line">        &lt;!--ClazzMapper.xml--&gt;</span><br><span class="line">     &lt;resultMap id=&quot;selectByCidStep1&quot; type=&quot;clazz&quot;&gt;</span><br><span class="line">             &lt;id property=&quot;cid&quot; column=&quot;cid&quot;&gt;&lt;/id&gt;</span><br><span class="line">             &lt;result property=&quot;cname&quot; column=&quot;cname&quot;&gt;&lt;/result&gt;</span><br><span class="line">             &lt;collection property=&quot;studs&quot;</span><br><span class="line">                         select=&quot;com.deng.mybatis.mapper.StudentMapper.selectByCidStep2&quot;</span><br><span class="line">                         column=&quot;cid&quot;&gt;&lt;/collection&gt;</span><br><span class="line">         &lt;/resultMap&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;select id=&quot;selectByCidStep1&quot; resultMap=&quot;selectByCidStep1&quot;&gt;</span><br><span class="line">             select cid,cname from t_clazz where cid = #&#123;cid&#125;</span><br><span class="line">         &lt;/select&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="xml">&lt;!--StudentMapper.xml--&gt; &lt;select id=&quot;selectByCidStep2&quot; resultType=&quot;student&quot;&gt;        select id,name from t_stud where cid = #&#123;cid&#125;    &lt;/select&gt;</code></pre></li><li></li></ul></li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--15.动态SQL</title>
      <link href="/2023/11/15/Mybatis%E5%AD%A6%E4%B9%A0--15.%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2023/11/15/Mybatis%E5%AD%A6%E4%B9%A0--15.%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><h5 id="为什么需要动态SQL"><a href="#为什么需要动态SQL" class="headerlink" title="为什么需要动态SQL"></a>为什么需要动态SQL</h5><ul><li>学习新技术前我们需要知道为什么需要学习这个技术，即这项技术有什么用，在我们的开发过程中有哪些场景可以用到？</li><li>我们之前的SQL语句要么是静态的，要么是可以预测的(参数固定的)。但在实际应用中在很多场景下，sql语句并不是固定的。比如：批量删除功能，我们无法预测用户需要删除多少数据，因此我们无法提前编写好sql语句。再比如：用户指定多个属性进行查询，我们也无法确定用户是根据哪些属性进行查询。</li><li>以上的业务场景，都不能使用现有的技术来解决，或者说如果使用现有技术会十分麻烦。而动态SQL能够很好的解决该问题。</li><li>所谓动态SQL，简单来说就是指SQL语句是动态变化的。能够根据不同的业务场景，得到合适的SQL语句。</li></ul><h5 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h5><ul><li><p>使用场景：多条件查询</p></li><li><pre><code class="xml">    &lt;select id=&quot;selectByMulti&quot; resultType=&quot;car&quot;&gt;        &lt;!--test属性为真则执行标签内的语句--&gt;        select * from t_car where 1 = 1        &lt;!--疑问：            还有为什么核心配置文件中的mappers标签内不用指定Mapper.xml的路径了            需要再去看一下别名        --&gt;        &lt;if test=&quot;#&#123;brand&#125; != null and #&#123;brand&#125; != &#39;&#39;&quot;&gt;            and brand like &quot;%&quot;#&#123;brand&#125;&quot;%&quot;        &lt;/if&gt;        &lt;if test=&quot;#&#123;price&#125; != null and #&#123;price&#125; != &#39;&#39;&quot;&gt;            and guide_price &gt;= #&#123;price&#125;        &lt;/if&gt;        &lt;if test=&quot;#&#123;carType&#125; != null and #&#123;carType&#125; != &#39;&#39;&quot;&gt;            and car_type = #&#123;carType&#125;        &lt;/if&gt;    &lt;/select&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### where标签</span><br><span class="line"></span><br><span class="line">* 场景需求：在上面的if条件中，为了避免某些条件不成立导致sql语句格式的错误，我们在语句中添加了where 1 = 1这一段代码，这非常的不美观。</span><br><span class="line"></span><br><span class="line">* 我们可以使用where标签使SQL语句更加智能化。</span><br><span class="line"></span><br><span class="line">* 作用</span><br><span class="line"></span><br><span class="line">  * 当条件都不成立时，使用where标签后，不会生成where语句。</span><br><span class="line"></span><br><span class="line">  * 能够智能化的删减前面的and或or。比如：当第一个条件成立时，使用了where标签，那么它能够自动化的检测出and关键字是多余的，并且会将其删除。</span><br><span class="line"></span><br><span class="line">  * 这里需要注意的是：where标签只能检测出是否多余了and或or关键字并将多余的删除，并不能检测出是否缺失了and或or关键字，自然不会填补上缺失的关键字。还有，where标签只能检测and在前面的语句，对and在后面的语句无效。比如guide_price &gt;= #&#123;price&#125; and.</span><br><span class="line"></span><br><span class="line">  * **所以建议在使用where标签使SQL语句更加智能化时，在每个条件中都写上and关键字，且写在前面**</span><br><span class="line"></span><br><span class="line">  * ```xml</span><br><span class="line">       &lt;select id=&quot;selectByMultiWithWhere&quot; resultType=&quot;car&quot;&gt;</span><br><span class="line">            select * from t_car</span><br><span class="line">            &lt;where&gt;</span><br><span class="line">                &lt;if test=&quot;#&#123;brand&#125; != null and #&#123;brand&#125; != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    and brand like &quot;%&quot;#&#123;brand&#125;&quot;%&quot;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;#&#123;price&#125; != null and #&#123;price&#125; != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    and guide_price &gt;= #&#123;price&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;#&#123;carType&#125; != null and #&#123;carType&#125; != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    and car_type = #&#123;carType&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/where&gt;</span><br><span class="line">        &lt;/select&gt;</span><br></pre></td></tr></table></figure>*</code></pre></li></ul><h5 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h5><ul><li><p>trim标签也能解决以上问题</p></li><li><p>在trim标签中有4个属性</p><ul><li>prefix:在标签体前加上一个前缀</li><li>suffix:在标签体后加上一个后缀</li><li>prefixoverride:删除sql语句的前缀</li><li>suffixoverride:删除sql语句的后缀，对where标签不能删除and出现在语句后面的情况做出了补充。比where标签功能更加强大</li></ul></li><li><pre><code class="xml">    &lt;select id=&quot;selectByMultiWithTrim&quot; resultType=&quot;car&quot;&gt;        select * from t_car        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot;&gt;            &lt;if test=&quot;#&#123;brand&#125; != null and #&#123;brand&#125; != &#39;&#39;&quot;&gt;                and brand like &quot;%&quot;#&#123;brand&#125;&quot;%&quot;            &lt;/if&gt;            &lt;if test=&quot;#&#123;price&#125; != null and #&#123;price&#125; != &#39;&#39;&quot;&gt;                and guide_price &gt;= #&#123;price&#125;            &lt;/if&gt;            &lt;if test=&quot;#&#123;carType&#125; != null and #&#123;carType&#125; != &#39;&#39;&quot;&gt;                and car_type = #&#123;carType&#125;            &lt;/if&gt;        &lt;/trim&gt;    &lt;/select&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### set标签</span><br><span class="line"></span><br><span class="line">* 需求场景：我们在进行数据库表的更新时，有可能只需要修改某一个字段，对于其他字段我们提交的数据都是null。如果采用原始做法，那么会将其他数据都更新为null，这肯定不是我们想要看到的。</span><br><span class="line"></span><br><span class="line">* set标签能够解决以上问题，如果提交的数据为null，那么使用set标签将不会修改该字段。并且使用set标签还能够去除多余的逗号。</span><br><span class="line"></span><br><span class="line">  * ```xml</span><br><span class="line">    update t_car</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;if test=&quot;carNum != null and carNum != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    car_num = #&#123;carNum&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    brand = #&#123;brand&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    guide_price = #&#123;guidePrice&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;produceTime != null and produceTime != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    produce_time = #&#123;produceTime&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    car_type = #&#123;carType&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">            where id = #&#123;id&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose-when-otherwise标签"></a>choose-when-otherwise标签</h5><ul><li><p>就是java中的嵌套条件语句：if-else if-else</p></li><li><pre><code class="xml">  select * from t_car        &lt;where&gt;            &lt;choose&gt;                &lt;when test=&quot;brand != null and brand != &#39;&#39;&quot;&gt;                    brand = #&#123;brand&#125;                &lt;/when&gt;                &lt;when test=&quot;price != null and price != &#39;&#39;&quot;&gt;                    guide_price &gt;= #&#123;price&#125;                &lt;/when&gt;                &lt;otherwise&gt;                    car_type = #&#123;carType&#125;                &lt;/otherwise&gt;            &lt;/choose&gt;        &lt;/where&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### foreach标签</span><br><span class="line"></span><br><span class="line">* 就是循环</span><br><span class="line"></span><br><span class="line">* 批量删除</span><br><span class="line"></span><br><span class="line">* ```xml</span><br><span class="line">   &lt;delete id=&quot;deleteByIds&quot;&gt;</span><br><span class="line">          delete from t_car where id in</span><br><span class="line">       &lt;!--</span><br><span class="line">    collection:需要进行遍历的集合或数组对象 item：当前枚举的元素</span><br><span class="line">    separator：元素与元素之间以什么分隔</span><br><span class="line">    open：循环体以什么开始</span><br><span class="line">    close：循环体以什么结束</span><br><span class="line">    --&gt;</span><br><span class="line">          &lt;foreach collection=&quot;ids&quot; item=&quot;a&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">              #&#123;a&#125;</span><br><span class="line">          &lt;/foreach&gt;</span><br><span class="line">     &lt;!--</span><br><span class="line">    另一种批量删除的方法</span><br><span class="line">    delete from t_car where</span><br><span class="line">    &lt;foreach collection = &quot;ids&quot; item = &quot;a&quot; sparator=&quot;or&quot;&gt;</span><br><span class="line">    id = #&#123;a&#125;</span><br><span class="line">      &lt;/foreach&gt;</span><br><span class="line">    --&gt;  </span><br><span class="line">      &lt;/delete&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="Sql与include标签"><a href="#Sql与include标签" class="headerlink" title="Sql与include标签"></a>Sql与include标签</h5><ul><li><p>sql标签：将某个代码片段声明为sql语句</p></li><li><p>include标签：使用sql片段</p></li><li><p>可以提高代码复用性，使代码更容易维护</p></li><li><pre><code class="xml"> &lt;sql id=&quot;carColumeSql&quot;&gt;        id,car_num as carNum,brand,guide_price as guidePrice,        produce_time as produceTime,car_type as carType    &lt;/sql&gt;    &lt;select id=&quot;selectById&quot; resultType=&quot;com.deng.mybatis.pojo.Car&quot;&gt;        select        &lt;include refid=&quot;carColumeSql&quot;&gt;&lt;/include&gt;        from t_car where id = #&#123;id&#125;;    &lt;/select&gt;</code></pre></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--17.Mybatis的缓存</title>
      <link href="/2023/11/14/Mybatis%E5%AD%A6%E4%B9%A0--17.Mybatis%E7%9A%84%E7%BC%93%E5%AD%98/"/>
      <url>/2023/11/14/Mybatis%E5%AD%A6%E4%B9%A0--17.Mybatis%E7%9A%84%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h4 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h4><ul><li>在mybatis中提供了一种缓存机制，内存中有一块区域用来存放从数据库中查询的结果。当下次再执行相同的查询语句时，就不需要通过IO的方式从数据库中取数据(数据库中的数据实际上是存放在硬盘文件中)，而是直接从缓存中取数据。一方面减少了IO操作次数，另一方面不再执行繁琐的查询算法，提高了查询效率。</li><li>缓存机制是计算机中优化性能的一种重要手段。比如计算机系统中cache，java中的字符串常量池，整数常量池(-127-128),线程池、连接池等。都是缓存机制的应用</li><li>mybatis缓存包括：一级缓存(将查询的结果存储到SqlSession中)、二级缓存(将查询的结果存储到SqlSessionFactory中)或者集成第三方的缓存</li><li>mybatis的缓存机制只针对DQL语句(select)，目的是提高查询效率</li></ul><h5 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h5><ul><li><p>一级缓存是默认开启的，不需要配置</p></li><li><p>如果在同一个SqlSession对象执行相同的select语句，就会使用缓存机制，只在第一次执行select语句，其余语句不会执行，而是直接从缓存中取出结果返回。</p></li><li><p>当SqlSession对象不同或者查询条件不同时，不会使用缓存机制</p></li><li><p>一级缓存失效的条件</p><ol><li>调用SqlSession的clearCache方法，进行手动清空缓存</li><li>只要执行insert、delete或update语句都会使一级缓存清空，即使这些语句是对另一张表的操作</li></ol></li><li><pre><code class="java">  @Test    public void testSelectById()&#123;        SqlSession sqlSession = SqlSessionUtil.getSqlSession();        CarMapper mapper = sqlSession.getMapper(CarMapper.class);          Car car1 = mapper.selectById(12L);        System.out.println(car1);        //sqlSession.clearCache();        Car car2 = mapper.selectById(12L);        System.out.println(car2);        sqlSession.close();    &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Preparing: select * from t_car where id = ?</span><br><span class="line"></span><br><span class="line">##### 二级缓存</span><br><span class="line"></span><br><span class="line">* 二级缓存的作用范围为整个SqlSessionFactory(一个SqlSessionFactory对应一个数据库)</span><br><span class="line"></span><br><span class="line">* 如何使用二级缓存</span><br><span class="line"></span><br><span class="line">  1. 在mybatis核心配置文件的settings标签中开启二级缓存机制，不过由于mybatis中默认开启二级缓存，所以不需要配置</span><br><span class="line">  2. 在需要使用二级缓存的SqlMapper.xml文件中添加&lt;cache/&gt;标签</span><br><span class="line">  3. 使用二级缓存的实体类必须可序列化，即实现java.io.Serializable接口</span><br><span class="line">  4. 只有当SqlSession对象关闭或提交后，一级缓存中的数据才会写入二级缓存中，二级缓存才会生效</span><br><span class="line"></span><br><span class="line">* 一级缓存的优先级高于二级缓存</span><br><span class="line"></span><br><span class="line">* 二级缓存失效的条件</span><br><span class="line"></span><br><span class="line">  * 只要执行insert、delete或update语句都会使一级缓存清空，即使这些语句是对另一张表的操作</span><br><span class="line"></span><br><span class="line">* 二级缓存的相关配置</span><br><span class="line"></span><br><span class="line">  * 在cache标签中有很多属性</span><br><span class="line"></span><br><span class="line">    * eviction：指定从缓存中移除某个对象的淘汰算法，默认使用LRU策略</span><br><span class="line"></span><br><span class="line">      * LRU：least recently used，最近使用次数少的对象，优先淘汰在间隔时间内使用频率最低的对象</span><br><span class="line">      * FIFO：first in first out，先进入缓存中的对象先被淘汰</span><br><span class="line">      * SOFT：优先淘汰软引用指向的对象，与JVM的垃圾回收算法相关</span><br><span class="line">      * WEAK：优先淘汰弱引用指向的对象，与JVM的垃圾回收算法相关</span><br><span class="line"></span><br><span class="line">    * flushinterval：设置二级缓存的刷新间隔。默认不刷新</span><br><span class="line"></span><br><span class="line">    * readonly：</span><br><span class="line"></span><br><span class="line">      a. 值为true时，多条相同sql语句返回的对象是同一个，性能好，但有线程安全问题</span><br><span class="line"></span><br><span class="line">      b. 值为false时，多条相同sql语句返回的对象是副本对象，调用了clone方法，线程安全但性能一般</span><br><span class="line"></span><br><span class="line">    * size：设置缓存中可以存放对象的最大数量，默认值为1024</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">    public void testSelectByIdWithDifSqlS() throws Exception&#123;</span><br><span class="line">          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));</span><br><span class="line">          SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">          SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">          CarMapper mapper1 = sqlSession1.getMapper(CarMapper.class);</span><br><span class="line">          CarMapper mapper2 = sqlSession2.getMapper(CarMapper.class);</span><br><span class="line">          Car car1 = mapper1.selectById(12L);</span><br><span class="line">          System.out.println(car1);</span><br><span class="line">          sqlSession1.close();</span><br><span class="line">          Car car2 = mapper2.selectById(12L);</span><br><span class="line">          System.out.println(car2);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Preparing: select * from t_car where id &#x3D; ?</p></li></ul><h5 id="集成第三方的缓存"><a href="#集成第三方的缓存" class="headerlink" title="集成第三方的缓存"></a>集成第三方的缓存</h5><ul><li><p>以Ehcache三方缓存器为例</p></li><li><p>这种第三方的缓存器可以替代mybatis中的二级缓存，无法替代一级缓存</p></li><li><p>使用步骤</p><ol><li><p>引入Ehcache依赖</p><ul><li><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在mybatis的根路径下新建ehcache.xml文件，并配置以下信息</span><br><span class="line"></span><br><span class="line">   * ```xml</span><br><span class="line">     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">     &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;</span><br><span class="line">              updateCheck=&quot;false&quot;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;defaultCache</span><br><span class="line">                 eternal=&quot;false&quot;</span><br><span class="line">                 maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">                 overflowToDisk=&quot;false&quot;</span><br><span class="line">                 diskPersistent=&quot;false&quot;</span><br><span class="line">                 timeToLiveSeconds=&quot;3600&quot;</span><br><span class="line">                 timeToIdleSeconds=&quot;0&quot;</span><br><span class="line">                 diskExpiryThreadIntervalSeconds=&quot;120&quot;</span><br><span class="line">                 memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;cache</span><br><span class="line">                 name=&quot;user&quot;</span><br><span class="line">                 eternal=&quot;false&quot;</span><br><span class="line">                 maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">                 overflowToDisk=&quot;false&quot;</span><br><span class="line">                 diskPersistent=&quot;false&quot;</span><br><span class="line">                 timeToLiveSeconds=&quot;3600&quot;</span><br><span class="line">                 timeToIdleSeconds=&quot;0&quot;</span><br><span class="line">                 diskExpiryThreadIntervalSeconds=&quot;120&quot;</span><br><span class="line">                 memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--    存储到磁盘时的路径--&gt;</span><br><span class="line">         &lt;diskStore path=&quot;/Users/wuhanxue/Downloads/ehcache&quot; /&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;/ehcache&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>修改cache标签，添加type属性</p><ul><li><pre><code class="xml">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;</code></pre></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--14.查询专题</title>
      <link href="/2023/11/14/Mybatis%E5%AD%A6%E4%B9%A0--14.Mybatis%E6%9F%A5%E8%AF%A2%E4%B8%93%E9%A2%98/"/>
      <url>/2023/11/14/Mybatis%E5%AD%A6%E4%B9%A0--14.Mybatis%E6%9F%A5%E8%AF%A2%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>#####自定义结果集映射</p><ul><li><p>可以在mapper.xml文件中通过resultMap标签自定义一个结果映射集resultmap，用来指定pojo类的属性和数据库表的字段之间的对应关系。解决了我们编写查询sql语句时需要给字段名重命名的麻烦。</p></li><li><p>该标签中有两个重要属性：</p><ul><li>id：用于唯一标识该映射集</li><li>type：指定对应的pojo类</li></ul></li><li><pre><code class="xml">&lt;mapper namespace=&quot;com.deng.mybatis.mapper.StudentMapper&quot;&gt;    &lt;resultMap id=&quot;studentResultMap&quot; type=&quot;student&quot; &gt;        &lt;!--为了提高mybatis效率，建议加上数据库表的主键，即使主键字段名和pojo类属性名一致--&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;date&quot; column=&quot;date&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;height&quot; column=&quot;height&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;gender&quot; column=&quot;gender&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; resultMap=&quot;studentResultMap&quot;&gt;        select * from t_student where id = #&#123;id&#125;;    &lt;/select&gt;&lt;/mapper&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Mybatis中开启自动驼峰映射</span><br><span class="line"></span><br><span class="line">* 可以在mybatis核心配置文件中进行配置，使我们查询结果时，pojo类的属性名可以直接映射为对应的数据库表的字段名。</span><br><span class="line"></span><br><span class="line">* ```xml</span><br><span class="line">  &lt;settings&gt;</span><br><span class="line">         &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">     &lt;/settings&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>不过这种方法是有前提条件的：pojo类属性的命名和数据库表字段的命名都需要符合规范。pojo类属性名需要符合驼峰命名法，数据库表的字段名必须全部小写，单词之间用下划线分隔。比如pojo类中的studentName对应字段名studeng_name</p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--13.Mybatis的参数处理</title>
      <link href="/2023/11/13/Mybatis%E5%AD%A6%E4%B9%A0--13.Mybatis%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/"/>
      <url>/2023/11/13/Mybatis%E5%AD%A6%E4%B9%A0--13.Mybatis%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis的参数处理"><a href="#MyBatis的参数处理" class="headerlink" title="MyBatis的参数处理"></a>MyBatis的参数处理</h4><h5 id="单个简单类型参数"><a href="#单个简单类型参数" class="headerlink" title="单个简单类型参数"></a>单个简单类型参数</h5><ul><li><p>单个：接口中方法的参数只有一个</p></li><li><p>简单类型：接口中方法的参数类型为简单类型。包括基本数据类型 + 包装类 + String + java.util.Date + java.sql.Date</p></li><li><p>其实sql标签中有一个属性：parameterType。顾名思义，它用来指定参数的类型，但由于mybatis能够在获得参数后自动推断出该参数的类型，因此该属性可以省略。并且mybatis对这些类型也起了别名，比如byte的别名为_byte.</p><ul><li><pre><code class="xml">&lt;select id=&quot;selectById&quot; resultType=&quot;student&quot; parameterType=&quot;long&quot;&gt;        select * from t_student where id = $&#123;id&#125;;    &lt;/select&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 还有map集合作为参数，pojo类作为参数。mybatis都能自动推断其类型</span><br><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">##### 多参数</span><br><span class="line"></span><br><span class="line">* 指接口中的方法有多个参数。</span><br><span class="line"></span><br><span class="line">* 当有多个参数时，mybatis底层会自动创建一个map集合，以这些参数的下标值作为key，参数值作为value放入map中。比如map.put(&quot;arg0&quot;,name)或者map.put(&quot;param1&quot;,name);</span><br><span class="line"></span><br><span class="line">* 可以在方法中使用param注解指定key值。比如</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    public void selectByIdAndName(@Param(&quot;id&quot;)Long id,@Param(&quot;name&quot;)String name);</span><br><span class="line">    //注解中的属性值可以省略不写</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h5 id="底层源码分析"><a href="#底层源码分析" class="headerlink" title="底层源码分析"></a>底层源码分析</h5><p>当我们在mybatis中进行数据库表的操作时(也就是调用接口中的方法)，首先会执行以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span></span><br><span class="line">    <span class="comment">//proxy:代理对象</span></span><br><span class="line">    <span class="comment">//method：目标方法(就是接口中的方法)</span></span><br><span class="line">    <span class="comment">//args：目标方法中的参数</span></span><br></pre></td></tr></table></figure><p>mybatis底层会先判断要执行的是哪种操作：insert、update、select、delete。如果是DML语句，那么会直接执行下述代码。进行参数转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param = <span class="built_in">this</span>.method.convertArgsToSqlCommandParam(args);</span><br></pre></td></tr></table></figure><p>如果是查询语句，那么会根据返回值类型的不同执行不同的方法。然后也会执行上述代码，进行参数转换。</p><p>底层会调用ParamNameResolver的getNamedParams方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getNamedParams</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//这个names是一个sortedMap集合</span></span><br><span class="line">    <span class="comment">//private final SortedMap&lt;Integer, String&gt; names;</span></span><br><span class="line">    <span class="comment">//存储了注解中给定的属性名</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">paramCount</span> <span class="operator">=</span> <span class="built_in">this</span>.names.size();</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span> &amp;&amp; paramCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有使用注解或者只有一个注解(f)</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> args[(Integer)<span class="built_in">this</span>.names.firstKey()];</span><br><span class="line">            <span class="keyword">return</span> wrapToMapIfCollection(value, <span class="built_in">this</span>.useActualParamName ? (String)<span class="built_in">this</span>.names.get(<span class="built_in">this</span>.names.firstKey()) : <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果使用了注解，创建一个新的map集合</span></span><br><span class="line">            Map&lt;String, Object&gt; param = <span class="keyword">new</span> <span class="title class_">ParamMap</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历names集合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.names.entrySet().iterator(); var5.hasNext(); ++i) &#123;</span><br><span class="line">                Entry&lt;Integer, String&gt; entry = (Entry)var5.next();</span><br><span class="line">                <span class="comment">//假设names集合中现在存储的是(0,&#x27;name&#x27;),args=[&quot;张三&quot;]</span></span><br><span class="line">                <span class="comment">//param中就会存储(&quot;name&quot;,&quot;张三&quot;)</span></span><br><span class="line">                param.put((String)entry.getValue(), args[(Integer)entry.getKey()]);</span><br><span class="line">                <span class="type">String</span> <span class="variable">genericParamName</span> <span class="operator">=</span> <span class="string">&quot;param&quot;</span> + (i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.names.containsValue(genericParamName)) &#123;</span><br><span class="line">                    <span class="comment">//这一步是生成通用属性名：(&quot;param1&quot;,&quot;张三&quot;)</span></span><br><span class="line">                    param.put(genericParamName, args[(Integer)entry.getKey()]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> param;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在Sql语句中</p><ul><li>当接口中方法的参数是单个且是基本数据类型时，可以直接使用#{}取出，且#{}内可以随意写</li><li>当接口中方法的参数是单个且是pojo类或map集合时，也可以使用#{}取出，但#{}内需要写对应的属性名或key值</li><li>当接口中方法的参数有多个且没有使用@Param注解时，也是使用#{}取出，但#{}内只能写arg0，arg1…或者param1,param2</li><li>当接口中方法的参数有多个且使用了@Param注解时，可以使用#{}取出也可以直接用注解指定的名字取出，但#{}内可以写注解指定的属性名</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--12.Mybatis小技巧</title>
      <link href="/2023/11/12/Mybatis%E5%AD%A6%E4%B9%A0--12.MyBatis%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/11/12/Mybatis%E5%AD%A6%E4%B9%A0--12.MyBatis%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis小技巧"><a href="#MyBatis小技巧" class="headerlink" title="MyBatis小技巧"></a>MyBatis小技巧</h4><ul><li><p>‘#{}’和’${}’</p><ul><li>两者均能用于sql语句中</li><li>‘#{}’：底层使用的是preparedStatement，先进行sql语句的编译，再给sql语句的？传值，可以避免sql注入</li><li>‘${}’：底层使用的是Statement，先对sql语句进行拼接，再对sql语句进行编译，存在sql注入的问题</li><li><strong>注意：#{}和${}用于sql语句中，非sql语句没有必要使用。</strong></li></ul></li><li><p>优先使用’#{}‘，避免sql注入的问题。</p></li><li><p>使用#{}取值时，取出来的值默认会带  ‘’ .</p></li><li><p>使用${}的情况</p><ul><li><p>将sql语句中的关键字进行传输，就要使用’${}’,比如根据用户指定的排序规则(asc，desc)进行数据查询。如果使用’#{asc}‘，那么在sql语句中出现的是’asc’，是一个字符串，而采用后者，会将参数直接拼接到sql语句上，那么出现的就是asc了。</p></li><li><p>批量删除</p><ul><li>批量删除的方法</li><li>delete from xxx where xx &#x3D; xx or xx &#x3D; xx；</li><li>delete from xxx where xx in(xx,xx,xx);</li><li>当使用第二种方法时，我们就可以通过${xx,xx,xx}将参数传入。</li></ul></li><li><p>模糊查询</p><ul><li>select * from xxx where xx like …</li><li>…号处可以用以下值替代</li><li>‘${xxx}’</li><li>“%”#{xxx}”%”</li><li>concat(‘%’,#{xxx},’%’)</li></ul></li></ul></li><li><p>别名</p><ul><li><p>我们可以在mybatis的核心配置文件中给某个类型起别名，可以使用该别名对所有使用该类型的地方进行替换</p></li><li><pre><code class="xml">&lt;typeAliases&gt;    &lt;!--type表示要起别名的类型 alia表示起的别名。该alias属性可以省略不写，这种情况下，该类型的别名就是这个类的简名。比如：com.deng.mybatis.pojo.Car的简名就是car，不区分大小写--&gt;    &lt;typeAlias type = &quot;&quot; alias=&quot;&quot;&gt;    &lt;!--还可以对包起别名，起了别名的包会自动对其内部的类起别名，别名就是这些类的简名，不区分大小写--&gt;    &lt;package name=&quot;com.deng.mybatis.pojo&quot;&gt;&lt;/typeAliases&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 所有别名不区分大小写，并且namespace不能使用别名。</span><br><span class="line"></span><br><span class="line">* mybatis-config.xml中的mapper标签</span><br><span class="line"></span><br><span class="line">  * mapper标签有3个属性，均用来指定sql配置文件的路径</span><br><span class="line"></span><br><span class="line">  * resource：从类的根路径下开始查找资源，sql配置文件必须放在类路径下</span><br><span class="line"></span><br><span class="line">  * url：以绝对路径的方式定位资源，可以将sql配置文件放在任意位置。使用file \ \ \ :+路径 格式，这种方式很少用，因为可移植性太差。 </span><br><span class="line"></span><br><span class="line">  * class：**value值为接口的全限定名(带包名的那种)。思考：这个属性的作用是用来关联mapper.xml文件的，提供接口的全限定名有什么用？表示从该接口所在的包下查找mapper.xml文件，在这种情况下，sql配置文件必须位于接口所在的包下并且名称要和接口名对应。因此我们也可以使用别名技巧，自动给接口起别名**</span><br><span class="line"></span><br><span class="line">    * ```xml</span><br><span class="line">          &lt;mappers&gt;</span><br><span class="line">      &lt;!--        &lt;mapper class=&quot;com.deng.mybatis.mapper.CarMapper&quot;&gt;&lt;/mapper&gt;--&gt;</span><br><span class="line">              &lt;package name=&quot;com.deng.mybatis.mapper&quot;/&gt;</span><br><span class="line">          &lt;/mappers&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>注意：在IDEA中resources和java中创建的文件都位于类的根路径下。如果想要在resources下创建多级目录，必须按照com&#x2F;deng&#x2F;mybatis的方式，而不是com.deng.mybatis。后者是创建包的方法，而只能在java中创建包。</p></li><li><p>插入语句时使用自动生成的主键</p><ul><li><pre><code class="xml">&lt;!--只需在sql配置文件的insert标签中添加以下属性即可。useGeneratedKey=&quot;true&quot;表示需要使用自动生成的主键。keyProperty属性表示将生成的主键封装--&gt;&lt;insert id=&quot;&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    ...&lt;/insert&gt;</code></pre></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--11.动态代理生成实现某个接口的对象</title>
      <link href="/2023/11/10/MyBatis%E5%AD%A6%E4%B9%A0--11.MyBatis%E4%B8%AD%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB/"/>
      <url>/2023/11/10/MyBatis%E5%AD%A6%E4%B9%A0--11.MyBatis%E4%B8%AD%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis中通过动态代理生成实现接口的对象"><a href="#MyBatis中通过动态代理生成实现接口的对象" class="headerlink" title="MyBatis中通过动态代理生成实现接口的对象"></a>MyBatis中通过动态代理生成实现接口的对象</h4><ul><li><p>在mybatis中对javassist进行了二次封装，即可以在mybatis中使用javassist</p></li><li><p>经过我们的改造，我们的dao层的AccountDaoImpl类已经变成了以下模样</p><ul><li><pre><code class="java">package com.deng.bank.dao.impl;import com.deng.bank.dao.AccountDao;import com.deng.bank.pojo.Account;import com.deng.bank.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;public class AccountDaoIm implements AccountDao &#123;    public Account select(String actno)&#123;        SqlSession sqlSession = SqlSessionUtil.getSqlSession();        Account act = (Account)sqlSession.selectOne(&quot;account.selectByActno&quot;, actno);        return act;    &#125;    public int update(Account act)&#123;        SqlSession sqlSession = SqlSessionUtil.getSqlSession();        int update = sqlSession.update(&quot;account.updateByActno&quot;, act);        return update;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 可以发现，每个方法都有一行固定的代码，且其他代码也非常固定(CRUD)。那么我们能不能不编写该类，而是使用javassist帮我们动态生成呢，答案是可以的，并且在mybatis中已经实现了，为了加深理解，我们先手写底层逻辑</span><br><span class="line"></span><br><span class="line">  * 用户需要将接口作为参数传入</span><br><span class="line">  * 获得类池对象，并使用该对象动态生成要返回的类，以及接口，并让该类实现该接口</span><br><span class="line">  * 获取接口内的所有方法，并实现。具体过程</span><br><span class="line">    * 拼接方法：创建一个StringBuilder对象，先将方法的框架拼接出来</span><br><span class="line">    * 再拼接方法内容。那行重复的代码可以直接拼接。后面的代码需要通过sqlid来确定，因此我们还需要用户将SqlSession作为参数传入。</span><br><span class="line">    * 关键：由于SqlId是由用户编写的，可变性太大，不利于框架开发者开发，因此开发者规定：Mapper文件中的namespace必须为接口的全限定名，SqlId必须为方法名。否则无法使用该动态代理生成方法。</span><br><span class="line">  * 将类加入内存并实例化</span><br><span class="line">  * 最后返回该类</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  package com.deng.bank.utils;</span><br><span class="line">  </span><br><span class="line">  import com.deng.bank.pojo.Account;</span><br><span class="line">  import org.apache.ibatis.javassist.CannotCompileException;</span><br><span class="line">  import org.apache.ibatis.javassist.ClassPool;</span><br><span class="line">  import org.apache.ibatis.javassist.CtClass;</span><br><span class="line">  import org.apache.ibatis.javassist.CtMethod;</span><br><span class="line">  import org.apache.ibatis.mapping.MappedStatement;</span><br><span class="line">  import org.apache.ibatis.mapping.SqlCommandType;</span><br><span class="line">  import org.apache.ibatis.session.SqlSession;</span><br><span class="line">  </span><br><span class="line">  import java.lang.reflect.Method;</span><br><span class="line">  import java.util.Arrays;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * author:dch</span><br><span class="line">   * this class is used to generate the object that implement the DAO&#x27;s Interface</span><br><span class="line">   */</span><br><span class="line">  public class GenerateDaoProxy &#123;</span><br><span class="line">      public Object Generate(SqlSession sqlSession, Class AccountDao)&#123;</span><br><span class="line">          ClassPool pool = ClassPool.getDefault();</span><br><span class="line">          CtClass ctClass = pool.makeClass(AccountDao.getName() + &quot;Proxy&quot;);</span><br><span class="line">          CtClass anInterface = pool.makeInterface(AccountDao.getName());</span><br><span class="line">          ctClass.addInterface(anInterface);</span><br><span class="line">          //implement the functions</span><br><span class="line">          Method[] methods = AccountDao.getDeclaredMethods();</span><br><span class="line">          Arrays.stream(methods).forEach(method -&gt; &#123;</span><br><span class="line">              StringBuilder methodCode = new StringBuilder();</span><br><span class="line">              //public void delete(int a,int b)&#123;...&#125;;</span><br><span class="line">              methodCode.append(&quot;public &quot;);</span><br><span class="line">              methodCode.append(method.getReturnType().getName() + &quot; &quot;);</span><br><span class="line">              methodCode.append(method.getName() + &quot; &quot;);</span><br><span class="line">              methodCode.append(&quot;(&quot;);</span><br><span class="line">              Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">              for (int i = 0; i &lt; types.length; i++) &#123;</span><br><span class="line">                  methodCode.append(types[i] + &quot;arg&quot; + i);</span><br><span class="line">                  if(i != types.length - 1)&#123;</span><br><span class="line">                      methodCode.append(&quot;,&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              methodCode.append(&quot;)&#123;&quot;);</span><br><span class="line">              //SqlSession sqlSession = SqlSessionUtil.getSqlSession();</span><br><span class="line">              methodCode.append(&quot;org.apache.ibatis.session.SqlSession sqlSession = com.deng.bank.utils.SqlSessionUtil.getSqlSessioni();&quot;);</span><br><span class="line">              String SqlId = AccountDao.getName() + &quot;.&quot; + method.getName();</span><br><span class="line">              SqlCommandType sqlCommandType = sqlSession.getConfiguration().getMappedStatement(SqlId).getSqlCommandType();</span><br><span class="line">              if(sqlCommandType == SqlCommandType.DELETE)&#123;</span><br><span class="line">  </span><br><span class="line">              &#125;else if(sqlCommandType == SqlCommandType.INSERT)&#123;</span><br><span class="line">  </span><br><span class="line">              &#125;else if(sqlCommandType == SqlCommandType.SELECT)&#123;</span><br><span class="line">                  methodCode.append(&quot;return sqlSession.selectOne(\&quot;&quot;+SqlId+&quot;\&quot;,arg0);&quot;);</span><br><span class="line">              &#125;else if(sqlCommandType == SqlCommandType.UPDATE)&#123;</span><br><span class="line">                  methodCode.append(&quot;return sqlSession.update(\&quot;&quot;+SqlId+&quot;\&quot;,arg0);&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              methodCode.append(&quot;&#125;&quot;);</span><br><span class="line">              try &#123;</span><br><span class="line">                  CtMethod ctMethod = CtMethod.make(methodCode.toString(), ctClass);</span><br><span class="line">                  ctClass.addMethod(ctMethod);</span><br><span class="line">              &#125; catch (CannotCompileException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          //put the class to internal storage and instantiation</span><br><span class="line">          Object o = null;</span><br><span class="line">          try &#123;</span><br><span class="line">              o = ctClass.toClass().newInstance();</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          return o;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--10.利用javassist动态生成类</title>
      <link href="/2023/11/09/Mybatis%E5%AD%A6%E4%B9%A0--10.%E5%88%A9%E7%94%A8javassist%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%B1%BB/"/>
      <url>/2023/11/09/Mybatis%E5%AD%A6%E4%B9%A0--10.%E5%88%A9%E7%94%A8javassist%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="利用javassist动态生成类"><a href="#利用javassist动态生成类" class="headerlink" title="利用javassist动态生成类"></a>利用javassist动态生成类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.javaSsist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javassistTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerateFirstClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//get the class pool</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//make a class;</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.deng.bank.dao.impl.AccountDaoIml&quot;</span>);</span><br><span class="line">        <span class="comment">//make a function</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodCode</span> <span class="operator">=</span> <span class="string">&quot;public void insert()&#123;System.out.println(123);&#125;&quot;</span>;</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> CtMethod.make(methodCode, ctClass);</span><br><span class="line">        ctClass.addMethod(method);</span><br><span class="line">        <span class="comment">//在内存中生成该类</span></span><br><span class="line">        ctClass.toClass();</span><br><span class="line">        <span class="comment">//use reflect to instance the object</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.deng.bank.dao.impl.AccountDaoIml&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">insert</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;insert&quot;</span>);</span><br><span class="line">        <span class="comment">//call the function</span></span><br><span class="line">        insert.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="利用javassist动态生成类并实现接口中方法"><a href="#利用javassist动态生成类并实现接口中方法" class="headerlink" title="利用javassist动态生成类并实现接口中方法"></a>利用javassist动态生成类并实现接口中方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerateInterface</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.deng.bank.dao.impl.AccountDaoIml&quot;</span>);</span><br><span class="line">    <span class="comment">//generate the interface</span></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">anInterface</span> <span class="operator">=</span> pool.makeInterface(<span class="string">&quot;com.deng.bank.dao.AccountDao&quot;</span>);</span><br><span class="line">    <span class="comment">//let the class implements the interface</span></span><br><span class="line">    ctClass.addInterface(anInterface);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methCode</span> <span class="operator">=</span> <span class="string">&quot;public void delete()&#123;System.out.println(\&quot;hello world\&quot;);&#125;&quot;</span>;</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> CtMethod.make(methCode, ctClass);</span><br><span class="line">    ctClass.addMethod(method);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; aClass = ctClass.toClass();</span><br><span class="line">    <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> (AccountDao) aClass.newInstance();</span><br><span class="line">    accountDao.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--9.Web项目中使用Mybatis</title>
      <link href="/2023/11/08/Mybatis%E5%AD%A6%E4%B9%A0--9.%E5%9C%A8WEB%E4%B8%AD%E5%BA%94%E7%94%A8MyBatis/"/>
      <url>/2023/11/08/Mybatis%E5%AD%A6%E4%B9%A0--9.%E5%9C%A8WEB%E4%B8%AD%E5%BA%94%E7%94%A8MyBatis/</url>
      
        <content type="html"><![CDATA[<h4 id="在WEB项目中使用MyBatis-以银行转账业务为例"><a href="#在WEB项目中使用MyBatis-以银行转账业务为例" class="headerlink" title="在WEB项目中使用MyBatis(以银行转账业务为例)"></a>在WEB项目中使用MyBatis(以银行转账业务为例)</h4><ul><li><p>使用maven新建项目，在pom文件中将打包方式改为war，并重载(reload)项目。在pom文件中引入相关依赖</p><p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0--9.%E5%9C%A8WEB%E4%B8%AD%E5%BA%94%E7%94%A8MyBatis/image-20231109103620253.png"></p></li><li><p>编写mybatis配置文件及logback配置文件：mybatis-config.xml,XxxMapper.xml,logback.xml</p></li><li><p>右键项目，找到openMouduleSettings。双击红色路径，这一步是在项目中引入web框架</p><ul><li><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0--9.%E5%9C%A8WEB%E4%B8%AD%E5%BA%94%E7%94%A8MyBatis/image-20231109103744017.png"></li></ul></li><li><p>在webapp目录下新建一个html文件(当作欢迎页使用)，编写前端代码。项目逻辑：从前往后</p></li><li><p>编写后端代码</p></li><li><p>采用三层架构</p></li><li><p>建包：web(表现层)、service(业务层)、dao(可持久层)、util(工具包)、exceptions(异常包)、pojo(javaBean)</p><ul><li><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0--9.%E5%9C%A8WEB%E4%B8%AD%E5%BA%94%E7%94%A8MyBatis/image-20231109104011025.png"></li></ul></li><li><p>在web包下创建Servlet类，接收前端用户提交的数据，并调用相关业务方法。于此同时，编写pojo类</p><ul><li><pre><code class="java">package com.deng.bank.web;import com.deng.bank.exceptions.moneyNotEnoughException;import com.deng.bank.exceptions.transferException;import com.deng.bank.service.AccountService;import com.deng.bank.service.impl.AccountServiceIm;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/transfer&quot;)public class AccountServlet extends HttpServlet &#123;    public void doPost(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException &#123;        //get data from page        String fromActno = request.getParameter(&quot;fromActno&quot;);        String toActno = request.getParameter(&quot;toActno&quot;);        Double money = Double.parseDouble(request.getParameter(&quot;money&quot;));        AccountService accountService = new AccountServiceIm();        try &#123;            accountService.transfer(fromActno,toActno,money);            response.sendRedirect(request.getContextPath() + &quot;/Success.html&quot;);        &#125; catch (moneyNotEnoughException e) &#123;            response.sendRedirect(request.getContextPath() + &quot;/Error1.html&quot;);        &#125; catch (transferException e) &#123;            response.sendRedirect(request.getContextPath() + &quot;/Error2.html&quot;);        &#125;catch(Exception e)&#123;            response.sendRedirect(request.getContextPath() + &quot;/Error2.html&quot;);        &#125;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 层与层之间通过接口交互。在service包和dao包下建立接口，并创建相应的子类实现该接口</span><br><span class="line"></span><br><span class="line">  * ![](../../../笔记/MyBatis/9.在WEB中应用MyBatis.assets/image-20231109104834245.png)</span><br><span class="line"></span><br><span class="line">* 业务层调用dao层接口获取数据库连接，进行相应业务逻辑代码的编写</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    package com.deng.bank.service.impl;</span><br><span class="line">    </span><br><span class="line">    import com.deng.bank.dao.AccountDao;</span><br><span class="line">    import com.deng.bank.dao.impl.AccountDaoIm;</span><br><span class="line">    import com.deng.bank.exceptions.moneyNotEnoughException;</span><br><span class="line">    import com.deng.bank.exceptions.transferException;</span><br><span class="line">    import com.deng.bank.pojo.Account;</span><br><span class="line">    import com.deng.bank.service.AccountService;</span><br><span class="line">    import com.deng.bank.utils.SqlSessionUtil;</span><br><span class="line">    import org.apache.ibatis.session.SqlSession;</span><br><span class="line">    </span><br><span class="line">    public class AccountServiceIm implements AccountService &#123;</span><br><span class="line">        private AccountDao accountDao = new AccountDaoIm();</span><br><span class="line">    </span><br><span class="line">        public void transfer(String fromActno,String toActno,Double money) throws moneyNotEnoughException, transferException &#123;</span><br><span class="line">            SqlSession sqlSession = SqlSessionUtil.getSqlSession();</span><br><span class="line">            Account fromAct = accountDao.select(fromActno);</span><br><span class="line">            if(fromAct.getBalance() &lt; money)&#123;</span><br><span class="line">                throw new moneyNotEnoughException(&quot;余额不足&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                Account toAct = (Account)accountDao.select(toActno);</span><br><span class="line">                fromAct.setMoney(fromAct.getBalance() - money);</span><br><span class="line">                toAct.setMoney(toAct.getBalance() + money);</span><br><span class="line">                int count = accountDao.update(fromAct);</span><br><span class="line">                String str = null;</span><br><span class="line">                str.toString();</span><br><span class="line">                count += accountDao.update(toAct);</span><br><span class="line">                if(count != 2)&#123;</span><br><span class="line">                    throw new transferException(&quot;转账失败，未知错误&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                sqlSession.commit();</span><br><span class="line">            &#125;</span><br><span class="line">            SqlSessionUtil.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>如果我们在dao层进行事务管理，那么当业务层25-26行出现类似情况的异常时，本来应该终止转账，但由于我们将事务设置在dao层，那么fromAct账户的金额会发生改变，而toAct账户的金额却不会改变，相当于有一笔钱不翼而飞，这对银行来说是致命的错误。因此我们需要将事务管理设置在业务层。我们之前的做法是：每执行一次数据库CRUD操作就需要创建一个SqlSession对象，这显然无法做到原子性。</p></li><li><p>因此我们引入ThreadLocal对象，将SqlSession对象和当前线程绑定，从而实现事务的原子性</p><ul><li><pre><code class="java">package com.deng.bank.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;public class SqlSessionUtil &#123;    private static SqlSessionFactory sqlSessionFactory;    static&#123;        try &#123;            sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    private static ThreadLocal&lt;SqlSession&gt; local = new ThreadLocal&lt;&gt;();    public static SqlSession getSqlSession()&#123;        SqlSession sqlSession = local.get();        if(sqlSession == null)&#123;            sqlSessionFactory.openSession();        &#125;        return sqlSession;    &#125;    public static void close()&#123;        SqlSession sqlSession = local.get();        if (sqlSession!=null) &#123;            sqlSession.close();            local.remove();        &#125;    &#125;&#125;</code></pre></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--7.解析Mybatis配置文件</title>
      <link href="/2023/11/07/Mybatis%E5%AD%A6%E4%B9%A0--7.%E5%88%A9%E7%94%A8dom4j%E8%A7%A3%E6%9E%90MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2023/11/07/Mybatis%E5%AD%A6%E4%B9%A0--7.%E5%88%A9%E7%94%A8dom4j%E8%A7%A3%E6%9E%90MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="解析MyBatis配置文件"><a href="#解析MyBatis配置文件" class="headerlink" title="解析MyBatis配置文件"></a>解析MyBatis配置文件</h4><p>#####解析核心配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.testmybatisxml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParseXmlByDom4jTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMybatisXmlConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取SAXReader 对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">//获取mybatis-config.xml文件对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(is);</span><br><span class="line">        <span class="comment">//获取文件的根标签</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rootName</span> <span class="operator">=</span> rootElement.getName();</span><br><span class="line">        System.out.println(rootName);<span class="comment">//configuration</span></span><br><span class="line">        <span class="comment">//获取根标签内部的单个子标签，通过路径定位标签</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xpath</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + rootName + <span class="string">&quot;/environments&quot;</span>;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">environments</span> <span class="operator">=</span> (Element)document.selectSingleNode(xpath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">environmentsName</span> <span class="operator">=</span> environments.getName();</span><br><span class="line">        System.out.println(environmentsName);<span class="comment">//environments</span></span><br><span class="line">        <span class="comment">//获得environments的default属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Default</span> <span class="operator">=</span> environments.attributeValue(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        System.out.println(Default);<span class="comment">//development</span></span><br><span class="line">        <span class="comment">//根据defaults获取environments中对应的environment标签</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xpath1</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + rootName + <span class="string">&quot;/&quot;</span> + environmentsName +</span><br><span class="line">                <span class="string">&quot;/environment[@id=&#x27;&quot;</span>+Default+<span class="string">&quot;&#x27;]&quot;</span>;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">environment</span> <span class="operator">=</span> (Element)document.selectSingleNode(xpath1);</span><br><span class="line">        <span class="comment">//获取environment标签中的子标签</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">transcationManager</span> <span class="operator">=</span> environment.element(<span class="string">&quot;transactionManager&quot;</span>);</span><br><span class="line">        System.out.println(transcationManager.getName());<span class="comment">//transactionManager</span></span><br><span class="line">        <span class="comment">//获得其属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> transcationManager.attributeValue(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        System.out.println(type);<span class="comment">//JDBC</span></span><br><span class="line">        <span class="comment">//不想从根标签下获得其子标签</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xpath2</span> <span class="operator">=</span> <span class="string">&quot;//mappers&quot;</span>;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">mappers</span> <span class="operator">=</span> (Element) document.selectSingleNode(xpath2);</span><br><span class="line">        System.out.println(mappers.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可通过 父标签.element(&quot;子标签名&quot;);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--6.Mybatis核心配置文件</title>
      <link href="/2023/11/06/Mybatis%E5%AD%A6%E4%B9%A0--6.MyBatis%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2023/11/06/Mybatis%E5%AD%A6%E4%B9%A0--6.MyBatis%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis核心配置文件"><a href="#MyBatis核心配置文件" class="headerlink" title="MyBatis核心配置文件"></a>MyBatis核心配置文件</h4><ul><li><p>environments标签</p><ul><li><p>配置mybatis环境的标签</p></li><li><p>在该标签体中可以配置mybatis的多个环境，一个环境就对应一个数据库，也就对应一个SqlSessionFactory对象</p></li><li><p>default属性。用来指定默认环境，也就是说在不指定环境的情况下，创建的SqlSessionFactory对象对应的是默认环境中的数据库。那么也就是说我们可以在创建SqlSessionFactory的时候指定其对应的环境(数据库)。</p></li><li><p>transactionManager标签：mybatis的事务管理器。有两种值</p><ul><li>jdbc：mybatis负责管理事务，其底层采用jdbc事务管理机制</li><li>managed：mybatis不负责管理事务，交给其他容器(Spring)来管理</li><li>mybatis底层提供了transcation接口来管理事务。如果选择jdbc，则会实例化JdbcTranscation对象；如果选择managed，则会实例化ManagedTranscation对象</li></ul></li><li><p>dataSource标签：数据源。为程序提供Connection对象。实际上，dataSource是一套规范，凡是为程序提供Connection对象的，都叫数据源。这套规范是JDK提供的，我们也能写数据源组件，只要实现javax.sql.DataSource接口中的所有方法即可。数据库连接池就是一个数据源(提供了Connection对象)</p><ul><li>常见的数据源(数据库连接池)组件：druid、c3p0、dbcp等</li><li>type属性：指定数据源的类型，即使用什么方法获得Connection对象</li><li>type属性有3个值<ul><li>UNPOOLED：不使用数据库连接池，也就是说每进行一次数据库连接，都创建一个新的Connection对象</li><li>POOLED：使用mybatis自己提供的数据库连接池</li><li>JNDI：集成第三方的数据库连接池。它其实是一套规范，大部分web服务器都实现了这套规范，因此可以在web容器中配置三方数据库连接池，那么mybatis中使用的就是web容器中集成的三方数据库连接池</li></ul></li><li>配置具体的数据库连接池参数标签：property。需要根据业务场景进行设置合适的参数，可以设置连接池最大连接数，空闲数等</li></ul></li></ul></li><li><p>properties标签：相当于一个Map集合，key和value都是String类型。可以在该标签体内配置很多配置信息</p><ul><li><pre><code class="xml">&lt;properties&gt;    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&lt;/properties&gt;&lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db01&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;dch&quot;/&gt;                &lt;!--配置连接池最大连接数为5--&gt;                &lt;property name=&quot;poolMaximumActiveConnections&quot; value=&quot;5&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;</code></pre></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--5.使用Mybatis进行CRUD</title>
      <link href="/2023/11/03/Mybatis%E5%AD%A6%E4%B9%A0--5.%E4%BD%BF%E7%94%A8MyBatis%E8%BF%9B%E8%A1%8CCRUD/"/>
      <url>/2023/11/03/Mybatis%E5%AD%A6%E4%B9%A0--5.%E4%BD%BF%E7%94%A8MyBatis%E8%BF%9B%E8%A1%8CCRUD/</url>
      
        <content type="html"><![CDATA[<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>使用maven创建工程</p></li><li><p>引入依赖：mybatis依赖、mysql-connector依赖，junit依赖，logback依赖</p></li><li><p>编写核心配置文件：mybatis-config.xml，并放在resource根路径下</p></li><li><p>创建XxxMapper.xml文件，在其中编写sql语句</p><ul><li><pre><code class="xml">&lt;insert id=&quot;insertCar&quot;&gt;        insert into t_car values(null,#&#123;car_num&#125;,#&#123;brand&#125;,#&#123;guide_price&#125;,#&#123;produce_time&#125;,#&#123;car_type&#125;);    &lt;/insert&gt;    &lt;delete id=&quot;deleteById&quot;&gt;        delete from t_car where id = #&#123;id&#125;;    &lt;/delete&gt;    &lt;update id=&quot;updateById&quot;&gt;        update t_car set guide_price = #&#123;guide_price&#125; where id = #&#123;id&#125;;    &lt;/update&gt;#&#123;&#125;里写属性名(和EL表达式用法类似，通过get方法查找)或map的key值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 为了方便，编写一个MyBatis工具类</span><br><span class="line"></span><br><span class="line">6. 创建一个java类，通过工具类获得SqlSession对象，通过SqlSession对象执行CRUD操作</span><br><span class="line"></span><br><span class="line">   1. 通过map集合传入参数</span><br><span class="line"></span><br><span class="line">      * ```java</span><br><span class="line">          public void testInsert()&#123;</span><br><span class="line">                SqlSession sqlSession = SqlSessionUtil.getSqlSession();</span><br><span class="line">          </span><br><span class="line">                Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;car_num&quot;,1004);</span><br><span class="line">                map.put(&quot;brand&quot;,&quot;比亚迪&quot;);</span><br><span class="line">                map.put(&quot;guide_price&quot;,10);</span><br><span class="line">                map.put(&quot;produce_time&quot;,2023-11-11);</span><br><span class="line">                map.put(&quot;car_type&quot;,&quot;新能源&quot;);</span><br><span class="line">          </span><br><span class="line">                int count = sqlSession.insert(&quot;insertCar&quot;, map);</span><br><span class="line">                System.out.println(count);</span><br><span class="line">          </span><br><span class="line">                sqlSession.commit();</span><br><span class="line">                sqlSession.close();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><ol start="2"><li><p>通过pojo对象传入参数</p><ol><li><pre><code class="java">Car car = new Car(null,&quot;1004&quot;,&quot;BYD&quot;,&quot;10&quot;,&quot;2022-11-11&quot;,&quot;新能源&quot;);sqlSession.insert(&quot;insertCar&quot;,car);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      2. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 查询语句：</span><br><span class="line"></span><br><span class="line">  * mybatis底层是将查询到的结果封装成一个对象放入结果集中，所以我们需要告诉mybatis将查询到的结果封装为哪个java对象。可以通过select标签中的resultType属性进行设置</span><br><span class="line"></span><br><span class="line">    * ```xml</span><br><span class="line">          &lt;select id=&quot;selectById&quot; resultType=&quot;&quot;&gt;&lt;/select&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol></li></ol><ul><li>需要注意的是，在编写查询的sql语句时，由于其底层是将查询到的结果封装为指定的java对象，所以需要保证查询的列名和对象属性名一致，可以使用as语法替换列名</li></ul><h5 id="XxxMapper-xml文件中的namespace"><a href="#XxxMapper-xml文件中的namespace" class="headerlink" title="XxxMapper.xml文件中的namespace"></a>XxxMapper.xml文件中的namespace</h5><ul><li>该属性是用来指定命名空间的，其作用为防止sql语句的ID冲突</li><li>在mybatis中是根据namespace.id来执行相应的sql语句</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--4.Mybatis集成日志文件</title>
      <link href="/2023/11/02/Mybatis%E5%AD%A6%E4%B9%A0--4.MyBatis%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
      <url>/2023/11/02/Mybatis%E5%AD%A6%E4%B9%A0--4.MyBatis%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis集成日志文件"><a href="#MyBatis集成日志文件" class="headerlink" title="MyBatis集成日志文件"></a>MyBatis集成日志文件</h4><ul><li><p>有了MyBatis集成日志文件，可以让我们调试起来更加方便</p></li><li><p>常见的集成日志组件</p><ul><li>SLF4J</li><li>LOG4J</li><li>LOG4J2</li><li>STDOUT_LOGGING</li><li>…</li></ul></li><li><p>其中STDOUT_LOGGING是标准日志，MyBatis框架已经实现了这种标准，我们只需开启即可。在mybatis-config.xml文件中配置如下代码</p><ul><li><pre><code class="xml">&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;该配置信息需要在evrionments前</code></pre></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--3.Mybatis事务管理机制</title>
      <link href="/2023/11/02/Mybatis%E5%AD%A6%E4%B9%A0--3.%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90MyBatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/11/02/Mybatis%E5%AD%A6%E4%B9%A0--3.%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90MyBatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="Mybatis事务管理机制"><a href="#Mybatis事务管理机制" class="headerlink" title="Mybatis事务管理机制"></a>Mybatis事务管理机制</h4><ul><li><p>我们在mybatis入门程序中可以发现，在编写完sql语句后，我们必须手动提交事务，否则数据库表并不会更新该数据</p></li><li><p>在mybatis-config.xml文件中可通过如下配置进行事务管理</p><ul><li><pre><code class="xml">&lt;transactionManager type=&quot;JDBC&quot;/&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* type属性有两种value</span><br><span class="line"></span><br><span class="line">  * JDBC(jdbc)</span><br><span class="line">  * MANAGED(managed)</span><br><span class="line"></span><br><span class="line">* 当value是jdbc时，表示MyBatis框架自己管理事务，底层采用的是原生的jdbc机制：在执行sql语句之前开启事务：conn.setAutoCommit(&quot;false&quot;);在执行sqlSession.commit();时底层执行conn.commit();</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">            SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    //该语句的底层源码分析</span><br><span class="line">    //当程序执行该语句时，底层会执行</span><br><span class="line">       public SqlSession openSession() &#123;</span><br><span class="line">      return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, false);</span><br><span class="line">        &#125;</span><br><span class="line">    /*    public SqlSession openSession(boolean autoCommit) &#123;</span><br><span class="line">            return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, autoCommit);</span><br><span class="line">        &#125;*/</span><br><span class="line">    //也就是说它会调用另一个openSessionFromDataSource方法，并且重载了该方法，根据传递的参数不同会调用相应的方法。</span><br><span class="line">    //该方法的参数含义：第一个参数应该和配置信息相关，第二个参数是事务隔离级别，第三个参数是是否开启事务</span><br><span class="line">    </span><br><span class="line">    //底层所执行的代码</span><br><span class="line">        TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">                tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    //很显然，其底层采用了工厂设计模式。先得到TransactionFactory对象，再通过该对象得到Transaction对象，此时autoCommit=false</span><br><span class="line">     public Transaction newTransaction(DataSource ds, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">            return new JdbcTransaction(ds, level, autoCommit, this.skipSetAutoCommitOnClose);</span><br><span class="line">        &#125;</span><br><span class="line">    //通过以上代码可知，返回的是一个jdbc事务(t)</span><br><span class="line">    //调用openConnction()方法</span><br><span class="line">        protected void openConnection() throws SQLException &#123;</span><br><span class="line">            this.setDesiredAutoCommit(this.autoCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    //调用setDesiredAutoCommit(Boolean boolean)方法</span><br><span class="line">        protected void setDesiredAutoCommit(boolean desiredAutoCommit) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //在jdbc中connection.getAutoCommit()默认是等于true的</span><br><span class="line">                if (this.connection.getAutoCommit() != desiredAutoCommit) &#123;</span><br><span class="line">                    //由于desiredAutoCommit为false，所以执行该语句，开启事务</span><br><span class="line">                    this.connection.setAutoCommit(desiredAutoCommit);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">            &#125; catch (SQLException var3) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>* 通过源码分析可得：如果我们采用SqlSessionFactory.openSsion(true);来获得SqlSession，那么是不开启事务的，默认是自动提交语句的。也就是说不需要SqlSession.commit，但是不建议这样做。</code></pre></li><li><p>当value是managed时，表示MyBatis不管理事务，而是交给其他容器比如Spring来管理事务。目前来说MyBatis不管理事务就意味着没人管理事务，也就是没开启事务，即自动提交DML。</p></li></ul></li><li><p>总结：只要MyBatis中autoCommit值为true，表示不开启事务</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--2.入门程序</title>
      <link href="/2023/11/02/Mybatis%E5%AD%A6%E4%B9%A0--2.%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/11/02/Mybatis%E5%AD%A6%E4%B9%A0--2.%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>设置打包方式：<packaging>jar</packaging></p></li><li><p>引入依赖，使用maven引入MyBatis框架(其实就是jar包)和数据库驱动jar包(jdbc)</p></li><li><p>创建核心配置文件，复制配置信息到该文件，并且修改连接数据库的信息</p></li><li><p>创建XxxMapper.xml文件。并在其中编写SQL语句。每条SQL语句都有一个唯一标识符id&#x3D;”…”</p></li><li><p>在mybatis-config.xml的mappers中指定XxxMappser.xml的路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;carMapper.xml&quot;</span>/&gt;</span>//从类路径中加载资源</span><br><span class="line"><span class="comment">&lt;!--该mapper还有另外一个属性：url。该属性值有固定写法：url=&quot;file:/// + 绝对路径&quot;</span></span><br><span class="line"><span class="comment">但不建议使用该方法，因为移植性太差。当从windows系统移植到mac或linux系统时，后两者的系统中没有磁盘的概念，那么这种写法就会报错--&gt;</span></span><br></pre></td></tr></table></figure><p>该resource属性会自动从项目根路径下开始查找资源。因为我们将carMapper.xml文件放在resources文件中，等同于放到了根路径下</p></li><li><p>编写MyBatis程序。MyBatis中有一个负责执行SQL语句的对象：SqlSession，该对象表示的是java程序和数据库之间的一次会话。获得SqlSession的过程：</p><p>SqlSessionFactoryBuilder –&gt; SqlSessionFactory –&gt; SqlSession</p><p>一般一个数据库对应一个SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.mybatis.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//get the SqlSessionFactorBuilder</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">//get the SqlSessionFactor</span></span><br><span class="line">        <span class="comment">//该方法默认从根路径下查找资源</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//get the SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//execute the sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sqlSession.insert(<span class="string">&quot;insertCar&quot;</span>);</span><br><span class="line">        <span class="comment">//commit</span></span><br><span class="line">        <span class="comment">//mybatis中默认情况下是开启事务的，在执行DML语句时需要s</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>MyBatis中有两种重要的xml文件</p><ol><li>mybatis-config.xml。不一定必须是这个名字该配置文件用于配置连接数据库的信息，只有一个</li><li>XxxMapper.xml。该配置文件用于编写SQL语句。一般是一个表对应一个Mapper.xml文件，所以有多个</li></ol></li><li><p>小技巧：</p><ol><li><p>在一些有Resource的方法且需要传递路径时，一般是从根路径下开始查找资源</p></li><li><p>另一种获得输入流的方法：</p><ol><li><pre><code class="java">InputStream is = ClassLoader.getSystemLoader().getResourceAsStream(&quot;path&quot;);//这也是Resources.getRescourceAsStream(&quot;path&quot;)的底层实现源码</code></pre></li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习--1.概述</title>
      <link href="/2023/10/30/Mybatis%E5%AD%A6%E4%B9%A0--1.%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/30/Mybatis%E5%AD%A6%E4%B9%A0--1.%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis概述"><a href="#MyBatis概述" class="headerlink" title="MyBatis概述"></a>MyBatis概述</h4><h5 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h5><ul><li>MyBatis是项目开发中比较常用的框架之一</li><li>所谓框架就是对通用代码进行封装，其提供了很多类和接口。我们在开发项目时，可以直接使用这些类和接口(框架引入)，从而大大提高开发效率</li><li>框架一般都以jar包的形式存在，jar包中包含一些class文件及配置文件</li><li>MyBatis位于三层架构中的持久层，内部封装了jdbc，用于操作数据库</li><li>其他常用的持久层框架<ul><li>Hibernate</li><li>jOOQ</li><li>Guzz</li><li>….</li></ul></li><li>JDBC的不足<ul><li>sql语句写在java代码中，不利于后期扩展。比如某个表的字段发生了改变，我们需要修改项目源代码，这违反了OPC原则</li><li>有很多sql语句是重复的。比如说插入数据以及查询数据。我们需要不断通过PrepareStatement进行数据插入，以及遍历ResultSet获得查询结果，一旦表的字段非常多，这些sql语句将是多而重复的，开发效率低。</li></ul></li></ul><h4 id="了解MyBatis"><a href="#了解MyBatis" class="headerlink" title="了解MyBatis"></a>了解MyBatis</h4><ul><li>MyBatis本质上是对Jdbc的封装，通过MyBatis完成CRUD操作</li><li>MyBatis位于三层架构中的持久层，属于持久层框架</li><li>MyBatis提供的框架有SQL Maps和DAO</li></ul><h5 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h5><ul><li>ORM是Object Relational Mapping的缩写，译为对象关系映射</li><li>OM：我们可以发现数据库中的一张表类似于java中的一个类，而表中的数据类似于该类的对象，即表可以映射为一个类，表项可以映射为一个对象</li><li>R：要求表的字段是和表有关系的，比如user表，其字段有id、name、age等，字段都是和表有关系的</li><li>MyBatis就是一个ORM框架，可以将Java对象对应数据库表中的表项</li><li>MyBatis是一个半自动化ORM框架，需要程序员手动编写SQL语句。Hibernate是一个自动化ORM框架，不需要程序员手动编写SQL语句</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
