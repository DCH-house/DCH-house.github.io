<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>短链接--用户信息脱敏展示</title>
      <link href="/2024/03/08/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B1%95%E7%A4%BA/"/>
      <url>/2024/03/08/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>​针对用户中的一些敏感信息，不能不展示，因为有时候需要用到这些数据，但又不能完全展示，因为可能会暴露用户的隐私(比如手机号，身份证号等信息)，因此需要对这些数据进行脱敏处理，即只展示数据的部分信息，其余部分用特殊字符表示。</p><p>​本项目中使用的是自定义Json序列化的方式，在SpringMVC中当用户信息返回给浏览器时默认会使用Jackson进行序列化，我们只需要改变此处的序列化方式就能达到给用户信息脱敏的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.deng.shortlink.admin.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.DesensitizedUtil;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于给手机号进行脱敏处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDesensitizationSerializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(String phone, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">safePhone</span> <span class="operator">=</span> DesensitizedUtil.mobilePhone(phone);</span><br><span class="line">        jsonGenerator.writeString(safePhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要在需要脱敏的字段上使用@JsonSerialize注解并指明序列化器即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize(using = PhoneDesensitizationSerializer.class)</span></span><br><span class="line"><span class="keyword">private</span> String phone;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B1%95%E7%A4%BA/image-20240308215714626.png" alt="image-20240308215714626"></p><p>可以发现，用户的手机号码的信息成功进行了脱敏处理。</p>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081操作系统学习-2</title>
      <link href="/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/"/>
      <url>/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h4 id="Trap机制"><a href="#Trap机制" class="headerlink" title="Trap机制"></a>Trap机制</h4><p>​今天要讨论的内容是程序是如何完成从用户空间到内核空间的切换的，这种机制称为trap，今天的讨论会更加深入，更加底层也更加困难，希望大家能够尽可能的跟上。</p><p>​在xv6系统中，我们的设计是当用户程序发生系统调用、异常以及中断时，将会触发trap机制，完成由用户空间到内核空间的转换。</p><p>​以用户程序调用系统调用触发trap机制为例，研究底层是如何完成这种切换的。在这个过程中硬件的状态非常重要，有很多工作都是将硬件的状态由适合用户空间的状态改为适合内核的状态。而在诸多硬件中，我们最关心的是32个用户寄存器的状态(RISC-V中提供了32个寄存器，包括了堆栈寄存器Stack Register)，除了用户寄存器外还有一些对该过程非常重要的寄存器：</p><p>​STAP寄存器，指向了当前程序的最高级页表的地址；</p><p>​PC寄存器，也叫程序计数器，存储当前程序将要执行的指令；</p><p>​STVEC寄存器，指向内核中处理trap指令的起始地址；</p><p>​SEPC寄存器，在处理trap过程中用于保存PC寄存器中的值；</p><p>​SSRATCH寄存器，xx；</p><p>在接下来的讨论中我们可以看到这些寄存器是如何使用的。</p><p>​在进入底层之前，我们来思考一下，从用户空间转换为内核空间需要完成哪些工作。</p><pre><code>1. 修改之前提到的内核标志位，标识系统此时进入内核区1. 保存当前程序计数器(pc)中的内容1. 保存用户空间32个寄存器的内容1. 将用户页表切换为内核页表</code></pre><p>其中2，3项工作的目的是在内核完成对应任务后，利用保存好的数据恢复用户程序的执行。</p><p>​接下来我们深入研究一下这个过程，观察操作系统内部做了哪些工作来完成该任务。当我们在shell中调用write系统调用时，</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.s081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081操作系统学习-1</title>
      <link href="/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/08/MIT6.S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>​最近也是在学习MIT6.s081，学了一段时间后，知识点很多也很杂，今天在复习的同时也顺带将这些知识点串一下。</p><p>​<strong>首先，我们需要知道什么是操作系统？操作系统有什么用？</strong></p><p>​那么我认为，操作系统它也是一个程序，只不过它是一个特殊的程序。为什么呢？操作系统能够执行一些特殊的指令，比如创建进程，分配内存等。而普通的程序没有执行这些操作的权限，那有人可能会说，不对啊，我平时使用java等编程语言也能创建进程啊。别急，等下会介绍这个话题。这是因为操作系统能够直接操控最底层的硬件资源，一般的操作系统会将这些硬件资源进行抽象，比如将磁盘等存储器抽象为文件，将CPU抽象为进程。为什么要设计操作系统呢？一方面，是为了方便用户更好的使用计算机，因为直接和硬件打交道太麻烦了，用户必须得输入二进制指令才能和计算机进行交互，有了操作系统后，可以基于操作系统开发出更加高级的语言来和计算机进行交互，比如汇编，C，C++等；但其实最重要的一点是，设计操作系统是为了保护底层硬件，用户可以直接操控底层硬件是一种非常可怕且危险的形式，有些不怀好意的人他们编写的程序可能会使你的计算机崩溃，这不是一种好的设计。因此操作系统必须具有很强的隔离性，它能够阻止恶意程序攻击你的设备。但与此同时，操作系统也必须拥有良好的交互性，比如刚才就有人提问使用java也能够创建进程这其实就是和操作系统间的交互。或许这听起来很矛盾，但一个真正的操作系统确实如此，这也是设计一个好的操作系统的难点。接下来，我们来看一下操作系统的组织结构，可能会让你了解操作系统是如何保证强隔离性的同时又有一定的交互性。</p><p>​<strong>操作系统的组织结构</strong></p><p>​上一节中讲到，一个好的操作系统必须提供极强的隔离性，从而保证底层硬件的安全，同时它又得提供一定得交互性，那么本节我们来探讨在xv6操作系统中是如何实现的。我们先来介绍一下隔离性，其实在设计操作系统时，主要通过两种措施来实现其隔离性。</p><p>######建立一堵墙：</p><p>​这是一个很好的想法，如果我们想把两样东西分隔开来，我们可以在它们中间设立一些障碍，至少柏林曾经有过一段时间就被一堵墙分隔成了两部分，不是吗。那么在操作系统中这堵墙就叫做user&#x2F;kernel mode，也就是说操作系统将计算机分成了两部分，上面的那部分叫做user space用户区，下面那部分叫做kernel space内核区，内核区中存放着操作系统的所有功能模块(但其实这是宏内核的划分方法，而xv6系统使用的就是宏内核，在微内核系统中，操作系统中部分功能模块也位于用户区)。一切特殊权限指令都将也必须在内核区执行，这保证了操作系统的隔离性</p><img src="../images/MIT6.S081操作系统学习/image-20240302151522555.png" alt="image-20240302151522555" style="zoom:50%;" /><h6 id="独立的空间："><a href="#独立的空间：" class="headerlink" title="独立的空间："></a>独立的空间：</h6><p>​这也是一个很好的想法，当我们将两个人安置在不同的房间里，他们自然也无法干扰对方了。在操作系统中我们将这个空间叫做页(大小一般为4KB)。每个程序(进程)都只会在自己的页面中活动，而操作系统需要保证每个程序的房间里不会出现其他程序的物品，实现这项功能的技术称为虚拟内存和内存管理系统(MMU)。在计算机中每条地址指令的内容都指的是虚拟地址，需要通过转化才能得到其真正的物理地址。在操作系统中提供了一种数据结构来方便进行这种转化——页表，页表中存放着每个页面对应的物理地址，其实就是一种映射结构。在xv6系统中，每条虚拟地址需要使用64位二进制数字，但实际有效的是后39位，其中最后12位表示偏移量(offset)，27位表示用于转化为页面。你们或许会问，既然只使用39位，为啥需要64位二进制。我想说的是，这不是我们能够决定的，64位二进制是由底层硬件决定的，你的存储器芯片具有64位二进制，那么你的地址就是64位，你当然可以将这64位二进制都用掉，但是一般我们不会这么做，因为我们需要保留一部分以供未来进行扩展使用。但主要的原因是，xv6系统只是一个小型操作系统，39位已经足以支撑我们整个系统结构了。</p><p>​接下来，我们仔细研究一下页表这个结构，很显然，页表必须存储在内存中某个位置。既然我们的虚拟地址中有27位用于表示页表，那也就意味着页表中需要存放2^27条记录，而在xv6系统中每条记录需要使用64位二进制，这是一块相当大的内存，可能在某些页表占用内存较小的系统中是这么设计的(将所有页面与物理地址的映射关系存放在一个页表中)。但显然我们不能这么设计，一种更好的做法是设置多级页表，什么意思呢？也就是说在更高一级的页表中存放着比它低一级页表的位置，而在最低一级页表中存放着该虚拟地址对应的物理地址。这听起来或许很抽象，让我们用一张图来说明这一切。</p><img src="../images/MIT6.S081操作系统学习/image-20240229101310378.png" style="zoom:50%;" /><p>​通过这张图，我们可以了解xv6系统中虚拟地址是如何转化为其物理地址的。在xv6系统中设置了3级页表，当接收到一个虚拟地址时，先通过satp(位于CPU中的一个寄存器，存放着当前进程最高一级页表的地址)，获取最高一级页表的首地址，通过偏移量(L2)获取该地址对应的第二级页表的首地址，再通过偏移量(L1)获取该地址对应的最低级页表的首地址，然后通过偏移量(L0)找到该地址对应的物理地址的首地址(再计算机中地址都是以块的形式存在的，块的大小和页的大小一致)，最后通过偏移量(offset)获取该地址中存放的数据。尽管这个过程十分繁琐，有点类似链表，但是经过这种操作，页表所需要的内存确实降低了：每个页表中只需要存放2^9条数据，总共有3*2 ^9条数据。但是这种做法有一个明显的缺点：每次转化都需要访问内存3次，在效率上是个问题。</p><p>​一种提高效率的方法是：设置缓存，即每次转化，先从缓存中查看是否已经有该数据，如果有则直接返回结果；如果没有，再利用上述过程得到其物理地址，并将其存放入缓存中。至于缓存中存在的一些问题，比如：数据一致性问题，大家有兴趣的可以自行了解，这里不再深入讨论。</p><p>​需要注意的是，每个进程都有自己的页表，因此当CPU进行进程切换时，会加载对应进程的页表地址到satp寄存器中，并且清空缓存。</p><p>​再上述图片中我们还可以了解到的是，在xv6系统中页表中存放的每条数据只使用了54位二进制(剩下10位作为保留位)，其中44位用于表示内存(<strong>难道xv6的内存空间有几TB那么大？</strong>)，10位用作标志位。在这10位标志位中，最低位表示该条记录是否是有效记录，接下来3位分别表示是否可以对该记录进行读、写、执行操作。</p><p>​至此，我们终于初步了解了操作系统是如何保证其强隔离性的。我们用几句话简单概括一下，通过设置user&#x2F;kernel mode将用户区和内核区隔离，保证用户程序无法直接执行特殊指令，从而提供了指令隔离；通过虚拟内存技术，保证了各个程序间内存上互不干扰，从而提供了内存隔离。</p><h5 id="一定的交互性"><a href="#一定的交互性" class="headerlink" title="一定的交互性"></a>一定的交互性</h5><p>​经过前几节的学习，我相信你已经对操作系统的隔离性有了一定的认识，由于这些知识点非常重要也是操作系统中比较难的一部分，因此我们花了比较多的时间来学习，我相信这些时间是值得的。好了，接下来我们放松点，来了解一下操作系统是如何提供交互的，当然，这个知识点也很重要，希望你们也能够好好听讲。</p><p>​一个完全封闭的操作系统是没有意义的，因为没有用户可以使用它。因此操作系统必须具有一定的交互能力，一种想法就是在墙的两边安装电话线，通过电话实现交流。在两边分别有两个接线员，用户区的负责人叫做ECALL，内核区的负责人叫做syscall，而电话线叫做中断程序。操作系统给用户区提供了许多电话号码(也就是系统调用)，当用户拨打了这个电话号码，ECALL会为其接线，当syscall收到后，它首先会打开某个开关(一个标志位，表示系统现在的状态)，表示系统现在进入到内核区，然后它会查看该用户的请求是否合理，如果合理再由它打电话给相应人员去完成；否则它会拒绝该请求，完成后它会关掉开关进入用户模式。</p><p>​以上这个例子是我对操作系统进行交互时的理解，比较学术的说法就是。操作系统提供了许多系统调用，所谓系统调用就是一些接口，其具体实现都位于内核区。当用户程序使用了这些系统调用时，ECALL函数将该系统调用作为参数传入(在xv6系统中这些系统调用都是由一个数字表示，比如read对应的数字为0)。然后会触发一个软中断，该中断程序位于内核，因此就成功从用户区切换为内核区。位于内核区的syscall函数会检查请求是否合理，并调用真正的系统函数来完成请求。</p><p>​以上就是对操作系统的交互性的认识，我们也稍微总结一下。首先操作系统通过提供系统调用接口来实现和用户区的交互，用户区通过ECALL来实现内核区的转换，有一个标志位用于标识当前是位于用户区还是内核区，当然该标志位由内核控制，最后在用户区调用的系统函数，最终是在内核区执行的。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.s081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>O(1)时间复杂度求动态数据的中位数</title>
      <link href="/2024/03/08/O(1)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E5%87%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2024/03/08/O(1)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E5%87%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>​中位数大家都知道，就是一些数经过排序后最中间的数。具体来说如果有n个排好序的数，当n为奇数时，这些数的中位数就是下标为n&#x2F;2（下取整）的数；当n为奇数时，这些数的中位数就是下标为n&#x2F;2和下标为n&#x2F;2+1的数的平均数。</p><p>​如果给定一个无序数组，并且数组中的数据是动态的，存在删除和新增操作，如何在O(1)的时间复杂度内快速得到该数组的中位数呢？</p><p>​详细题目可以参考<a href="https://leetcode.cn/problems/find-median-from-data-stream">LeetCode295</a></p><p>​这里提供的思路为：用一个大根堆维护数组中较小的一半的数，用一个小根堆维护数组中较大的一半的数，当数组的长度为偶数时，该数组的中位数等于两个堆顶元素的平均值；当数组的长度为奇数时，该数组的中位数等于小根堆的堆顶元素(因为优先插入的是小根堆，所以当数组长度为奇数时，小根堆中的元素个数比大根堆多一)</p><p>​具体的维护方式为：当小根堆和大根堆中的元素个数相等时，此时如果发生数据的添加，需要往小根堆中添加元素，为了使小根堆中的元素始终是数组中较大的一半，先将该元素插入大根堆中，再将大根堆的堆顶元素插入小根堆中；如果不相等，往大根堆中添加元素，为了使大根堆中的元素始终是数组中较小的一半，先将该元素插入小根堆中，再将小根堆的堆顶元素插入大根堆中。至于数据的删除，也可以按照同样的思路，只要保证小根堆中存储的是较大一半的数，大根堆中存储的是较小一半的数即可。</p><p>​实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt;heapMax;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt;heapMin;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        heapMax = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a,Integer b)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        heapMin = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeMax</span> <span class="operator">=</span> heapMax.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeMin</span> <span class="operator">=</span> heapMin.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sizeMax == sizeMin)&#123;</span><br><span class="line">            heapMax.add(num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> heapMax.poll();</span><br><span class="line">            heapMin.add(top);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            heapMin.add(num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> heapMin.poll();</span><br><span class="line">            heapMax.add(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> heapMin.size() + heapMax.size();</span><br><span class="line">        <span class="type">double</span> median;</span><br><span class="line">        <span class="keyword">if</span>(size % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            median = (<span class="type">double</span>)(heapMin.peek() + heapMax.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            median = heapMin.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--全局统一返回实体</title>
      <link href="/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5--%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AE%9E%E4%BD%93/"/>
      <url>/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5--%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AE%9E%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h4 id="全局统一返回实体"><a href="#全局统一返回实体" class="headerlink" title="全局统一返回实体"></a>全局统一返回实体</h4><p>​为了使在返回给浏览器数据时更加方便，适配各种返回情况，比如只返回成功或失败的信息、返回信息和数据，只返回数据等等。提高开发效率</p><p>全局统一返回实体的设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serial;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局返回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5679018624309023727L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正确返回码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUCCESS_CODE</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS_CODE.equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Accessors注解：位于Lombok插件包中，作用于类和属性上，对属性的getter和setter方法有影响。有三个属性：fluent、chain和prefix</p><p>fluent属性：默认为false，当该属性为true时，表示去除getter和setter方法的get和set，也就是说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(fluent = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(fluent = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.name(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chain属性：默认为false，当该属性为true时，调用bean的set方法可以返回该对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prefix属性：该属性是一个字符串数组，能够去掉getter和setter方法中属性指定的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(prefix = &#123;&quot;xx&quot;,&quot;yy&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String xxName;</span><br><span class="line">    <span class="keyword">private</span> String yyAge;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局统一返回实体构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.exception.AbstractException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局返回对象构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Results</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造成功响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造带返回数据的成功响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE)</span><br><span class="line">                .setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建服务端失败响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">failure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(BaseErrorCode.SERVICE_ERROR.code())</span><br><span class="line">                .setMessage(BaseErrorCode.SERVICE_ERROR.message());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 &#123;<span class="doctag">@link</span> AbstractException&#125; 构建失败响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">failure</span><span class="params">(AbstractException abstractException)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorCode</span> <span class="operator">=</span> Optional.ofNullable(abstractException.getErrorCode())</span><br><span class="line">                .orElse(BaseErrorCode.SERVICE_ERROR.code());</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> Optional.ofNullable(abstractException.getErrorMessage())</span><br><span class="line">                .orElse(BaseErrorCode.SERVICE_ERROR.message());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(errorCode)</span><br><span class="line">                .setMessage(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 errorCode、errorMessage 构建失败响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;Void&gt; <span class="title function_">failure</span><span class="params">(String errorCode, String errorMessage)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;Void&gt;()</span><br><span class="line">                .setCode(errorCode)</span><br><span class="line">                .setMessage(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问：为啥要特意创建一个类来实例化另一个类？</p><p>解答：为了代码整洁？</p><p>通过本节需要掌握</p><ol><li>全局统一返回实体的设计和使用</li><li>一些注解的使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接--异常码的设计和使用</title>
      <link href="/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%BC%82%E5%B8%B8%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/07/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE--%E5%BC%82%E5%B8%B8%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>####异常码的设计和使用</p><p>​为了更快的确定异常原因，从而快速定位出错地点并解决异常。可以使用异常码，每个异常码都对应一个特定的错误。本项目参考阿里巴巴开发手册，将出错原因大体上分为3类：用户端出错，服务器端出错以及远端第三方组件出错，分别用大写英文字母A、B、C标识，每个类别下使用6位数字来表示出错原因，因而总共可以表示30万种错误。每个大类中根据内容详细程度不同，分为3个级别，级别越高内容越详细。</p><p>异常码设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Interface IErrorCode&#123;</span><br><span class="line">    String code;</span><br><span class="line">    String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础异常码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础错误码定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BaseErrorCode</span> <span class="keyword">implements</span> <span class="title class_">IErrorCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 一级宏观错误码 客户端错误 ==========</span></span><br><span class="line">    CLIENT_ERROR(<span class="string">&quot;A000001&quot;</span>, <span class="string">&quot;用户端错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 二级宏观错误码 用户注册错误 ==========</span></span><br><span class="line">    USER_REGISTER_ERROR(<span class="string">&quot;A000100&quot;</span>, <span class="string">&quot;用户注册错误&quot;</span>),</span><br><span class="line">    USER_NAME_VERIFY_ERROR(<span class="string">&quot;A000110&quot;</span>, <span class="string">&quot;用户名校验失败&quot;</span>),</span><br><span class="line">    USER_NAME_EXIST_ERROR(<span class="string">&quot;A000111&quot;</span>, <span class="string">&quot;用户名已存在&quot;</span>),</span><br><span class="line">    USER_NAME_SENSITIVE_ERROR(<span class="string">&quot;A000112&quot;</span>, <span class="string">&quot;用户名包含敏感词&quot;</span>),</span><br><span class="line">    USER_NAME_SPECIAL_CHARACTER_ERROR(<span class="string">&quot;A000113&quot;</span>, <span class="string">&quot;用户名包含特殊字符&quot;</span>),</span><br><span class="line">    PASSWORD_VERIFY_ERROR(<span class="string">&quot;A000120&quot;</span>, <span class="string">&quot;密码校验失败&quot;</span>),</span><br><span class="line">    PASSWORD_SHORT_ERROR(<span class="string">&quot;A000121&quot;</span>, <span class="string">&quot;密码长度不够&quot;</span>),</span><br><span class="line">    PHONE_VERIFY_ERROR(<span class="string">&quot;A000151&quot;</span>, <span class="string">&quot;手机格式校验失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 二级宏观错误码 系统请求缺少幂等Token ==========</span></span><br><span class="line">    IDEMPOTENT_TOKEN_NULL_ERROR(<span class="string">&quot;A000200&quot;</span>, <span class="string">&quot;幂等Token为空&quot;</span>),</span><br><span class="line">    IDEMPOTENT_TOKEN_DELETE_ERROR(<span class="string">&quot;A000201&quot;</span>, <span class="string">&quot;幂等Token已被使用或失效&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 一级宏观错误码 系统执行出错 ==========</span></span><br><span class="line">    SERVICE_ERROR(<span class="string">&quot;B000001&quot;</span>, <span class="string">&quot;系统执行出错&quot;</span>),</span><br><span class="line">    <span class="comment">// ========== 二级宏观错误码 系统执行超时 ==========</span></span><br><span class="line">    SERVICE_TIMEOUT_ERROR(<span class="string">&quot;B000100&quot;</span>, <span class="string">&quot;系统执行超时&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 一级宏观错误码 调用第三方服务出错 ==========</span></span><br><span class="line">    REMOTE_ERROR(<span class="string">&quot;C000001&quot;</span>, <span class="string">&quot;调用第三方服务出错&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    BaseErrorCode(String code, String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">message</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常的设计和使用"><a href="#异常的设计和使用" class="headerlink" title="异常的设计和使用"></a>异常的设计和使用</h4><p>​根据异常码的分类，因此产生的异常也分为3类.</p><p><strong>异常类设计</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象项目中三类异常体系，客户端异常、服务端异常以及远程服务调用异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ClientException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RemoteException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String errorCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String errorMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, throwable);</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorCode.code();</span><br><span class="line">        <span class="built_in">this</span>.errorMessage = Optional.ofNullable(StringUtils.hasLength(message) ? message : <span class="literal">null</span>).orElse(errorCode.message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientException</span> <span class="keyword">extends</span> <span class="title class_">AbstractException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, BaseErrorCode.CLIENT_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(String message, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, throwable, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ClientException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&#x27;&quot;</span> + errorCode + <span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;message=&#x27;&quot;</span> + errorMessage + <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 远程服务调用异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteException</span> <span class="keyword">extends</span> <span class="title class_">AbstractException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, BaseErrorCode.REMOTE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteException</span><span class="params">(String message, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, throwable, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RemoteException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&#x27;&quot;</span> + errorCode + <span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;message=&#x27;&quot;</span> + errorMessage + <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.IErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceException</span> <span class="keyword">extends</span> <span class="title class_">AbstractException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, BaseErrorCode.SERVICE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(message, <span class="literal">null</span>, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message, Throwable throwable, IErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Optional.ofNullable(message).orElse(errorCode.message()), throwable, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ServiceException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&#x27;&quot;</span> + errorCode + <span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;message=&#x27;&quot;</span> + errorMessage + <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​在处理异常上，设置全局异常拦截器，统一处理产生的所有异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.collection.CollectionUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.errorcode.BaseErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.exception.AbstractException;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.result.Result;</span><br><span class="line"><span class="keyword">import</span> com.nageoffer.shortlink.admin.common.convention.result.Results;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.FieldError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截参数验证异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">validExceptionHandler</span><span class="params">(HttpServletRequest request, MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> ex.getBindingResult();</span><br><span class="line">        <span class="type">FieldError</span> <span class="variable">firstFieldError</span> <span class="operator">=</span> CollectionUtil.getFirst(bindingResult.getFieldErrors());</span><br><span class="line">        <span class="type">String</span> <span class="variable">exceptionStr</span> <span class="operator">=</span> Optional.ofNullable(firstFieldError)</span><br><span class="line">                .map(FieldError::getDefaultMessage)</span><br><span class="line">                .orElse(StrUtil.EMPTY);</span><br><span class="line">        log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;</span>, request.getMethod(), getUrl(request), exceptionStr);</span><br><span class="line">        <span class="keyword">return</span> Results.failure(BaseErrorCode.CLIENT_ERROR.code(), exceptionStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截应用内抛出的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = &#123;AbstractException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">abstractException</span><span class="params">(HttpServletRequest request, AbstractException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex.getCause() != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString(), ex.toString(), ex.getCause());</span><br><span class="line">            <span class="keyword">return</span> Results.failure(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString(), ex.toString());</span><br><span class="line">        <span class="keyword">return</span> Results.failure(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截未捕获异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">defaultErrorHandler</span><span class="params">(HttpServletRequest request, Throwable throwable)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;[&#123;&#125;] &#123;&#125; &quot;</span>, request.getMethod(), getUrl(request), throwable);</span><br><span class="line">        <span class="keyword">return</span> Results.failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUrl</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(request.getQueryString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> request.getRequestURL().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request.getRequestURL().toString() + <span class="string">&quot;?&quot;</span> + request.getQueryString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@SneakyThrows注解：可作用于方法和构造函数上，可以帮助捕获异常，简化代码，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">utf8ToString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用该注解后，可以使代码更加简洁。该注解位于Lombok中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">utf8ToString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过本节需要掌握</p><ol><li>异常码的设计和使用</li><li>异常类的设计和使用</li><li>全局异常处理器的设计</li><li>@SneakyThrows注解的使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 短链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目全局唯一ID生成器</title>
      <link href="/2024/03/07/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2024/03/07/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="开发全局唯一ID生成器"><a href="#开发全局唯一ID生成器" class="headerlink" title="开发全局唯一ID生成器"></a>开发全局唯一ID生成器</h4><p>​保证id唯一的方法有很多种，本项目使用的是基于Redis的id生成器，其基本原理是借助于Redis自带的increment自增方法。</p><p>​<strong>生成原理</strong>：以long类型作为生成id的类型，long类型具有64位，将这64位分为三部分，[63,63],[32,62],[0,31]。最高位是符号位，是一个固定值0，表示生成的id是非负数，后面63位需要决定生成id的唯一性。具体方法为，[0,31]位上填充由Redis的increment方法生成的值，[32,62]位填充当前时间距离某个基准时间的时间(一般以秒作为单位，69年后生成的值才会超过31位)。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E5%99%A8/image-20240307191739286.png"></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用于生成全局唯一ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniqueIdGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2024.01.01 00:00:00作为基准时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIME_BEGIN</span> <span class="operator">=</span> <span class="number">1704067200L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的业务生成不同的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix 业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">generatorId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> now - TIME_BEGIN;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy:MM:dd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">timeStamp</span> <span class="operator">=</span> simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//为了便于管理和查询，将当日时间融入key中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + timeStamp;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(key);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> interval &lt;&lt; <span class="number">32</span> | count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习完本节需要掌握以下知识点：</p><ol><li>如何通过Redis生成全局唯一ID</li><li>时间戳的巧用</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC--创建线程</title>
      <link href="/2024/03/07/JUC--%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/03/07/JUC--%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在java中创建一个线程有3种方法。</p><p>一.直接new一个Thread对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread1</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;t1 is doing&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>二.通过Runnable接口辅助创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 is doing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对第二种方法可以通过lambda对其简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;t3 is doing&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑问</strong></p><p>以上代码中可以发现有new Runnable这个操作，Runnable是一个接口，为啥能够被实例化？</p><p>–解答：在java中接口和抽象类是不能被实例化的，在这里也不例外.而这里其实是使用了匿名内部类，也就是说new出来的这个对象不是Runnable，而是一个实现了该接口的子类，这也是为什么run方法上出现@Override注解的原因。等价于以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2 is doing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现，相较于使用匿名内部类，后者需要额外创建一个类，更加麻烦。因此对于那些只在某些只使用一次的接口实现子类，可以使用匿名内部类的方式创建，这也是我们经常使用的方式，比如在给集合排序时，就会使用匿名内部类来实现Comparator接口。</p><p>三.通过FutureTask辅助创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForCreateThread4</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">      FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;t4 is doing&quot;</span>);</span><br><span class="line">              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">      thread4.start();</span><br><span class="line">      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> task.get();</span><br><span class="line">      System.out.println(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​FutureTask实现了RunnableFuture接口，而RunnableFuture继承了Runnable接口，因此FutureTask也实现了Runnable接口。</p><p>​FutureTask类中提供了两个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​第一种构造方法的Callable也是一个接口，里面有一个抽象方法call()，用于返回计算结果.FutureTask的get方法能够获取该返回值，需要注意的是该get方法是一个阻塞式线程，它会一直等待这个返回值，所以如果你将task.get()语句放在thread4.start()语句之前，就会发生死锁现象。</p><p>​需要注意的是，以上3中创建线程的方法中，其实只有第一种方法才是真正创建了一个线程，后两者只是创建了线程所要运行的任务，即run方法中的内容，不过由于后两种方法能够将创建线程和线程要运行的任务分开，是编程更加灵活，因此也更受青睐。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2024/03/07/%E7%AE%97%E6%B3%95--%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2024/03/07/%E7%AE%97%E6%B3%95--%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="单调栈题集"><a href="#单调栈题集" class="headerlink" title="单调栈题集"></a>单调栈题集</h4><p>​单调栈是一种特殊的栈，因为栈中的元素大小是单调的而得名单调栈。经过预处理(预处理的时间复杂度为O(n))，可以在O(1)的时间复杂度求出数组中每个元素右边(左边)第一个大于(小于)该元素的值的下标。是一种非常常用且好用的数据结构</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram">LeetCode84</a></p><p>​这道题我一开始的想的暴力做法是枚举两个自由度，第一个自由度表示该矩形的起始位置(start)，另一个自由度表示该矩形的结束位置(end)，在枚举的过程中维护一个最小高度(minH)并更新答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">minH</span> <span class="operator">=</span> heights[i];</span><br><span class="line">   res = Math.max(res,minH);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j ++)&#123;</span><br><span class="line">       minH = Math.min(minH,heights[j]);</span><br><span class="line">       res = Math.max(res,(j - i + <span class="number">1</span>) * minH);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这似乎也是一种暴力思路，但是由于我一开始想的暴力做法是以上做法，导致我想利用双指针来进行优化，还是没想出来。</p><p>​但其实还有另一种暴力思路，枚举当前该高度能够形成的最大矩形，也要枚举两个自由度，一个就是数组中的每个高度height，另一个就是左右两边第一个比它小的高度的下标minL，minR，该矩形的面积就是height * (minL - minR)。在这种思路下，我一下子就想到了使用单调栈来优化。因为单调栈能够在O(1)的时间复杂度内得到左右两边第一个小于某个数的下标(在经过预处理的情况下)，因此总的时间复杂度为O(n)</p><p>​实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> minL[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//minL[i]表示左边第一个小于heights[i]的下标</span></span><br><span class="line">        <span class="type">int</span> minR[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//minR[i]表示右边第一个小于heights[i]的下标</span></span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line">        Stack&lt;Integer&gt;stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                minR[i] = n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minR[i] = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                minL[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minL[i] = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举每个高度下能够形成的最大矩形</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> heights[i] * (minR[i] - minL[i] - <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res,s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目开发缓存工具类</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存工具类"><a href="#缓存工具类" class="headerlink" title="缓存工具类"></a>缓存工具类</h4><p>​在解决缓存技术中存在的问题时，其解决方案基本上是有固定套路的</p><p>​针对缓存穿透问题(指查询数据既不存在于缓存中，也不存在于数据库中，如果有用户恶意刷该请求，会给数据库造成巨大压力，影响系统性能)，有以下两种解决方案：</p><ol><li>当数据库查询不到数据时，给缓存返回空值。这个方案也是有问题的，比如此后不久数据库中插入了该数据，那么直到缓存中的空值过期，否则用户一直无法取到对应数据，并且会消耗额外的内存。</li><li>采用布隆过滤器技术：这是一种利用二进制来判断缓存中是否有对应数据的技术，作用于用户请求和Redis之间，能够过滤掉缓存和数据库中都不存在数据的请求。但是实现复杂，并且存在误判可能(类似于哈希冲突)</li></ol><p>​针对缓存雪崩问题(指某一段时间，缓存中的大量数据失效在项目初始化时，有大量数据同时加入缓存，又称为数据预热或者缓存服务挂了，导致大量请求涌入数据库，给数据库造成巨大压力，影响系统性能)，有以下解决方案</p><ol><li>给缓存中的每条数据设置随机的过期时间。该方案只能解决前一种情况</li><li>针对第二种情况，可以采用缓存集群以及设置多级缓存的方式加以解决。</li></ol><p>​针对缓存击穿问题(通常是针对某些热点key，比如某些促销活动，在很短时间内有大量请求涌入，此时某个key失效，会导致大量请求不断涌入数据库，给数据库造成巨大压力，不仅影响用户体验，还可能使系统崩溃)，有以下解决方案：</p><ol><li>给缓存中的数据设置逻辑过期时间，即缓存中的每条数据都不会失效，而是让程序员在编写代码时判断该数据是否有效。这种做法的优点是性能较高，但是由于缓存中的数据不会失效，因此保证不了数据一致以及消耗了额外内存。</li><li>设置互斥锁，即当第一个线程发现缓存中无数据时，它会去访问数据库同时给该数据上锁，上锁的目的是让其他线程无法访问缓存从而也引发缓存重构。这种做法的优点是能够保证数据的一致性，缺点是由于线程必须等待，因此性能较低</li></ol><p>从上面这几种缓存中出现的问题，我们可以得出缓存中的问题基本上都是关于数据不一致的以及数据库压力过大的问题，由于使用场景颇多，如果每次开发时，都要额外写一套代码，既繁琐代码也没得到复用，基于以上情况，开发一个缓存工具类，具有以下功能。</p><ol><li><p>可以将任意java对象存储进String类型的value中，并可以设置有效时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time,timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以将任意java对象存储进String类型的value中，并可以设置逻辑过期时间，用于处理缓存击穿问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogic</span><span class="params">(String key,Object value,Long time,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(value);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    </span><br><span class="line">       stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里针对逻辑过期的做法是对数据进行再封装，符合OCP原则。</p></li><li><p>根据key查询数据并反序列化为指定类型，当无该数据时将空值存储进redis中用于解决缓存穿透问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key查询数据并反序列化为指定类型，当无该数据时将空值存储进redis中用于解决缓存穿透问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix 前缀和id组合在一起构成key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dbFeedBack 由调用者指定查询数据库的逻辑，是查询商户还是其他逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 返回值类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; 由调用者指定id类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;ID&gt; 由调用者指定返回值类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;R,ID&gt;R <span class="title function_">queryWithPassThrough</span><span class="params">(String prefix, ID id, Class&lt;R&gt;type,Function&lt;ID,R&gt; dbFeedBack,Long time,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> prefix + id;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(json != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">R</span> <span class="variable">ret</span> <span class="operator">=</span> dbFeedBack.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="literal">null</span>)&#123;</span><br><span class="line">        set(key,<span class="string">&quot;&quot;</span>,time,timeUnit);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        set(key,ret,time,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据key查询数据并反序列化为指定类型，并使用逻辑过期解决缓存击穿问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R,ID&gt;R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String prefix,ID id,Class&lt;R&gt;type,Function&lt;ID,R&gt;dbFeedBack,Long time,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> prefix + id;</span><br><span class="line">    <span class="comment">//查看Redis中是否有该商户</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">        <span class="comment">//Redis中有该商户，直接返回</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">cacheData</span> <span class="operator">=</span> JSONUtil.toBean(json,type);</span><br><span class="line">        <span class="keyword">return</span> cacheData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(json != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//shopJson是空字符串，说明数据库中也没有该店铺</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始缓存重建</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span>(!lock)&#123;</span><br><span class="line">            <span class="comment">//有其他线程在重建，进入等待</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithLogicalExpire(prefix,id,type,dbFeedBack,time,timeUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = dbFeedBack.apply(id);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数据库中也没有该数据，查询错误,向Redis中插入空数据防止缓存穿透,并设置2min有效期</span></span><br><span class="line">            set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            setWithLogic(key,ret,CACHE_SHOP_TTL,TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        delLock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//设置互斥锁防止缓存击穿,设置锁的有效期为10s，防止发生故障锁未释放</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;0&quot;</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过本节需要掌握以下知识点：</p><ol><li>如何通过互斥锁来解决缓存击穿问题的，互斥锁是如何实现的</li><li>在编写该工具类时泛型的使用以及Function是如何使用的</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小未出现正整数</title>
      <link href="/2024/03/06/O(n)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E6%95%B0%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"/>
      <url>/2024/03/06/O(n)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E6%95%B0%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="O-n-时间复杂度常数空间求解最小未出现正整数"><a href="#O-n-时间复杂度常数空间求解最小未出现正整数" class="headerlink" title="O(n)时间复杂度常数空间求解最小未出现正整数"></a>O(n)时间复杂度常数空间求解最小未出现正整数</h4><p><a href="https://leetcode.cn/problems/first-missing-positive">LeetCode41</a></p><p>​这道题的难点在于，既要求时间复杂度控制在O(n)，有要求常数级空间复杂度。</p><p>​假设抛开时间复杂度复杂度这一要求，我们可以使用快排或者二分来实现，都能满足常数时间复杂度的要求。</p><p>​如果抛开空间复杂度这一要求，我们可以额外创建一个哈希表来记录数组中的数，能够满足O(n)时间复杂度的要求。</p><p>​如果想要满足这两个要求，这是一种思维上的挑战。这里的想法是，其实题目中有一个隐含条件，那就是[1,2,…n]这个数组，我们只要保证让n以内的数在nums中有序，再通过对比这个数组就能找出最小未出现正整数，这也是排序做法的思路。做法就是让这些数回到它们本应该在的位置，比如2应该在nums下标为1的位置，同理，n应该在nums下标为n-1的位置，遍历nums每个数，将n以内的数交换至对应的位置，这样就能实现nums数组的部分有序性，这样就既符合时间复杂度O(n)(交换的次数非常少),常数级空间复杂度。</p><p>​实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                <span class="comment">//由于nums[i] - 1依赖于nums[i]因此以下这种交换规则是错误的，期间nums[i]已经改变了</span></span><br><span class="line">                <span class="comment">// int temp = nums[i];</span></span><br><span class="line">                <span class="comment">// nums[i] = nums[nums[i] - 1];</span></span><br><span class="line">                <span class="comment">// nums[nums[i] - 1] = temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="字典树Tire题集"><a href="#字典树Tire题集" class="headerlink" title="字典树Tire题集"></a>字典树Tire题集</h4><p><a href="https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii">LeetCode3045</a></p><p>​讲一下这道题使用字典树的做法，首先介绍一下什么是字典树。字典树是一种处理字符串的数据结构，通常用于快速统计某些字符串出现的次数，比如：给定一个字符串数组[a,a,c,abc,ab],以下就是该字符串数组形成的字典树。</p><img src="../images/算法--字典树/image-20240219161255454.png" style="zoom:50%;" /><p>​这棵树可以表示以字符串a出现了2次，ab出现了1次，abc出现了1次，c出现了1次</p><p>​这道题的特别之处在于，不仅要求我们匹配前缀还要匹配后缀。比如ab虽然是abc的前缀但不是它的后缀，因此不符合题意。这里灵神提供的一种思路是将前缀和后缀综合考虑，比如字符串abcde、abcdesabcde，将它们的前后缀综合考虑变为{(a,e),(b,d),(c,c),(d,b),(e,a)},{(a,e),(b,d),(c,c),(d,b),(e,a),(s,s),…},可以发现经过这样转化后，只需判断前者是否是后者的前缀即可判定，<strong>某个字符串是否既是另一个字符串的前缀，又是另一个字符串的后缀，而这样就可以直接使用字典树解决</strong>。为了进一步简化，我们可以将这个键值对映射为一个数字。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countPrefixSuffixPairs</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="type">char</span> s[] = words[i].toCharArray();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;<span class="comment">//每次都需要从根节点开始遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length; j ++)&#123;</span><br><span class="line">                <span class="comment">//将键值对映射为一个数字，一种简单的哈希</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">pair</span> <span class="operator">=</span> (s[j] - <span class="string">&#x27;a&#x27;</span>) &lt;&lt; <span class="number">5</span> | (s[s.length - <span class="number">1</span> - j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                cur = cur.son.computeIfAbsent(pair,k -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                res += cur.cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    Map&lt;Integer,Node&gt;son = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E6%A0%88/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="栈题集"><a href="#栈题集" class="headerlink" title="栈题集"></a>栈题集</h4><ul><li><p>栈是一种特殊的数据结构，具有先进后出的特点。可以把栈想象成一个桶，当从桶中取出物品时，先放入的物品会后取出，并且只有将上面的物品取出后，处于桶下面的物品才能取出。</p></li><li><p>在java中也提供了这种数据结构，位于java.util包下，名称为Stack。以下是有关Stack的一些常用操作</p></li><li><pre><code class="java">//初始化Stack&lt;Integer&gt;stack = new Stack&lt;&gt;();//向栈中存放数据stack.push(1);//取出栈顶元素int x = stack.pop();//查看栈顶元素int top = stack.peek();//移除栈中对应的元素stack.remove(1);//查看栈是否为空stack.isEmpty();//返回栈的大小stack.size();//翻转栈Collections.reverse(stack);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[LeetCode155](https://leetcode.cn/problems/min-stack)</span><br><span class="line"></span><br><span class="line">​本题要求实现一个最小栈，与普通栈相比，多了一个返回栈中最小值的功能(要求时间复杂度为常数级别)。我一开始的思路是打算用优先队列来做的，但不知道为什么过不了。以上问题已解决，主要是在定义优先队列的排序规则时使用了减法导致数据溢出，代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class MinStack &#123;</span><br><span class="line">    private Stack&lt;Data&gt; stack;</span><br><span class="line">    private int index;</span><br><span class="line">    private PriorityQueue&lt;Data&gt;heap;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        stack = new Stack&lt;&gt;();</span><br><span class="line">        heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Data&gt;()&#123;</span><br><span class="line">            public int compare(Data a,Data b)&#123;</span><br><span class="line">                return a.getData() - b.getData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        index = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int val) &#123;</span><br><span class="line">        Data data = new Data(val,index++);</span><br><span class="line">        stack.push(data);</span><br><span class="line">        heap.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        Data data = stack.pop();</span><br><span class="line">        heap.remove(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack.peek().getData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        return heap.peek().getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//设计这个类来避免优先队列remove时将所有的数字都移除，比如heap中有1，2，2，这时执行heap.remove(2),就会将所有2移除，而我们只是想要移除其中一个2.</span><br><span class="line">class Data&#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private int ord;</span><br><span class="line"></span><br><span class="line">    public Data()&#123;&#125;;</span><br><span class="line">    public Data(int data,int ord)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.ord = ord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData()&#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>以下是看了题解后的写法，题解的做法是使用辅助栈。因为由于栈具有先进后出的特点，只要上面的数不被弹出，那么下面的数就一定还在栈中，因此可以使用一个辅助栈来记录每个状态下，栈的最小值，相当于维护一个前缀最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;tempStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        tempStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span>(tempStack.isEmpty())&#123;</span><br><span class="line">            tempStack.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> tempStack.peek();</span><br><span class="line">            <span class="keyword">if</span>(top &gt; val)tempStack.push(val);</span><br><span class="line">            <span class="keyword">else</span> tempStack.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        tempStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(dfs)/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(dfs)/</url>
      
        <content type="html"><![CDATA[<h4 id="深度优先遍历-dfs"><a href="#深度优先遍历-dfs" class="headerlink" title="深度优先遍历(dfs)"></a>深度优先遍历(dfs)</h4><h5 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h5><p><a href="https://leetcode.cn/problems/generate-parentheses">LeetCode22</a></p><p>​本题要求生成给定数量的”()”，问有多少种生成方案。比如：要求生成3对括号，那么生成结果可以是”()()()”、”((()))”、”(()())”。</p><p>​解决本题的关键在于需要保证在生成”)”时，在此之前至少有一个未被配对的”(“。因此我dfs的主要参数有已使用的”(“数量，未被配对的”(“数量。接下来在生成”(“时只需保证”(“的数量还未使用完；生成”)”时只需保证在此之前至少有一个未被配对的”(“。</p><p>​实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt;res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftNum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span> s[] = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span> * n];</span><br><span class="line">        leftNum = n;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> leNum,<span class="type">int</span> noCoupleNum,<span class="type">char</span> s[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">2</span> * leftNum)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(s);</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//保证&quot;(&quot;的数量还未使用完</span></span><br><span class="line">        <span class="keyword">if</span>(leNum &lt; leftNum)&#123;</span><br><span class="line">            s[u] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>,leNum + <span class="number">1</span>,noCoupleNum + <span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在此之前至少有一个未被配对的&quot;(&quot;</span></span><br><span class="line">        <span class="keyword">if</span>(noCoupleNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s[u] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>,leNum,noCoupleNum - <span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/palindrome-partitioning">LeetCode131</a></p><p>​本题要求对给定字符串进行分割，使得每个子串都是回文串。</p><p>​解决方法就是直接枚举每个子串是否是回文串。模拟样例：s&#x3D;”aab”.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>,j = i = <span class="number">0</span>,子串为<span class="string">&quot;a&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">i = <span class="number">1</span>,j = i = <span class="number">1</span>,子串为<span class="string">&quot;a&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">i = <span class="number">2</span>,j = i = <span class="number">2</span>,子串为<span class="string">&quot;b&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">i = <span class="number">3</span> = s.length(),将path加入res中,回溯,path=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">         i = <span class="number">2</span>,j = <span class="number">3</span> &gt; s.length() - <span class="number">1</span>,回溯,path=&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    i = <span class="number">1</span>,j = <span class="number">2</span>,子串为<span class="string">&quot;ab&quot;</span>不是回文串</span><br><span class="line">    i = <span class="number">1</span>,j = <span class="number">3</span> = s.length() - <span class="number">1</span>,回溯,path=&#123;&#125;</span><br><span class="line">i = <span class="number">0</span>,j = <span class="number">1</span>,子串为<span class="string">&quot;aa&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;aa&quot;</span>&#125;</span><br><span class="line">i = <span class="number">2</span>,j = i = <span class="number">2</span>,子串为<span class="string">&quot;b&quot;</span>是回文串加入path中,path=&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">i = <span class="number">3</span> = s.length(),将path加入res中,回溯,path=&#123;<span class="string">&quot;aa&quot;</span>&#125;</span><br><span class="line">i = <span class="number">2</span>,j = <span class="number">3</span> &gt; s.length() - <span class="number">1</span>,回溯,path=&#123;&#125;</span><br><span class="line">i = <span class="number">0</span>,j = <span class="number">2</span>,子串为<span class="string">&quot;aab&quot;</span>不是回文串</span><br><span class="line">i = <span class="number">0</span>,j = <span class="number">3</span> &gt; s.length() - <span class="number">1</span>,至此,递归结束</span><br></pre></td></tr></table></figure><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt;res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt;path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,s,path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判定是否为回文串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,String s)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left++) != s.charAt(right--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,String s,List&lt;String&gt;path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(i,j,s))&#123;</span><br><span class="line">                path.add(s.substring(i,j + <span class="number">1</span>));</span><br><span class="line">                dfs(j + <span class="number">1</span>,s,path);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉树题集"><a href="#二叉树题集" class="headerlink" title="二叉树题集"></a>二叉树题集</h4><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">Leetcode105</a></p><p>这道题要求我们根据二叉树的前序遍历和中序遍历还原这棵二叉树。这是一个定理：只要给定一棵树的前序遍历和中序遍历或者后序遍历和中序遍历，我们就能够唯一构造出这棵树。需要注意的是如果只给定前序遍历和后续遍历，虽然也能构造出一棵树，但不唯一。</p><p>其原理为：由于前序遍历的特点为先遍历根节点，再遍历左儿子，最后遍历右儿子。因此通过前序遍历&#x2F;后序遍历可以知道根节点(整棵树的根节点以及子树的根节点)，再通过中序遍历可以知道根节点的左子树和右子树。这样我们就能够唯一确定这棵树。比如给定某棵树的前序遍历集合为[3,4,5,7,9,10],再给定其中序遍历集合为[4,5,3,7,10,9].</p><p>首先，通过前序遍历集合可以知道3是根节点，再定位到中序遍历集合中，4、5是它的左子树；7、10、9是它的右子树。因为前序遍历集合中4在5前，因此4才是3的左儿子；7在10和9前，因此它是3的右儿子。这样不断重复操作，最终还原这棵二叉树</p><img src="../images/算法--二叉树/image-20240217153009329.png" style="zoom:50%;" /><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt;indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="comment">//思路：从preorder中取出根节点，再在inorder中找到该节点的位置，该位置左边的</span></span><br><span class="line">        <span class="comment">//节点为根节点的左子树，右边的节点为根节点的右子树。如此不断递归</span></span><br><span class="line">        n = preorder.length;</span><br><span class="line">        <span class="comment">//更快定位某节点在中序遍历集合中的位置，用哈希表记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            indexMap.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> dfs(preorder,inorder,<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> preorder[],<span class="type">int</span> inorder[],<span class="type">int</span> preorder_left,<span class="type">int</span> preorder_right,<span class="type">int</span> inorder_left,<span class="type">int</span> inorder_right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_left &gt; preorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preorder_left];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndexInorder</span> <span class="operator">=</span> indexMap.get(rootVal);<span class="comment">//根节点在中序遍历集合中的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size_left</span> <span class="operator">=</span> rootIndexInorder - inorder_left;<span class="comment">//左子树的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size_right</span> <span class="operator">=</span> inorder_right - rootIndexInorder;<span class="comment">//右子树的大小</span></span><br><span class="line">        root.left = dfs(preorder,inorder,preorder_left + <span class="number">1</span>,preorder_left + size_left,inorder_left,rootIndexInorder - <span class="number">1</span>);</span><br><span class="line">        root.right = dfs(preorder,inorder,preorder_left + <span class="number">1</span> + size_left,preorder_right,rootIndexInorder + <span class="number">1</span>,inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定的是后序遍历集合和中序遍历集合，那么根节点是post_right,且由于后续遍历的规则为“左右根”，我们需要通过右子树的大小确定左右子树中的元素。</p><p>题目见<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">LeetCode106</a></p><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt;postorderIndexOfInorder;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> postorder.length;</span><br><span class="line">        postorderIndexOfInorder = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            postorderIndexOfInorder.put(inorder[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dfs(postorder,inorder,<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> postorder[],<span class="type">int</span> inorder[],<span class="type">int</span> postorder_left,<span class="type">int</span> postorder_right,<span class="type">int</span> inorder_left,<span class="type">int</span> inorder_right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder_left &gt; postorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postorder_right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> postorderIndexOfInorder.get(rootVal);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size_left</span> <span class="operator">=</span> index - inorder_left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size_right</span> <span class="operator">=</span> inorder_right - index;</span><br><span class="line">        root.right = dfs(postorder,inorder,postorder_right-size_right,postorder_right-<span class="number">1</span>,index+<span class="number">1</span>,inorder_right);<span class="comment">//构建右子树</span></span><br><span class="line">        root.left = dfs(postorder,inorder,postorder_left,postorder_right-<span class="number">1</span>-size_right,inorder_left,index-<span class="number">1</span>);<span class="comment">//构建左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/path-sum-iii">LeetCode437</a></p><p>​这道题给定一个目标值，要求我们求出给定二叉树路径和为目标值的路径数量。需要注意的是，这里的路径并不是指从根节点到叶子节点，而是任意一个及以上节点形成且只能由父节点指向子节点的路径。比如：</p><img src="../images/算法--二叉树/image-20240217153009329.png" style="zoom:50%;" /><p>在这棵树中：3是一条路径，3-&gt;4是一条路径，4-&gt;5是一条路径，但是4-&gt;3-&gt;7不是路径。</p><p>​其解决方案是利用前缀和的思想，两个节点的前缀和之差就是这两个节点之间的路径和。但仅依靠前缀和还比较麻烦，因为我们需要枚举这两个节点，需要维护两个自由度。但是这道题规定了路径只能由父节点指向子节点，可以转化为给定一个数组和一个目标值，0 &lt; i &lt; j &lt; n，求满足arr[i] + arr[j] &#x3D; target的索引对的数量，比较暴力的做法是两重循环枚举，但更巧妙的做法是用一个哈希表记录这些数出现的数量，这样只需遍历一次。</p><p>​由于规定了路径只能由父节点指向子节点，因此当遍历完当前节点后，需要执行恢复操作。比如以上述二叉树为例，当遍历完节点4后，接着会遍历节点7，为了消除节点4的影响，必须从哈希表中减去它的前缀和。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long,Integer&gt;prefixSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        prefixSum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSum.put(<span class="number">0L</span>,<span class="number">1</span>);<span class="comment">//根节点的前缀和</span></span><br><span class="line">        dfs(root,targetSum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum,<span class="type">long</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (<span class="type">long</span>)root.val;<span class="comment">//前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> prefixSum.getOrDefault(sum - targetSum,<span class="number">0</span>);<span class="comment">//另一个满足要求的节点数量，因为当前节点的前缀和为sum，目标值为target，需要满足要求sum - sum2 = target =&gt; sum2 = sum - target</span></span><br><span class="line">        ans += cnt;<span class="comment">//更新答案</span></span><br><span class="line">        cnt = prefixSum.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(sum,++cnt);<span class="comment">//更新哈希表</span></span><br><span class="line">        dfs(root.left,targetSum,sum);</span><br><span class="line">        dfs(root.right,targetSum,sum);</span><br><span class="line">        cnt = prefixSum.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(sum,--cnt);<span class="comment">//恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree">LeetCode2476</a></p><p>​给定一棵二叉搜索树，所谓二叉搜索树是一棵特殊的二叉树，需要满足以下条件：</p><p>root.val &gt; root.left.val; root.val &lt; root.right.val.再给定对于一个数，要求在这棵树中找到大于等于这个数的最小值max以及小于等于这个数的最大值min。我的思路就是直接根据搜索二叉树的性质直接遍历两次二叉树，分别找到max和min。在一般情况下，其时间复杂度为log(n),是可以通过的，但是本题有一个特殊样例，该二叉树是一条链，其时间复杂度为O(n),会超时。</p><p>​提到搜索二叉树，一定要想到中序遍历。因为搜索二叉树经过中序遍历得到的结果是一个严格递增的序列，这往往是一个突破口。而一般看到题中求解最大值最小，最小值最大，一般可以使用二分进行求解。二分有两种模板，向左寻找的模板可以得到第一个大于等于目标值的数(还有一种特殊情况，整个数组中的数都小于目标值)；向右寻找的模板可以得到第一个小于等于目标值的数(还有一种特殊情况，整个数组中的数都大于目标值)。而这两个数分别对应大于等于目标值的最小值和小于等于目标值的最大值。而二分的时间复杂度是确定的log(n),最后一个样例也能通过。</p><hr><p><a href="https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree">LeetCode2673</a></p><p>​要使得所有叶子节点到根节点的路径和相等，不妨先考虑让互为兄弟的叶子节点到根节点的路径和相等需要的最少操作数。因为这两个叶子节点是兄弟节点，所以它们到根节点之间的cost都一样，因此只需要保证这两个叶子节点的cost一样即可，达到这个目的的最小操作数就是让cost等于它们中较大的那个数。接着使用同样的思路考虑其父节点。</p><p>例如：</p><img src="../images/算法--二叉树/image-20240228115017594.png" style="zoom:50%;" /><p>从最后一个非叶子节点开始枚举(<strong>对于一棵满二叉树，节点个数&#x2F;2为最后一个非叶子节点的编号</strong>)。其左儿子cost为3，右儿子cost为4，因此让它们的cost等于较大的数4，cost[3] &#x3D; 5 + 4 &#x3D; 9.节点2的左儿子cost为2，右儿子cost为4，它们最终的cost为4，cost[2] &#x3D; 4 + 4 &#x3D; 8.于是转化为求让这样一棵满二叉树所有叶子节点到根节点的路径和相等的最小操作数。</p><p>​<img src="../images/算法--二叉树/image-20240228115652973.png" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/03/06/%E7%AE%97%E6%B3%95--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/03/06/%E7%AE%97%E6%B3%95--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h4 id="动态规划题集"><a href="#动态规划题集" class="headerlink" title="动态规划题集"></a>动态规划题集</h4><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array">LeetCode2369</a></p><p>​本题的状态定义为dp[i + 1]表示下标0-i的子数组是否可以是有效划分，状态转移方案为</p><pre><code>      1. nums[i] == nums[i - 1],问题就转化为查看0-(i-2)的子数组是否是有效划分，根据状态定义就是dp[i - 1]      2. nums[i] == nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2],问题就转化为查看0-(i - 3)的子数组是否是有效划分，根据状态定义就是dp[i - 2]      3. nums[i] == nums[i - 1] + 1 &amp;&amp; nums[i - 1] == nums[i - 2] + 1,问题就转化为查看0-(i - 3)的子数组是否是有效划分，根据状态定义就是dp[i - 2]</code></pre><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//dp[i + 1]表示0-i的子数组是否为有效划分</span></span><br><span class="line">        <span class="type">boolean</span> dp[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] || i &gt; <span class="number">1</span> &amp;&amp; dp[i - <span class="number">2</span>] &amp;&amp; (</span><br><span class="line">                nums[i - <span class="number">2</span>] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] || </span><br><span class="line">                nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            ))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟样例：nums[4,4,4,5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">0</span>]:<span class="literal">true</span>;</span><br><span class="line">nums[i] == nums[i-<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">i = <span class="number">2</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">1</span>]:<span class="literal">false</span>;</span><br><span class="line">dp[i-<span class="number">2</span>]=dp[<span class="number">0</span>]:<span class="literal">true</span>;</span><br><span class="line">nums[i-<span class="number">2</span>]=nums[i-<span class="number">1</span>]=nums[i]=<span class="number">4</span>;</span><br><span class="line">dp[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">i = <span class="number">3</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="literal">true</span>,nums[i] != nums[i-<span class="number">1</span>];</span><br><span class="line">dp[i-<span class="number">2</span>]=dp[<span class="number">1</span>]:<span class="literal">false</span>;</span><br><span class="line">i = <span class="number">4</span>:</span><br><span class="line">dp[i-<span class="number">1</span>]=dp[<span class="number">3</span>]=<span class="literal">true</span>,nums[i] != nums[i-<span class="number">1</span>];</span><br><span class="line">dp[i-<span class="number">2</span>]=dp[<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">4</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/longest-palindromic-substring">LeetCode5</a></p><p>​本题要我们求解给定字符串的最长回文子串，最暴力的做法就是遍历每个子串并判断是否为回文串，这种做法需要遍历两个自由度，并且判断子串是否为回文串也需要O(n)的时间复杂度，因此总的时间复杂度为O(n^3^)，会超时。</p><p>​一般遇到这种字符串的题目以及求解最大值最小值方案数，并且数据范围比较大的题，都需要通过动态规划来优化。但是很多人(包括我)都能想到是用动态规划解答，但是不知道如何定义状态，以及如何建立状态转移方程，因此只能干瞪眼，其实最佳做法就是直接去看题解，学习人家是如何定义状态的，以及状态是如何转移的，这样才是最高效的。只有刷了一定的题，有了经验后，或许下次遇到动态规划的题能够成功定义出状态以及建立状态转移方程。</p><p>​言归正传，看了人家的题解后，人家定义的状态是dp[i] [j]：表示[i,j]这个子串是否是回文串(我当时定义的状态是dp[i]：表示[0,i]这个子串是否是回文串，显然是有问题的，因为我这种定义将一个子串的头定死在了开头，这只是所有子串的一部分)。而[i,j]这个子串是否为回文串，可以由[i+1,j-1]这个子串推出，因为如果[i+1，j-1]这个子串是回文串的话，那么只需要保证s[i]&#x3D;&#x3D;s[j]就可以判断[i,j]这个子串是否为回文串。(在构建转移方程时，往往将前一个状态作为切入点，经常可以见到dp[i] &#x3D; dp[i - 1] + …，这也是动态规划比较快的原因：利用了之前求得的数据)。</p><p>dp[i,j] &#x3D; dp[i+1,j-1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]</p><p>​这里有两个特殊点需要特判，当子串长度为1和2时，比如[1,1],[1,2]。如果按照上述转移方程，需要判断dp[2] [0]和dp[2] [1],由于我们的状态定义需要保证i &lt; j，因此这两个状态不会更新，将会导致所有长度为1，2的子串的dp值都是false，这显然是不对的。因此最终的状态转移方程：</p><p>dp[i,j] &#x3D; true, i &#x3D;&#x3D; j；</p><p>dp[i,j] &#x3D; s[i] &#x3D;&#x3D; s[j],j &#x3D;&#x3D; i + 1;</p><p>dp[i,j] &#x3D;&#x3D; dp[i+1,j-1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= n; len ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; n; start ++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(end &gt;= n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[start][end] = (len == <span class="number">1</span> || len == <span class="number">2</span> || dp[start + <span class="number">1</span>][end - <span class="number">1</span>]) &amp;&amp; (s.charAt(start) == s.charAt(end));</span><br><span class="line">                <span class="keyword">if</span>(dp[start][end] &amp;&amp; len &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = len;</span><br><span class="line">                    res = s.substring(start,end + <span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存击穿问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>问题：什么是缓存击穿？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180010990.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180531358.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180806453.png"></p><p>实现互斥锁及其设计细节</p><p>实现逻辑过期</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存雪崩问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>问题：什么是缓存雪崩？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/image-20240301175041871.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存穿透问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>问题：什么是缓存穿透？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/image-20240301172050600.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存更新问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>主要有以下三种缓存更新策略</p><ol><li>内存淘汰：这种策略主要是利用Redis的内存淘汰机制，即当Redis中内存已满时，如果这时又新的数据到来，那么Redis就会按照一定策略淘汰掉一部分数据，从而让新数据进入。常见的淘汰策略有先进先出，最近未被使用(LUR)，最少未被使用等。这种更新策略的优点是不需要维护，又Redis自己维护，缺点是几乎不能保证数据一致性，Redis中可能会同时存在旧数据和新数据。</li><li>超时剔除：这种策略需要我们在Redis存储数据时为其设置一个有效时间，时间一到数据自然剔除，当用户查询数据时，由于缓存中没有该数据，就会从数据库中查找，进而更新进缓存中。因此这种策略具有一定的数据一致性，但是一致性不高，因为如果数据在有效期内发生的变化，需要等到有效期后才会被存储进缓存中，在此期间取出的数据都是旧数据。</li><li>主动更新：当我们修改数据库中的数据时，需要手动的去更新缓存中的数据。具有较好的数据一致性，但是维护成本大。</li></ol><p>需要根据不同业务场景来选择不同的更新策略，低一致性业务可以考虑内存淘汰，因为不需要维护；高一致性业务考虑主动更新。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/image-20240229211619395.png"></p><p>主要有以下三种主动更新方案</p><ol><li>Cache Aside调用者在更新数据库时更新缓存</li><li>Read&#x2F;Write Through缓存和数据库集成为一个服务，服务保证两者一致性，对外提供接口</li><li>调用者只操作缓存，使用一个独立的异步线程每间隔一段时间更新一次数据库</li></ol><p>为什么选择方案1？</p><p>操作缓存和数据库时需要考虑的3个问题</p><ol><li><p>删除缓存还是更新缓存？为什么？</p><p>删除缓存。因为删除缓存可以和更新缓存达到相同的目的，但是性能更好。如果选择更新缓存，意味着当我们更新数据库中的数据时，顺便更新缓存中的数据。而如果选择删除缓存，意味着更新数据库中的数据时，删除缓存中对应的数据，当用户查询该数据时，由于缓存中没有，因此会向数据库中查询，也能得到正确的数据，这样做的好处在于，只有当用户请求对应数据时才会向缓存中存入，节省了内存。</p></li><li><p>如何保证缓存和数据库的操作同时成功或失败？</p><p>通过事务保证删除缓存和更新数据库两个操作的原子性，在分布式系统中需要通过另一种技术实现</p></li><li><p>先操作缓存还是数据库？</p><p>如果选择先删除缓存，由于更新数据库的时间比较长，如果此时来了大量请求，会给数据库造成极大压力；</p></li></ol><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/image-20240229213623162-17096998984914.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目使用缓存进行商户查询</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="使用缓存进行商户查询"><a href="#使用缓存进行商户查询" class="headerlink" title="使用缓存进行商户查询"></a>使用缓存进行商户查询</h4><p><strong>问题：为什么要使用缓存？常见的缓存有哪些？</strong></p><p>​使用缓存能够减少向数据库的查询次数，从而提高性能，缓解数据库压力。常见的缓存技术有连接池、线程池、常量池等。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229192530778.png"></p><img src="../images/Redis--黑马点评项目使用缓存查询商户信息/image-20240229192805575.png" style="zoom:50%;" /><p>以下是查询商户列表使用缓存前后消耗的时间，可以发现，使用缓存后，查询时间从1.52秒提示到了158毫秒，性能得到了极大的提升。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229203438458.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229203525250-17096995639353.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目集群session共享问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="集群session共享问题及解决方案"><a href="#集群session共享问题及解决方案" class="headerlink" title="集群session共享问题及解决方案"></a>集群session共享问题及解决方案</h4><p><strong>问题：之前的设计方案是什么？有什么问题？解决方案是什么？为什么使用这种解决方案(Redis)？</strong></p><p>​当前我们的系统结构作为单体项目是可以的，但是一旦用户量比较大，想要转化为集群项目，这种架构就不行了。主要原因是，当前系统中，我们是基于session来进行数据共享的，但session中的数据只能在同一个服务器中进行共享，如果我们想要扩展为集群项目，使用session就无法做到多个服务器之间数据的共享。因此，必须使用另一种工具作为数据共享。而Redis能够很好的胜任这一要求。</p><p>​1. Redis本身是一个数据库，而数据库本身就是用于存储数据以便进行数据共享的；2. Redis的数据是存放在内存中的，读取速率快，性能好；3. Redis支持各种数据类型，能够很好的满足各种数据的存储。</p><p><strong>验证码存储进Redis以什么作为Key，Value选择什么数据类型？</strong></p><p>​以手机号作为key，value选择String类型即可，为了减少内存消耗，一般会给验证码存储进Redis时设置一个有效期。</p><p>用户信息存储进Redis以什么作为Key，Key的选择需要满足什么条件(唯一，易携带)？为什么不用手机号作为Key？Value选择什么数据类型，为什么选择这种数据类型？</p><p>​key需要具备唯一性以及请求时方便携带的特点。一般使用一个随机化字符串token作为key，如果使用手机号作为key会暴露用户信息，value选择hash类型，hash结构可以将对象中每个字段但独立存储，可以针对单个字段做CRUD</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/image-20240228204035007.png"></p><p><strong>什么是token，它和cookie和session有什么区别？</strong></p><p>​session顾名思义，就是指一种会话技术，由于HTTP协议是无状态协议，当客户端和服务器端建立连接后，它们之间的状态就会断开。这种特点为鉴别用户是否是同一个造成了困难，为了解决该问题，就提供了session机制。当客户端向服务器发送请求时，如果该客户是第一次发送请求，服务器会创建一个session对象用于表示两者建立连接的状态，并生成一个sessionid，sessionid会随着响应报文发送给客户端。客户端收到后会将其存放在cookie中，下一次请求时，请求路径会携带cookie，服务器收到后根据cookie找到对应的session，找到两者的连接。token也是用于鉴权的，它的作用就相当于sessionid，只不过它一般是按照某种加密方式生成的一个字符串，使用token相对于cookie来说更加安全方便，相对于session来说消耗的内存更小，因此现在项目中一般使用token作为鉴权令牌使用。</p><p><strong>如何定期更新Redis中存储的用户信息(用户活跃时不断更新Redis)？以及对其进行优化</strong></p><p>​为了减少内存消耗，一般会给存储进Redis中的数据设置一个有效期，有效期一到，Redis就会自动清除数据。这就会引发一个问题，有时候你用着用着就自动退出登录了。这是我们需要解决的问题，常见的解决方案是，当用户在页面上活跃时，就定期去更新这个有效期。做法就是，再设置一个拦截器，一个拦截器用于更新token有效期，另一个用于鉴权登录。</p><p>​</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/image-20240229172514521.png"></p><p><strong>设置拦截器的执行顺序？</strong></p><p>​需要保证更新token有效期的拦截器先执行，可以通过设置拦截器的order属性来规定拦截器的执行顺序，order值越小，优先级越高。</p><p>​拦截器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.RefreshInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserLoginInteceptorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInteceptorHandler</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">//放行请求，这些请求不做拦截</span></span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher-order/**&quot;</span></span><br><span class="line">                        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拦截器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//token为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看redis中是否有用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="keyword">if</span>(entries.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将map转化为UserDTO类型</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//更新Redis数据</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目初始化</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="开发短信验证登录功能"><a href="#开发短信验证登录功能" class="headerlink" title="开发短信验证登录功能"></a>开发短信验证登录功能</h4><p>开发流程：</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240227194335725.png"></p><h5 id="发送短信模块"><a href="#发送短信模块" class="headerlink" title="发送短信模块"></a>发送短信模块</h5><p>​当点击我的之后会弹出登录页面，要求输入手机号获取验证码，当输入手机号点击发送验证码后，通过抓包发现浏览器会发送如下报文</p><img src="../images/Redis--黑马点评项目初始化/image-20240227195645100.png" alt="image-20240227195645100" style="zoom:50%;" /><p>可以看到，浏览器会以post方式向服务器发送请求，并携带请求参数：phone&#x3D;xxx。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//校验手机号是否合法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">phoneInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">        <span class="comment">//如果不合法</span></span><br><span class="line">        <span class="keyword">if</span>(phoneInvalid)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不合法,请重新输入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果合法，则生成验证码(一个六位数随机数),并保存在session中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">//m</span></span><br><span class="line">        log.debug(<span class="string">&quot;成功发送验证码：&quot;</span> + code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginFormDTO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginFormDTO,HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//验证手机号是否正确</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginFormDTO.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证码是否一致</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginFormDTO.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cachecode</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(code == <span class="literal">null</span> || !cachecode.equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据库中是否有该用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">        <span class="comment">//保存用户</span></span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户保存到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验登录"><a href="#校验登录" class="headerlink" title="校验登录"></a>校验登录</h5><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228195552226.png"></p><p>问题：拦截器和过滤器有什么区别？拦截器的作用是什么？为什么要使用ThreadLocal？详细介绍一下ThreadLocal？</p><p>​拦截器是SpringMVC中提供的类，也是用于拦截请求，和过滤器不同的是，它拦截的是DispatcherServlet和控制器方法之间的请求。而过滤器拦截的是用户和Servlet间的请求。而且过滤器是基于Servlet的，它只能用于web程序，而拦截器是Spring的组件，由Spring控制，不仅能用于web程序，还能用于其他程序。</p><p>​拦截器是基于java反射机制(动态代理实现的)，而过滤器是基于回调函数(doFilter方法)实现的，当一个过滤器执行完后，会调用doFilter方法返回执行上一级Filter</p><p>​鉴于两者都能够拦截请求，因此常被用来作为鉴权登录模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-02-28</span></span><br><span class="line"><span class="comment"> * 校验用户登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginInteceptorHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//查看session中是否有用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//进行拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);<span class="comment">//401表示未得到授权</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserLoginInteceptorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInteceptorHandler</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">//放行请求，这些请求不做拦截</span></span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher-order/**&quot;</span></span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何保护用户敏感信息"><a href="#如何保护用户敏感信息" class="headerlink" title="如何保护用户敏感信息"></a>如何保护用户敏感信息</h5><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228201228430.png"></p><p>​从图中可以看出，当前系统中，当我们登录时，会将用户的一些敏感信息暴露在浏览器中，这非常危险。因此我们需要解决该问题，那么常用的解决方案就是，定义两个用户实体，一个是数据库用户实体，另一个是返回给浏览器的用户实体，后者相对于前者缺少了用户的敏感信息，更加安全，如下图所示。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228202022415-17096985435601.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo结合主题Matery构建绝美博客</title>
      <link href="/2024/03/06/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/06/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>​之前那个主题既不美观也不好用，我就上网搜了搜hexo的主题，发现了matery这个主题。最吸引我的其实不是它绚丽的色彩，而是它可以搜索文章以及热点图的功能，于是我赶紧搜索了一下如何下载该主题。</p><p>​首先点击以下链接访问位于github上的matery主题项目，根据readme文档操作，需要注意的是在复制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>类似以上形式的内容时，在Typora中如果出现了以下情形，需要将多余的”—“删除</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305184436062.png"></p><p>我当时就是没有删除，导致每次我执行hexo s时都会报以下错误</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305184845222.png"></p><p>解决了以上问题后，我又有一个新问题：如何给我的文章分类，这个也很简单(然而当时却花了我不少时间)。按照readme文档的提示，我们在创建文章时，只要在顶部按照格式写上它的信息即可，比如</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305185152689.png"></p><p>就表示这篇文章名称为：hexo结合主题Matery构建绝美博客</p><p>发表日期为：2024-03-05</p><p>作者为：dch</p><p>位于hexo这个类别下</p><p>标签是hexo和matery</p><p>最后附上搭建好的图片</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305185437028.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
