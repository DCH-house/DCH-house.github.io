<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis--黑马点评项目缓存击穿问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>问题：什么是缓存击穿？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180010990.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180531358.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240301180806453.png"></p><p>实现互斥锁及其设计细节</p><p>实现逻辑过期</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存雪崩问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>问题：什么是缓存雪崩？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/image-20240301175041871.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存穿透问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>问题：什么是缓存穿透？如何解决该问题？</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/image-20240301172050600.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目缓存更新问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>主要有以下三种缓存更新策略</p><ol><li>内存淘汰：这种策略主要是利用Redis的内存淘汰机制，即当Redis中内存已满时，如果这时又新的数据到来，那么Redis就会按照一定策略淘汰掉一部分数据，从而让新数据进入。常见的淘汰策略有先进先出，最近未被使用(LUR)，最少未被使用等。这种更新策略的优点是不需要维护，又Redis自己维护，缺点是几乎不能保证数据一致性，Redis中可能会同时存在旧数据和新数据。</li><li>超时剔除：这种策略需要我们在Redis存储数据时为其设置一个有效时间，时间一到数据自然剔除，当用户查询数据时，由于缓存中没有该数据，就会从数据库中查找，进而更新进缓存中。因此这种策略具有一定的数据一致性，但是一致性不高，因为如果数据在有效期内发生的变化，需要等到有效期后才会被存储进缓存中，在此期间取出的数据都是旧数据。</li><li>主动更新：当我们修改数据库中的数据时，需要手动的去更新缓存中的数据。具有较好的数据一致性，但是维护成本大。</li></ol><p>需要根据不同业务场景来选择不同的更新策略，低一致性业务可以考虑内存淘汰，因为不需要维护；高一致性业务考虑主动更新。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/image-20240229211619395.png"></p><p>主要有以下三种主动更新方案</p><ol><li>Cache Aside调用者在更新数据库时更新缓存</li><li>Read&#x2F;Write Through缓存和数据库集成为一个服务，服务保证两者一致性，对外提供接口</li><li>调用者只操作缓存，使用一个独立的异步线程每间隔一段时间更新一次数据库</li></ol><p>为什么选择方案1？</p><p>操作缓存和数据库时需要考虑的3个问题</p><ol><li><p>删除缓存还是更新缓存？为什么？</p><p>删除缓存。因为删除缓存可以和更新缓存达到相同的目的，但是性能更好。如果选择更新缓存，意味着当我们更新数据库中的数据时，顺便更新缓存中的数据。而如果选择删除缓存，意味着更新数据库中的数据时，删除缓存中对应的数据，当用户查询该数据时，由于缓存中没有，因此会向数据库中查询，也能得到正确的数据，这样做的好处在于，只有当用户请求对应数据时才会向缓存中存入，节省了内存。</p></li><li><p>如何保证缓存和数据库的操作同时成功或失败？</p><p>通过事务保证删除缓存和更新数据库两个操作的原子性，在分布式系统中需要通过另一种技术实现</p></li><li><p>先操作缓存还是数据库？</p><p>如果选择先删除缓存，由于更新数据库的时间比较长，如果此时来了大量请求，会给数据库造成极大压力；</p></li></ol><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/image-20240229213623162-17096998984914.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目使用缓存进行商户查询</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="使用缓存进行商户查询"><a href="#使用缓存进行商户查询" class="headerlink" title="使用缓存进行商户查询"></a>使用缓存进行商户查询</h4><p><strong>问题：为什么要使用缓存？常见的缓存有哪些？</strong></p><p>​使用缓存能够减少向数据库的查询次数，从而提高性能，缓解数据库压力。常见的缓存技术有连接池、线程池、常量池等。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229192530778.png"></p><img src="../images/Redis--黑马点评项目使用缓存查询商户信息/image-20240229192805575.png" style="zoom:50%;" /><p>以下是查询商户列表使用缓存前后消耗的时间，可以发现，使用缓存后，查询时间从1.52秒提示到了158毫秒，性能得到了极大的提升。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229203438458.png"></p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E5%95%86%E6%88%B7%E4%BF%A1%E6%81%AF/image-20240229203525250-17096995639353.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目集群session共享问题</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="集群session共享问题及解决方案"><a href="#集群session共享问题及解决方案" class="headerlink" title="集群session共享问题及解决方案"></a>集群session共享问题及解决方案</h4><p><strong>问题：之前的设计方案是什么？有什么问题？解决方案是什么？为什么使用这种解决方案(Redis)？</strong></p><p>​当前我们的系统结构作为单体项目是可以的，但是一旦用户量比较大，想要转化为集群项目，这种架构就不行了。主要原因是，当前系统中，我们是基于session来进行数据共享的，但session中的数据只能在同一个服务器中进行共享，如果我们想要扩展为集群项目，使用session就无法做到多个服务器之间数据的共享。因此，必须使用另一种工具作为数据共享。而Redis能够很好的胜任这一要求。</p><p>​1. Redis本身是一个数据库，而数据库本身就是用于存储数据以便进行数据共享的；2. Redis的数据是存放在内存中的，读取速率快，性能好；3. Redis支持各种数据类型，能够很好的满足各种数据的存储。</p><p><strong>验证码存储进Redis以什么作为Key，Value选择什么数据类型？</strong></p><p>​以手机号作为key，value选择String类型即可，为了减少内存消耗，一般会给验证码存储进Redis时设置一个有效期。</p><p>用户信息存储进Redis以什么作为Key，Key的选择需要满足什么条件(唯一，易携带)？为什么不用手机号作为Key？Value选择什么数据类型，为什么选择这种数据类型？</p><p>​key需要具备唯一性以及请求时方便携带的特点。一般使用一个随机化字符串token作为key，如果使用手机号作为key会暴露用户信息，value选择hash类型，hash结构可以将对象中每个字段但独立存储，可以针对单个字段做CRUD</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/image-20240228204035007.png"></p><p><strong>什么是token，它和cookie和session有什么区别？</strong></p><p>​session顾名思义，就是指一种会话技术，由于HTTP协议是无状态协议，当客户端和服务器端建立连接后，它们之间的状态就会断开。这种特点为鉴别用户是否是同一个造成了困难，为了解决该问题，就提供了session机制。当客户端向服务器发送请求时，如果该客户是第一次发送请求，服务器会创建一个session对象用于表示两者建立连接的状态，并生成一个sessionid，sessionid会随着响应报文发送给客户端。客户端收到后会将其存放在cookie中，下一次请求时，请求路径会携带cookie，服务器收到后根据cookie找到对应的session，找到两者的连接。token也是用于鉴权的，它的作用就相当于sessionid，只不过它一般是按照某种加密方式生成的一个字符串，使用token相对于cookie来说更加安全方便，相对于session来说消耗的内存更小，因此现在项目中一般使用token作为鉴权令牌使用。</p><p><strong>如何定期更新Redis中存储的用户信息(用户活跃时不断更新Redis)？以及对其进行优化</strong></p><p>​为了减少内存消耗，一般会给存储进Redis中的数据设置一个有效期，有效期一到，Redis就会自动清除数据。这就会引发一个问题，有时候你用着用着就自动退出登录了。这是我们需要解决的问题，常见的解决方案是，当用户在页面上活跃时，就定期去更新这个有效期。做法就是，再设置一个拦截器，一个拦截器用于更新token有效期，另一个用于鉴权登录。</p><p>​</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/image-20240229172514521.png"></p><p><strong>设置拦截器的执行顺序？</strong></p><p>​需要保证更新token有效期的拦截器先执行，可以通过设置拦截器的order属性来规定拦截器的执行顺序，order值越小，优先级越高。</p><p>​拦截器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.RefreshInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserLoginInteceptorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInteceptorHandler</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">//放行请求，这些请求不做拦截</span></span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher-order/**&quot;</span></span><br><span class="line">                        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拦截器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//token为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看redis中是否有用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="keyword">if</span>(entries.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将map转化为UserDTO类型</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//更新Redis数据</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--黑马点评项目初始化</title>
      <link href="/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/03/06/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="开发短信验证登录功能"><a href="#开发短信验证登录功能" class="headerlink" title="开发短信验证登录功能"></a>开发短信验证登录功能</h4><p>开发流程：</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240227194335725.png"></p><h5 id="发送短信模块"><a href="#发送短信模块" class="headerlink" title="发送短信模块"></a>发送短信模块</h5><p>​当点击我的之后会弹出登录页面，要求输入手机号获取验证码，当输入手机号点击发送验证码后，通过抓包发现浏览器会发送如下报文</p><img src="../images/Redis--黑马点评项目初始化/image-20240227195645100.png" alt="image-20240227195645100" style="zoom:50%;" /><p>可以看到，浏览器会以post方式向服务器发送请求，并携带请求参数：phone&#x3D;xxx。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//校验手机号是否合法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">phoneInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">        <span class="comment">//如果不合法</span></span><br><span class="line">        <span class="keyword">if</span>(phoneInvalid)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不合法,请重新输入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果合法，则生成验证码(一个六位数随机数),并保存在session中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">//m</span></span><br><span class="line">        log.debug(<span class="string">&quot;成功发送验证码：&quot;</span> + code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginFormDTO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginFormDTO,HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//验证手机号是否正确</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginFormDTO.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证码是否一致</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginFormDTO.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cachecode</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(code == <span class="literal">null</span> || !cachecode.equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据库中是否有该用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">        <span class="comment">//保存用户</span></span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户保存到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验登录"><a href="#校验登录" class="headerlink" title="校验登录"></a>校验登录</h5><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228195552226.png"></p><p>问题：拦截器和过滤器有什么区别？拦截器的作用是什么？为什么要使用ThreadLocal？详细介绍一下ThreadLocal？</p><p>​拦截器是SpringMVC中提供的类，也是用于拦截请求，和过滤器不同的是，它拦截的是DispatcherServlet和控制器方法之间的请求。而过滤器拦截的是用户和Servlet间的请求。而且过滤器是基于Servlet的，它只能用于web程序，而拦截器是Spring的组件，由Spring控制，不仅能用于web程序，还能用于其他程序。</p><p>​拦截器是基于java反射机制(动态代理实现的)，而过滤器是基于回调函数(doFilter方法)实现的，当一个过滤器执行完后，会调用doFilter方法返回执行上一级Filter</p><p>​鉴于两者都能够拦截请求，因此常被用来作为鉴权登录模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-02-28</span></span><br><span class="line"><span class="comment"> * 校验用户登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginInteceptorHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//查看session中是否有用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//进行拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);<span class="comment">//401表示未得到授权</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserLoginInteceptorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInteceptorHandler</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">//放行请求，这些请求不做拦截</span></span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher-order/**&quot;</span></span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何保护用户敏感信息"><a href="#如何保护用户敏感信息" class="headerlink" title="如何保护用户敏感信息"></a>如何保护用户敏感信息</h5><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228201228430.png"></p><p>​从图中可以看出，当前系统中，当我们登录时，会将用户的一些敏感信息暴露在浏览器中，这非常危险。因此我们需要解决该问题，那么常用的解决方案就是，定义两个用户实体，一个是数据库用户实体，另一个是返回给浏览器的用户实体，后者相对于前者缺少了用户的敏感信息，更加安全，如下图所示。</p><p><img src="/../images/Redis--%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240228202022415-17096985435601.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 黑马点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo结合主题Matery构建绝美博客</title>
      <link href="/2024/03/06/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/06/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>​之前那个主题既不美观也不好用，我就上网搜了搜hexo的主题，发现了matery这个主题。最吸引我的其实不是它绚丽的色彩，而是它可以搜索文章以及热点图的功能，于是我赶紧搜索了一下如何下载该主题。</p><p>​首先点击以下链接访问位于github上的matery主题项目，根据readme文档操作，需要注意的是在复制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>类似以上形式的内容时，在Typora中如果出现了以下情形，需要将多余的”—“删除</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305184436062.png"></p><p>我当时就是没有删除，导致每次我执行hexo s时都会报以下错误</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305184845222.png"></p><p>解决了以上问题后，我又有一个新问题：如何给我的文章分类，这个也很简单(然而当时却花了我不少时间)。按照readme文档的提示，我们在创建文章时，只要在顶部按照格式写上它的信息即可，比如</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305185152689.png"></p><p>就表示这篇文章名称为：hexo结合主题Matery构建绝美博客</p><p>发表日期为：2024-03-05</p><p>作者为：dch</p><p>位于hexo这个类别下</p><p>标签是hexo和matery</p><p>最后附上搭建好的图片</p><p><img src="/../images/hexo%E7%BB%93%E5%90%88%E4%B8%BB%E9%A2%98Matery%E6%9E%84%E5%BB%BA%E7%BB%9D%E7%BE%8E%E5%8D%9A%E5%AE%A2/image-20240305185437028.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
